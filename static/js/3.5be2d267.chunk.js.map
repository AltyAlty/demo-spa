{"version":3,"sources":["components/Profile/ProfileInfo/ProfileInfo.module.css","components/Profile/MyPosts/MyPosts.module.css","components/Profile/MyPosts/Post/Post.module.css","assets/images/profilelogo.jpg","components/Profile/ProfileInfo/ProfileStatusWithHooks.tsx","components/Profile/ProfileInfo/ProfileDataForm.tsx","components/Profile/ProfileInfo/ProfileInfo.tsx","components/Profile/MyPosts/Post/Post.tsx","components/Profile/MyPosts/MyPosts.tsx","components/Profile/MyPosts/MyPostsContainer.tsx","components/Profile/Profile.tsx","components/Profile/ProfileContainer.tsx"],"names":["module","exports","ProfileStatusWithHooks","isOwner","updateUserStatus","props","useState","editMode","setEditMode","status","setStatus","useEffect","onDoubleClick","onChange","event","currentTarget","value","onFocus","target","select","autoFocus","onBlur","console","error","ProfileDataReduxForm","reduxForm","form","handleSubmit","profile","onSubmit","className","styles","formSummaryError","createField","Input","Object","keys","contacts","map","key","style","contact","type","Textarea","ProfileData","activateEditMode","onClick","fullName","aboutMe","contactTitle","contactValue","lookingForAJob","lookingForAJobDescription","Contact","ProfileInfo","saveUserPhoto","saveProfile","Preloader","profileImage","src","profileLogoSource","alt","descriptionBlock","photos","large","userPhoto","files","length","initialValues","formData","then","Post","avatar","message","likes","item","maxLength10","maxLengthCreator","AddPostReduxForm","required","MyPosts","React","memo","postsData","addPost","postsElements","p","id","likesCount","postsBlock","newPostText","posts","connect","state","profilePage","profileAC","Profile","MyPostsContainer","ProfileContainer","userID","this","match","params","authUserID","history","push","getUserProfile","getUserStatus","refreshProfile","prevProps","prevState","Component","compose","auth","withRouter"],"mappings":"qGACAA,EAAOC,QAAU,CAAC,iBAAmB,sCAAsC,aAAe,kCAAkC,UAAY,+BAA+B,QAAU,+B,oBCAjLD,EAAOC,QAAU,CAAC,WAAa,4BAA4B,MAAQ,yB,oBCAnED,EAAOC,QAAU,CAAC,KAAO,qB,iKCDV,MAA0B,wC,yDCiL1BC,EAnHqC,SAAC,GAA0C,IAAzCC,EAAwC,EAAxCA,QAAQC,EAAgC,EAAhCA,iBAAqBC,EAAW,iBAO1F,EAA8BC,oBAAS,GAAvC,mBAAKC,EAAL,KAAeC,EAAf,KAKA,EAA0BF,mBAASD,EAAMI,QAAzC,mBAAKA,EAAL,KAAaC,EAAb,KAUAC,qBAAU,WAQND,EAAUL,EAAMI,UAEhB,CAACJ,EAAMI,SAqCX,OACI,qCACMF,GAUF,8BACKJ,EACK,gCAAK,uCAAL,KAAoB,sBAAMS,cA/CnB,WACrBJ,GAAY,IA8CsB,SAAwCH,EAAMI,QAAU,yBAC5E,+BAAOJ,EAAMI,QAAU,OAKhCF,GAYD,gCACI,uBAAOM,SAnDQ,SAACC,GAIxBJ,EAAUI,EAAMC,cAAcC,QAgDfC,QA7CC,SAACH,GAGjBA,EAAMI,OAAOC,UA2CEC,WAAW,EACXC,OAjEQ,WAGvBb,GAAY,GACRC,EACAL,EAAiBK,GAEjBa,QAAQC,MAAM,yBA2DHP,MAAOP,IALlB,W,kCC0FGe,EAZcC,YAAkE,CAO3FC,KAAM,eAPmBD,EAlHzB,SAAC,GAKoC,IAHZE,EAGW,EAHXA,aAEAC,EACW,EADXA,QACAL,EAAW,EAAXA,MA6BzB,OACI,uBAAMM,SAAUF,EAAhB,cAEI,oCAEI,6CAGHJ,GAAS,qBAAKO,UAAWC,IAAOC,iBAAvB,SAA0CT,IAPxD,IAWI,oCACI,6CADJ,IAEKU,YAA2C,YAAa,WAAYC,IAAO,OAMhF,oCACI,4CADJ,IAEKD,YAA2C,WAAY,UAAWC,IAAO,OAM9E,oCAEI,4CAFJ,KAEyBC,OAChBC,KAAKR,EAAQS,UACbC,KAAI,SAAAC,GAKT,OACI,sBAAeT,UAAWU,IAAMC,QAAhC,cAGI,8BAAIF,EAAJ,KAAWN,YAAYM,EAAK,YAAcA,EAAKL,IAAO,SAHhDK,SAiBlB,oCACI,yDACCN,YACA,GAAI,iBAAkBC,IAAO,GAAI,CAACQ,KAAM,gBAM7C,oCACI,2CACCT,YACA,aAAc,4BAA6BU,IAAU,aCehEC,EAA8C,SAAC,GAA0C,IAAzChB,EAAwC,EAAxCA,QAASzB,EAA+B,EAA/BA,QAAS0C,EAAsB,EAAtBA,iBAepE,OACI,oCACK1C,GAAW,oCAER,wBAAQ2C,QAASD,EAAjB,kBAFQ,OAOZ,gCAAK,6CAAL,KAA2BjB,EAAQmB,YARvC,IAWI,gCAAK,4CAAL,KAA0BnB,EAAQoB,WAXtC,IAcI,oCAEI,4CAFJ,KAEyBb,OAChBC,KAAKR,EAAQS,UACbC,KAAI,SAAAC,GAIT,OAAO,cAAC,EAAD,CAESU,aAAcV,EACdW,aAActB,EAAQS,SAASE,IAH1BA,SAUzB,gCAAK,yDAAL,IAAsCX,EAAQuB,eAAiB,uCAAmB,yCAKjFvB,EAAQuB,gBAAkB,gCAAK,2CAAL,IAAwBvB,EAAQwB,6BArC/D,QAkEFC,EAAsC,SAAC,GAAkC,IAAjCJ,EAAgC,EAAhCA,aAAcC,EAAkB,EAAlBA,aAWxD,OAAO,sBAAKpB,UAAWC,IAAOU,QAAvB,UAAgC,4BAAIQ,IAApC,KAAwDC,MAMpDI,EA5OqC,SAAC,GAa9C,IATkBnD,EASnB,EATmBA,QAEAyB,EAOnB,EAPmBA,QACAnB,EAMnB,EANmBA,OACAL,EAKnB,EALmBA,iBACAmD,EAInB,EAJmBA,cAEAC,EAEnB,EAFmBA,YAGrB,EAA8BlD,oBAAS,GAAvC,mBAAKC,EAAL,KAAeC,EAAf,KAWA,IAAKoB,EACD,OAAO,cAAC6B,EAAA,EAAD,IAoCX,OACI,oCACI,sBAAK3B,UAAWC,IAAO2B,aAAvB,cAEI,qBAAKC,IAAKC,EAAmBC,IAAI,KAFrC,OAMA,sBAAK/B,UAAWC,IAAO+B,iBAAvB,cAEI,qBAAKH,IAAK/B,EAAQmC,OAAOC,OAASC,IAAWnC,UAAWC,IAAOkC,UAAWJ,IAAI,KAFlF,IAMK1D,GAAW,uBAAOuC,KAAM,OAAQ7B,SA/CjB,SAACC,GAA0C,IAAD,GAKlE,UAAIA,EAAMI,OAAOgD,aAAjB,aAAI,EAAoBC,SAGpBZ,EAAczC,EAAMI,OAAOgD,MAAM,OAiCjC,IAaI,cAAC,EAAD,CAAwBzD,OAAQA,EACjBL,iBAAkBA,EAElBD,QAASA,IAIvBI,EAiBK,cAAC,EAAD,CAAsB6D,cAAexC,EAASC,SAlE/C,SAACwC,GASdb,EAAYa,GAAUC,MAClB,WACI9D,GAAY,OAuD4DoB,QAASA,IAC3E,cAAC,EAAD,CAAaA,QAASA,EAASzB,QAASA,EAAS0C,iBAxF1C,WAErBrC,GAAY,a,4CCxFP+D,EAA4B,SAAC,GAA8B,IAA7BC,EAA4B,EAA5BA,OAAQC,EAAoB,EAApBA,QAASC,EAAW,EAAXA,MAYxD,OACI,sBAAK5C,UAAWC,IAAO4C,KAAvB,cAGI,qBAAKhB,IAAKa,EAAQX,IAAI,KAH1B,IAMKY,EANL,IASI,8BAAK,2CAAcC,OATvB,QCsDFE,EAAcC,YAAiB,IA+E/BC,EAAmBrD,YAA0D,CAO/EC,KAAM,sBAPeD,EAnDrB,SAAC,GAAoB,IAAnBE,EAAkB,EAAlBA,aA2BF,OACI,uBAAME,SAAUF,EAAhB,cAEI,oCAEKM,YACA,qBAAsB,cAAeU,IAAU,CAACoC,IAAUH,OAM/D,oCAEI,uDAkHDI,EAtE6BC,IAAMC,MAAK,YAA2B,IAAzBC,EAAwB,EAAxBA,UAAWC,EAAa,EAAbA,QA+B5DC,EAAgBF,EAAU7C,KAAI,SAAAgD,GAAC,OAAI,cAAC,EAAD,CAAMC,GAAID,EAAEC,GACAd,QAASa,EAAEb,QACXC,MAAOY,EAAEE,WACThB,OAAQc,EAAEd,QACLc,EAAEC,OAiB1D,OACI,sBAAKzD,UAAWC,IAAO0D,WAAvB,cAEI,0CAFJ,IAGI,cAACX,EAAD,CAAkBjD,SAnBT,SAACwC,GAKde,EAAQf,EAASqB,aAEjBrB,EAASqB,YAAc,MASvB,IAWI,qBAAK5D,UAAWC,IAAO4D,MAAvB,SAA+BN,IAXnC,U,SChLOO,eAVS,SAACC,GAIrB,MAAO,CACHV,UAAWU,EAAMC,YAAYX,aAMjC,CAACC,QAASW,IAAUX,SADTQ,CAMbZ,GCCagB,EA7CsB,SAAC,GAKmB,IALlBpE,EAKiB,EALjBA,QACAnB,EAIiB,EAJjBA,OACAL,EAGiB,EAHjBA,iBACAD,EAEiB,EAFjBA,QACAoD,EACiB,EADjBA,cACAC,EAAiB,EAAjBA,YAmBnC,OACI,oCAEI,cAAC,EAAD,CAAa5B,QAASA,EACTnB,OAAQA,EACRL,iBAAkBA,EAElBD,QAASA,EAEToD,cAAeA,EAEfC,YAAaA,IAK1B,cAACyC,EAAD,QCyDNC,E,oKAEF,WAEI,IAAIC,GAAyBC,KAAK/F,MAAMgG,MAAMC,OAAOH,OAMhDA,IACDA,EAASC,KAAK/F,MAAMkG,aAEhBH,KAAK/F,MAAMmG,QAAQC,KAAK,WAK3BN,GAKDC,KAAK/F,MAAMqG,eAAeP,GAG1BC,KAAK/F,MAAMsG,cAAcR,IALzB7E,QAAQC,MAAM,+C,+BAWtB,WAEI6E,KAAKQ,mB,gCAGT,SACCC,EAAqBC,GAKdV,KAAK/F,MAAMgG,MAAMC,OAAOH,SAAWU,EAAUR,MAAMC,OAAOH,QAK1DC,KAAKQ,mB,oBAIb,WAMI,OACI,cAAC,EAAD,2BAAaR,KAAK/F,OAAlB,IAGSF,SAAUiG,KAAK/F,MAAMgG,MAAMC,OAAOH,c,GA9DxBlB,IAAM8B,WAwFtBC,sBAKXpB,aAjBoB,SAACC,GAAD,MAA+C,CAInEjE,QAASiE,EAAMC,YAAYlE,QAE3BnB,OAAQoF,EAAMC,YAAYrF,OAE1B8F,WAAYV,EAAMoB,KAAK1B,MASiE,CAMpFmB,mBACAC,kBACAvG,qBACAmD,kBAEAC,kBAEJ0D,IAlBWF,CAmBbd","file":"static/js/3.5be2d267.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"descriptionBlock\":\"ProfileInfo_descriptionBlock__3IFpJ\",\"profileImage\":\"ProfileInfo_profileImage__1regV\",\"userPhoto\":\"ProfileInfo_userPhoto__2cgvG\",\"contact\":\"ProfileInfo_contact__1pgdA\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"postsBlock\":\"MyPosts_postsBlock__3XkAy\",\"posts\":\"MyPosts_posts__16GbP\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"item\":\"Post_item__1JDJo\"};","export default __webpack_public_path__ + \"static/media/profilelogo.de89eaed.jpg\";","import React, {useState, useEffect, ChangeEvent} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\nПодключаем хук \"useEffect\", который принимает функцию первым параметром и выполняет ее, когда произойдет\r\nотрисовка компонента, то есть после каждого вызова \"render\". Вторым параметром этот хук принимает зависимости -\r\nзависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то\r\nэтот хук сработает только один раз. Этот хук используется для side effects.\r\nИмпортируем \"ChangeEvent\" для типизации событий.\r\n*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    status: string | null /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип \"null\",\r\n    то есть быть пустыми.*/\r\n    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля, должно быть булева типа.*/\r\n    updateUserStatus: (status: string) => void /*TC для изменения данных по статусу пользователя на странице профиля\r\n    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/\r\n};\r\n\r\n\r\n/*\r\n\"ProfileStatusWithHooks\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileStatusWithHooks(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"ProfileInfo\".\r\nКомпонент \"ProfileStatusWithHooks\" предоставляет реализацию статуса пользователя на странице пользователя.\r\nСтатус пользователя представляет из себя поле статуса как в ВК, на который можно нажать и активировать поле для ввода\r\nстатуса, а если убрать фокус с этого поля, то будет просто текст.\r\n*/\r\nconst ProfileStatusWithHooks: React.FC<PropsType> = ({isOwner,updateUserStatus, ...props}) => {/*Указываем\r\nкакие именно \"props\" мы получаем, чтобы не писать далее \"props.isOwner\", и так далее:\r\n- \"isOwner\" - свойство, которое показывает является ли залогиненный пользователь владельцем профиля;\r\n- \"updateUserStatus\" - TC для изменения данных по статусу пользователя на странице профиля.\r\nТакое мы делаем только в функциональных компонентах. Не указываем здесь свойства \"status\", а при помощи деструктуризации\r\n\"...props\" прокидываем это свойство в этот компонент, так как в самом компоненте уже используется своя переменная с\r\nименем \"status\".  Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n    let [editMode, setEditMode] = useState(false); /*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет означать\r\n    включен или выключен режим редактирования статуса (изначально \"false\"). Вторая переменная будет хранить функцию\r\n    из хука \"useState\", которая будет изменять первый элемент (то есть включать или выключать режим редактирования\r\n    статуса).*/\r\n    let [status, setStatus] = useState(props.status);/*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет хранить\r\n    значение статуса (изначально берется из \"props\"). Вторая переменная будет хранить функцию из хука \"useState\",\r\n    которая будет изменять первый элемент (то редактировать статус).*/\r\n\r\n    /*Поскольку \"useState\" содержит массив с двумя элементами, то аналог мог бы быть такой:\r\n    let stateWithSetState = useState(false);\r\n    let editMode = stateWithSetState[0];\r\n    let setEditMode = stateWithSetState[1];*/\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы избежать бага, когда не успевал загружаться статус\r\n    с сервера во время первого редактирования после загрузки компонента. Когда после загрузки страницы мы входили в\r\n    режим редактирования статуса, то поле было пустым, так как локальный \"status\", созданный при помощи хука \"useState\",\r\n    был пустым, поскольку иногда компонент загружался раньше, чем получался статус с сервера. То есть отображалось\r\n    пустое поле, так как изначально это пустое поле указано в статусе в нашем BLL. И это пустое поле подхватывалось\r\n    нашим \"status\" раньше данных о статусе, полученных из запроса на сервер. Поэтому сейчас мы отслеживаем изменения\r\n    статуса в глобальном \"state\" и при каждом таком изменении вызываем функцию \"setStatus\", то есть теперь получение\r\n    запоздавших данных о статусе с сервера будет триггерить изменение локального \"status\".*/\r\n        setStatus(props.status); /*Первый параметр это функция для редактирования статуса при помощи хука \"useState\".*/\r\n    },\r\n        [props.status] /*Второй параметр это значение статуса из глобального \"state\". Если это значение будет\r\n        меняться, то будет срабатывать каждый раз функция из первого параметра.*/\r\n    );\r\n\r\n    const activateEditMode = () => { /*Создали функцию, которая при вызове активирует режим редактирования статуса.*/\r\n        setEditMode(true);\r\n    };\r\n\r\n    const deactivateEditMode = () => { /*Создали функцию, которая при вызове деактивирует режим редактирования статуса\r\n    и обновляет значение статуса в глобальном \"state\" при помощи TC \"updateUserStatus\" для изменения\r\n    статуса пользователя на странице профиля.*/\r\n        setEditMode(false);\r\n        if (status) { /*Здесь делаем дополнительную проверку на наличие статуса для целей типизации типизации.*/\r\n            updateUserStatus(status)\r\n        } else { /*Если же статус отсутствует, то выводим ошибку в консоль.*/\r\n            console.error('Status should exist ')\r\n        };\r\n    };\r\n\r\n    const onUserStatusChange = (event: ChangeEvent<HTMLInputElement>) => { /*Создали специальный метод\r\n    \"onUserStatusChange\", который будет вызываться при изменении поля \"input\", брать текущее значение содержимого этого\r\n    поля и сохранять его в локальный \"state\" при помощи хука \"useState\". Для события \"event\" указали тип\r\n    \"ChangeEvent<HTMLInputElement>\"*/\r\n        setStatus(event.currentTarget.value)\r\n    };\r\n\r\n    const handleFocus = (event: ChangeEvent<HTMLInputElement>) => { /*Создали специальный метод \"handleFocus\" для\r\n    автоматического выделения текста в поле статуса пользователя. Для события \"event\" указали тип\r\n    \"ChangeEvent<HTMLInputElement>\"*/\r\n        event.target.select();\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {!editMode && /*Если режим редактирования статуса пользователя отключен и мы являемся владельцем страницы,\r\n            то отрисуется элемент \"div\", внутри которого будет элемент \"span\", содержащий обработчик события двойного\r\n            нажатия по элементу \"onDoubleClick\". При срабатывании этого события активируется метод \"activateEditMode\"\r\n            через callback, чтобы активировать режим редактирования статуса пользователя. Внутри элемента \"span\"\r\n            будет отображаться текущее значение статуса пользователя из \"props\", а при его отсуствии будет надпись\r\n            \"Enter your status\". Если мы же не являемся владельцем профиля, то мы не сможем перейти в режим\r\n            редактирования, только увидеть сам статус. Здесь есть небольшая проблема - после ввода нового статуса\r\n            какое-то время будет отображен старый статус, пока не завершится запрос на сервер на изменение\r\n            этого статуса. Одним из вариантов решений этой проблемы может быть добавление заглушки \"Preloader\" на время\r\n            пока идет запрос.*/\r\n            <div>\r\n                {isOwner\r\n                    ? <div><b>Status</b>: <span onDoubleClick={activateEditMode}>{props.status || 'Enter your status'}</span></div>\r\n                    : <span>{props.status || ''}</span>\r\n                }\r\n            </div>\r\n            }\r\n\r\n            {editMode && /*Если режим редактирования статуса пользователя включен, то\r\n            отрисуется элемент \"div\", внутри которого будет элемент \"input\", содержащий обработчик события потери фокуса\r\n            с элемента \"onBlur\". При срабатывании этого события активируется метод \"deactivateEditMode\"\r\n            через callback, чтобы деактивировать режим редактирования статуса пользователя и сохранить новый статус\r\n            в глобальном \"state\". Также у элемента \"input\" указан атрибут \"autoFocus\" для автоматического фокуса\r\n            на элементе. Внутри элемента \"input\" будет отображаться текущее значение статуса пользователя при помощи\r\n            атрибута \"value\" из локального \"state\" при помощи хука \"useState\". Также внутри элемента \"input\" содержится\r\n            обработчик события появления фокуса на элементе \"onFocus\", при срабатывании которого активируется\r\n            метод \"handleFocus\" через callback, чтобы автоматически выделить текст статуса пользователя. Еще внутри\r\n            элемента \"input\" содержится обработчик события изменения поля \"input\" \"onChange\", при срабатывании которого\r\n            активируется метод \"onUserStatusChange\" через callback, чтобы брать текущее значение содержимого\r\n            этого поля и сохранять его в локальный \"state\" при помощи хука \"useState\".*/\r\n            <div>\r\n                <input onChange={onUserStatusChange}\r\n                       onFocus={handleFocus}\r\n                       autoFocus={true}\r\n                       onBlur={deactivateEditMode}\r\n                       value={status as string}/> {/*Поскольку в нашей типизации указано, что статус может быть \"null\",\r\n                       то тут нам пришлось указать, что он всегда воспринимался как строка при помощи \"as string\".*/}\r\n            </div>\r\n            }\r\n        </div>\r\n    );\r\n};\r\n\r\n\r\nexport default ProfileStatusWithHooks; /*Экспортируем компонент \"ProfileStatusWithHooks\" по default и будем его\r\nиспользовать в нашем проекте под именем \"ProfileStatusWithHooks\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"ProfileDataForm\".\r\n- обворачиваем компонент \"ProfileDataForm\" HOC-ом \"reduxForm\" в компоненте \"ProfileDataReduxForm\", тем самым\r\nпредоставляя callback \"handleSubmit\" для компонента \"ProfileDataForm\".\r\n- компонент \"ProfileDataReduxForm\" указывается в компоненте \"ProfileInfo\" в файле \"ProfileInfo.tsx\", куда в\r\nсобытие \"onSubmit\" будет попадать объект с данными, сформированный в событии \"onSubmit\" при помощи\r\ncallback \"handleSubmit\" в компоненте \"ProfileDataForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"ProfileDataForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"onSubmit\" (доступен из контейнерного компонента \"ProfileDataReduxForm\") из компонента \"ProfileInfo\"\r\nв файле \"ProfileInfo.tsx\", в который передается указанный объект с данными и собираются в одном месте, потом эти данные\r\nпередаются в компонент \"ProfileDataReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под\r\nименем \"editProfile\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n\r\nВ компонент \"ProfileDataForm\" внедряются некие дополнительные \"props\" (например, тот же \"handleSubmit\") ХОКом, который\r\nобразуется при помощи компонента \"ProfileDataReduxForm\". Эти \"props\" содержатся под именем \"InjectedFormProps\". Эти\r\n\"InjectedFormProps\" также содержат добавленные нами \"props\". Поэтому мы импортировали \"InjectedFormProps\" из библиотеки\r\n\"reduxForm\", чтобы типизировать такие \"props\" в компоненте \"ProfileDataForm\".\r\n*/\r\n\r\nimport {createField, GetValuesKeysType, Input, Textarea} from '../../common/FormsControls/FormsControls'; /*Подключаем\r\nсозданный нами компонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию. Также\r\nподключаем созданный нами компонент \"Input\" для создания элемента \"input\" с возможностью указывать валидацию. Также\r\nимпортируем функцию \"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания\r\nформы в компоненте \"ProfileDataForm\". Дополнительно импортируем оттуда тип \"GetValuesKeysType\".*/\r\n\r\nimport style from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport styles from '../../common/FormsControls/FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {ProfileType} from '../../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"ProfileDataForm\". \"Собственные props\" в этом компоненте должны\r\nобязательно содержать следующие поля с указанными типами.*/\r\ntype ProfileDataFormOwnPropsType = {\r\n    profile: ProfileType /*Информация о профиле пользователя, полученная с сервера должна быть типа \"PostType\"\r\n    или иметь тип \"null\", то есть быть пустой. Тип \"PostType\" был создан нами и импортирован сюда. Не указываем здесь\r\n    \"any\" или пустой объект, так как сверху этому компоненту приходит \"profile\" из компонента \"ProfileInfo\" из файла\r\n    \"ProfileInfo.tsx\".*/\r\n};\r\n\r\n/*Создаем тип для \"props\" компонента \"ProfileDataForm\", которые будут использоваться в \"formData\" для компонента\r\n\"ProfileInfo\" в файле \"ProfileInfo.tsx\". Эти \"props\" в этом компоненте должны обязательно содержать следующие поля с\r\nуказанными типами.*/\r\nexport type ProfileDataFormValuesType = ProfileType; /*В \"formData\" находятся данные по пользователю в виде объекта\r\nс типом \"ProfileType\", который мы создали и импортировали сюда.*/\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства \"name\" в \"createField\".\r\nЭто свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы использовали созданный\r\nнами и иимпортированный сюда вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"ProfileDataFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"ProfileDataFormValuesType\".*/\r\ntype ProfileDataFormValuesKeysType = GetValuesKeysType<ProfileDataFormValuesType>;\r\n\r\n\r\n/*\r\n\"ProfileDataForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileDataForm\" является компонентом, который представляет из себя форму для редактирования профиля пользователя\r\nна странице профиля в виде заготовки для обворачивания ее в HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"ProfileDataReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым\r\nполучая callback \"handleSubmit\".\r\n*/\r\nconst ProfileDataForm:\r\n    React.FC<InjectedFormProps<ProfileDataFormValuesType, ProfileDataFormOwnPropsType> & ProfileDataFormOwnPropsType> =\r\n    ({ /*Указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.handleSubmit\", \"props.profile\" и так\r\n    далее. Такое мы делаем только в функциональных компонентах.*/\r\n                             handleSubmit, /*Callback для\r\n                             сабмита данных.*/\r\n                             profile, /*Данные профиля пользователя для страницы профиля.*/\r\n                             error}) => { /*Свойство, содержащее текст ошибки (если была). Свойство \"error\" будет\r\n                             в объекте \"props\" благодаря библиотеке \"redux-form\", в него подцепится значение из TC\r\n                             \"saveProfile\" из \"profile-reducer.ts\".*/\r\n\r\n    /*Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип\r\n    \"InjectedFormProps<ProfileDataFormValuesType, ProfileDataFormOwnPropsType> & ProfileDataFormOwnPropsType>\". Такая\r\n    комбинация получилась следующим образом:\r\n    - \"InjectedFormProps<ProfileDataFormValuesType, ProfileDataFormOwnPropsType>\" - здесь мы уточнили внедренные ХОКом,\r\n    который образуется при помощи компонента \"ProfileDataReduxForm\", \"InjectedFormProps\". \"ProfileDataFormValuesType\"\r\n    указывает, что приходит из этого ХОКа, а \"ProfileDataFormOwnPropsType\" указывает, что приходит со стороны -\r\n    \"profile\".\r\n    - \"& ProfileDataFormOwnPropsType\" - также этот компонент содержит некие свои собственные \"props\", которые не\r\n    приходят от ХОКа выше - тот же \"profile\".\r\n    Это мы сделали на основании файла декларации \"InjectedFormProps\" (\"Ctrl+click\" в \"WebStorm\"). Там указано, что\r\n    первым параметром принимаются \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого\r\n    обворачиваем \"reduxForm\" (то есть компонент \"ProfileDataForm\"), и собственные \"props\" этого компонента\r\n    \"ProfileDataForm\", которые не приходят от ХОКа выше (так нужно для внутренней работы \"InjectedFormProps\"); а вторым\r\n    параметром принимаются еще раз некие свои собственные \"props\", которые не приходят от ХОКа выше (так уже надо для\r\n    работы самого этого компонента \"ProfileDataForm\"). Третьим параметром принимается вид ошибки формы типа строка, но\r\n    данном случае мы этого не указываем. Только все эти три параметра указываются как бы вместе как единый параметр, а\r\n    не через запятую как три разных параметра. ВОЗМОЖНО, это потому, что \"InjectedFormProps\" это объект (как единое\r\n    целое состоит из разных свойств, которые можно типизировать суммой разных типов), а тот же \"reduxForm\" это функция\r\n    (принимает последовательность параметров, где каждый параметр нужно отдельно типизировать).*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указывает\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>save</button>\r\n            </div>\r\n\r\n            {error && <div className={styles.formSummaryError}>{error}</div>} {/*Если произошла какая-то ошибка, то\r\n            выведем ее в отдельном элементе \"div\". Свойство \"error\" будет в объекте \"props\" благодаря\r\n            библиотеке \"redux-form\", в него подцепится значение из TC \"saveProfile\" из \"profile-reducer.ts\".*/}\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для ввода полного имени пользователя.*/}\r\n                <b>1. Full Name</b>:\r\n                {createField<ProfileDataFormValuesKeysType>(\"Full Name\", \"fullName\", Input, [])}\r\n                {/*Создали поле для ввода полного имени пользователя на основе импортированной функции \"createField\".\r\n                Уточняем здесь функцию \"createField\", что она имеет тип \"ProfileDataFormValuesKeysType\", созданный нами\r\n                выше.*/}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для ввода информации о пользователе \"Обо мне\".*/}\r\n                <b>2. About Me</b>:\r\n                {createField<ProfileDataFormValuesKeysType>(\"About Me\", \"aboutMe\", Input, [])}\r\n                {/*Создали поле для ввода информации о пользователе \"Обо мне\" на основе импортированной функции\r\n                \"createField\". Уточняем здесь функцию \"createField\", что она имеет тип \"ProfileDataFormValuesKeysType\",\r\n                созданный нами выше.*/}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поля для ввода контактов пользователя. Создаются эти поля\r\n            следующим образом (аналогично как и в компоненте \"ProfileData\" из файла \"ProfileInfo.tsx\"):*/}\r\n                <b>3. Contacts</b>: {Object\r\n                    .keys(profile.contacts)\r\n                    .map(key => { /*При помощи метода \"keys\" глобального объекта \"Object\" мы можем проитерироваться по\r\n                    ключам переданного объекта \"profile.contacts\". Возьмутся все ключи \"key\" и завернутся в массив\r\n                    строк. А далее мы мапим этот массив, чтобы отрисовать JSX с однотипным полями контактов при помощи\r\n                    небольшого куска JSX (в компоненте \"ProfileData\" из файла \"ProfileInfo.tsx\" для такого JSX мы\r\n                    создавали вспомогательную компоненту \"Contact\").*/\r\n                return (\r\n                    <div key={key} className={style.contact}> {/*Отрисовываем элемент \"div\", который представляет\r\n                    из себя типовое поле для указания контакта. При использовании метода \"map\" нужно указывать\r\n                    атрибут \"key\" для избежания ошибок.*/}\r\n                        <b>{key}: {createField(key, \"contacts.\" + key, Input, [])}</b>\r\n                        {/*Внутри этот элемент \"div\" будет из себя представлять следующее:\r\n                         \"Текст заголовка поля контакта\": \"Текст со значение самого контакта\". Первое будет браться\r\n                         из ключа \"key\". Второе будет создаваться на основе импортированной функции \"createField\".\r\n                         \"name\" во втором будет получаться так: к тексту \"contacts.\" будет прибавляться текст ключа\r\n                         (например, \"github\"), что в итоге будет давать правильную структуру контактов (например,\r\n                         \"contacts.github\") для составления объекта с контактами, который сможет понять сервер\r\n                         при получении объекта с данным по профилю пользователя. Здесь отсутствует уточнение типа у\r\n                         функции \"createField\", поэтому в дальнейшем его необходимо добавить сюда.*/}\r\n                    </div>\r\n                )\r\n            })}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для указания ищет ли в данный момент работу пользователь.*/}\r\n                <b>4. Is looking for a job?</b>\r\n                {createField<ProfileDataFormValuesKeysType>\r\n                (\"\", \"lookingForAJob\", Input, [], {type: \"checkbox\"})}\r\n                {/*Создали поле для указания ищет ли в данный момент работу пользователь на основе импортированной\r\n                функции \"createField\". Уточняем здесь функцию \"createField\", что она имеет тип\r\n                \"ProfileDataFormValuesKeysType\", созданный нами выше.*/}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для ввода работы, которую ищет пользователь.*/}\r\n                <b>Which one?</b>\r\n                {createField<ProfileDataFormValuesKeysType>\r\n                (\"Which one?\", \"lookingForAJobDescription\", Textarea, [])}\r\n                {/*Создали поле для ввода работы, которую ищет пользователь, на основе импортированной\r\n                функции \"createField\". Уточняем здесь функцию \"createField\", что она имеет тип\r\n                \"ProfileDataFormValuesKeysType\", созданный нами выше.*/}\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"ProfileDataForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"ProfileDataFormReduxForm\" будет заниматься общением\r\nс глобальным \"state\". Далее этот компонент используется в компоненте \"ProfileInfo\" в файле \"ProfileInfo.tsx\" */\r\nconst ProfileDataReduxForm = reduxForm<ProfileDataFormValuesType, ProfileDataFormOwnPropsType>({ /*\"reduxForm\"\r\nявляется \"generic\", поэтому мы его уточнили. В файле декларации \"reduxForm\" (\"Ctrl+click\" в \"WebStorm\") указано, что он\r\nпринимает следующие данные:\r\n- \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого обворачиваем \"reduxForm\" (то\r\nесть компонент \"ProfileDataForm\");\r\n- \"собственные props\" компонента, вокруг которого обворачиваем \"reduxForm\" (то есть компонент \"ProfileDataForm\");\r\n- вид ошибки формы типа строка, но данном случае мы этого не указываем.*/\r\n    form: 'editProfile' /*Это то самое уникальное имя для данных этой формы, которые будут попадать\r\n    в глобальный \"state\".*/\r\n})(ProfileDataForm);\r\n\r\n\r\nexport default ProfileDataReduxForm; /*Экспортируем компонент \"ProfileDataReduxForm\" по default и будем его использовать\r\nв нашем проекте под именем \"ProfileDataReduxForm\", экспорт необходим для импорта.*/","import React, {ChangeEvent, useState} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\n\"ChangeEvent\" импортировали для типизации событий.\r\n*/\r\n\r\nimport styles from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport userPhoto from '../../../assets/images/user.png'; /*Импортируем из ассетов аватар на случай, если у пользователя\r\nнет фото.*/\r\nimport profileLogoSource from '../../../assets/images/profilelogo.jpg'; /*Импортируем из ассетов лого для страницы\r\nпрофиля.*/\r\n\r\nimport {Preloader} from '../../common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\r\nimport ProfileStatus from './ProfileStatus'; /*Подключаем компонент \"ProfileStatus\", но в данный момент\r\nне используется (аналог компонента \"ProfileStatusWithHooks\", но без хуков).*/\r\nimport ProfileStatusWithHooks from './ProfileStatusWithHooks'; /*Подключаем компонент \"ProfileStatusWithHooks\".*/\r\nimport ProfileDataReduxForm, {ProfileDataFormValuesType} from './ProfileDataForm'; /*Подключаем компонент\r\n\"ProfileDataFormReduxForm\". Так же импортируем оттуда тип \"ProfileDataFormValuesType\".*/\r\n\r\nimport {ContactsType, ProfileType} from '../../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем общий тип для всех \"props\" компонента \"ProfileInfo\". Все это нужно для указания типа \"props\" в функциональном\r\nкомпоненте \"ProfileInfo\".*/\r\ntype ProfileInfoPropsType = {\r\n    profile:ProfileType | null /*Информация о профиле пользователя, полученная с сервера должна быть типа \"PostType\"\r\n    или иметь тип \"null\", то есть быть пустой. Тип \"PostType\" был создан нами и импортирован сюда.*/\r\n    status: string | null /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип \"null\",\r\n    то есть быть пустыми.*/\r\n    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля, должно быть булева типа.*/\r\n    updateUserStatus: (status: string) => void /*TC для изменения данных по статусу пользователя на странице профиля\r\n    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/\r\n    saveUserPhoto: (photoFile: File) => void /*TC для загрузки фото пользователя на странице профиля и дальнейшего его\r\n    отображения в нашем приложении должен быть функцией, которая принимает объект с фото пользователя, которое типа\r\n    \"File\" из \"TypeScript\" и ничего не возвращает.*/\r\n    saveProfile: (profile: ProfileType) => Promise<any> /*TC для отправки новых данных профиля пользователя на странице\r\n    профиля и дальнейшего их отображения в нашем приложении должен быть функцией, которая принимает объект типа\r\n    \"ProfileType\" и возвращает какой-либо промис, так как мы здесь используем \"then.\" вместе с этим TC.*/\r\n};\r\n\r\n/*Создаем тип для \"props\" компонента \"ProfileData\".*/\r\ntype ProfileDataPropsType = {\r\n    profile:ProfileType /*Информация о профиле пользователя, полученная с сервера должна быть типа \"PostType\"\r\n    или иметь тип \"null\", то есть быть пустой. Тип \"PostType\" был создан нами и импортирован сюда.*/\r\n    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля, должно быть булева типа.*/\r\n    activateEditMode: () => void /*Функция, которая при вызове активирует режим редактирования профиля пользователя,\r\n    должна быть функцией, которая ничего не принимает и не возвращает. Это функция создается в компоненте \"ProfileInfo\"\r\n    и передается в компонент \"ProfileData\".*/\r\n};\r\n\r\n/*Создаем тип для \"props\" компонента \"ContactPropsType\".*/\r\ntype ContactPropsType = {\r\n    contactTitle: string /*Текст заголовка контакта должен быть строкой.*/\r\n    contactValue: string /*Значение контакта должен быть строкой.*/\r\n};\r\n\r\n\r\n/*\r\n\"ProfileInfo\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileInfo(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileInfo\" является компонентом, который содержит информацию о пользователе.\r\nЭтот компонент подключается в компоненте \"Profile\".\r\nВнутри компонента \"Profile\" подключаются компоненты:\r\n- \"Preloader\", который является компонентом-заглушкой, который используется, чтобы показать анимацию загрузки в других\r\nкомпонентах, когда идет какой-то процесс в них (например, AJAX-запрос);\r\n- \"ProfileStatusWithHooks\", который отвечает за отображение и редактирование статуса пользователя на странице профиля\r\n(сделан на хуках);\r\n- \"ProfileStatus\", который отвечает за отображение и редактирование статуса пользователя на странице профиля (в данный\r\nмомент не используется);\r\n- \"ProfileDataFormReduxForm\", который ;\r\n- \"ProfileData\", который является внутренним вспомогательным компонентом для компонента \"ProfileInfo\", который содержит\r\nданные профиля пользователя и интерфейс для перехода в режим редактирования этой информации.\r\n*/\r\nconst ProfileInfo: React.FC<ProfileInfoPropsType> = ({/*Указали при помощи \"React.FC<>\", что \"props\" в этом\r\nфункциональном компоненте имеют тип \"ProfileInfoPropsType\", созданный нами выше. Также указываем какие именно \"props\"\r\nмы получаем, чтобы не писать далее \"props.isOwner\", \"props.profile\" и так далее. Такое мы делаем только в функциональных\r\nкомпонентах.*/\r\n                         isOwner, /*Свойство, которое показывает является ли залогиненный пользователь\r\n                         владельцем профиля, который в данный момент отображается на странице профиля.*/\r\n                         profile, /*Данные профиля пользователя для страницы профиля.*/\r\n                         status, /*Данные статуся пользователя для страницы профиля.*/\r\n                         updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/\r\n                         saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его\r\n                         отображения в нашем приложении.*/\r\n                         saveProfile /*TC для отправки новых данных профиля пользователя на странице профиля и\r\n                         дальнейшего их отображения в нашем приложении.*/\r\n}) => {\r\n    let [editMode, setEditMode] = useState(false); /*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет означать\r\n    включен или выключен режим редактирования профиля пользователя (изначально \"false\"). Вторая переменная будет\r\n    хранить функцию из хука \"useState\", которая будет изменять первый элемент (то есть включать или выключать режим\r\n    редактирования профиля пользователя).*/\r\n\r\n    const activateEditMode = () => { /*Создали функцию, которая при вызове активирует режим редактирования\r\n    профиля пользователя.*/\r\n        setEditMode(true);\r\n    };\r\n\r\n    if (!profile) { /*Если данные профиля пользователя отсутствуют, то отрисовываем компонент-заглушку \"Preloader\".*/\r\n        return <Preloader/>\r\n    }\r\n\r\n    const onUserPhotoSelected = (event: ChangeEvent<HTMLInputElement>) => { /*Создали функцию, которая при вызове\r\n    сначала проверяет, что массив файлов с фото пользователя не пустой, и если он не пустой, то потом отправляет первый\r\n    файл из этого массива в TC \"saveUserPhoto\" для загрузки фото пользователя на сервер и дальнейшего его отображения в\r\n    нашем приложении. Эта функция будет срабатывать как callback, когда пользователь выбирает изображение. Для события\r\n    \"event\" указали тип \"ChangeEvent<HTMLInputElement>\".*/\r\n        if (event.target.files?.length) { /*Здесь указали \"?\", чтобы не было ошибки связанной с типизацией, поскольку\r\n        \"files\" может не быть. Вместо этого можно было написать так:\r\n        \"if (event.target.files && event.target.files.length)\", такая бы проверка тоже удовлетворила \"TypeScript\".*/\r\n            saveUserPhoto(event.target.files[0]);\r\n        }\r\n    };\r\n\r\n    const onSubmit = (formData: ProfileDataFormValuesType) => { /*Создали callback функцию, которая при вызове совершает\r\n    сабмит данных, то есть собирает данные формы и вызывает TC \"saveProfile\" для отправки новых данных профиля\r\n    пользователя на странице профиля и дальнейшего их отображения в нашем приложении, передав ему эти данные. Далее\r\n    будет ожидание промиса. При успешном выполнении промиса деактивируется режим редактирования профиля пользователя.\r\n    Если от сервера придет ошибка, то промис будет отклонен и режим редактирования профиля пользователя не будет\r\n    деактивирован (так работает этот TC \"saveProfile\"). Если здесь использовать \"async/await\" вместо \".then\", то\r\n    работать не будет. Этот callback получает указанные данные на входе в объекте \"formData\" с типом\r\n    \"ProfileDataFormValuesType\". Стоит здесь также отметить, что такое использование \".then\" в компонентах не\r\n    желательно, поэтому в дальнейшем нужно найти другое решение.*/\r\n        saveProfile(formData).then(\r\n            () => {\r\n                setEditMode(false);\r\n            }\r\n        );\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <div className={styles.profileImage}> {/*Этот элемент \"div\" содержит изображение из шапки страницы\r\n            профиля.*/}\r\n                <img src={profileLogoSource} alt=''/> {/*Отрисовываем элемент \"img\", который содержит изображение\r\n                из шапки страницы профиля.*/}\r\n            </div>\r\n\r\n            <div className={styles.descriptionBlock}> {/*Этот элемент \"div\" содержит данные профиля пользователя\r\n            на странице профиля.*/}\r\n                <img src={profile.photos.large || userPhoto} className={styles.userPhoto} alt=''/> {/*Отрисовываем\r\n                элемент \"img\", в котором будет отображаться фото пользователя, а если данных по фото пользователя от\r\n                сервера получено не было, то отобразится аватар из ассетов проекта.*/}\r\n\r\n                {isOwner && <input type={'file'} onChange={onUserPhotoSelected}/>} {/*Если пользователь является\r\n                владельцем открытого в данным момент профиля, то отрисуется элемент \"input\" с \"type\" равным \"file\"\r\n                (т.е. можно загрузить файл) с событием при изменении \"onUserPhotoSelected\" для загрузки\r\n                фото пользователя.*/}\r\n\r\n                {/*Отрисовываем компонент \"ProfileStatusWithHooks\" и передаем ему через \"props\" необходимые для\r\n                него данные.*/}\r\n                <ProfileStatusWithHooks status={status} /*Данные статуся пользователя для страницы профиля.*/\r\n                               updateUserStatus={updateUserStatus} /*TC для изменения статуса пользователя\r\n                               на странице профиля.*/\r\n                               isOwner={isOwner} /*Свойство, которое показывает является ли залогиненный пользователь\r\n                               владельцем профиля, который в данный момент отображается на странице профиля.*/\r\n                />\r\n\r\n                {editMode /*Если режим редактирования включен, то отрисуется компонент \"ProfileDataReduxForm\", получив\r\n                стартовые значения \"initialValues\" (взято из библиотеки \"redux-form\") для полей формы, данные\r\n                автоматически раскидаются по полям в зависимости от их имен, чтобы при переходе в режим редактирования\r\n                профиля поля не были пустыми, если она уже имели какую-то информацию. При подтверждении формы в этом\r\n                компоненте сработает callback \"onSubmit\" для сабмита данных. Также передаем в компонент\r\n                \"ProfileDataFormReduxForm\" объект с данными профиля пользователя \"profile\" для его маппинга и создания\r\n                полей для редактирования контактов пользователя (смотри реализацию самого компонента).\r\n\r\n                Если же режим редактирования выключен, то отрисуется компонент \"ProfileData\" для отображения профиля\r\n                пользователя. В него мы передаем объект с данными профиля пользователя \"profile\", и свойство \"isOwner\",\r\n                так как нам нужно знать является ли пользователь владельцем открытого в данный момент профиля, поскольку\r\n                только владелец своего профиля должен иметь право его редактировать. Также в этот компонент мы передаем\r\n                callback \"activateEditMode\" для активации режима редактирования профиля пользователя.\r\n\r\n                Здесь есть проблема, когда мы быстро переключаемся с чужого профиля на свой профиль - в этот момент\r\n                сразу же появляется кнопка для редактирования профиля, и если ее сразу нажать, то в полях будут данные\r\n                чужого профиля, а не своего, так как данные нашего профиля не успели еще подгрузиться.*/\r\n                    ? <ProfileDataReduxForm initialValues={profile} onSubmit={onSubmit} profile={profile}/>\r\n                    : <ProfileData profile={profile} isOwner={isOwner} activateEditMode={activateEditMode}/>\r\n                }\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\n\r\n/*\r\n\"ProfileData\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileData\" является внутренним вспомогательным компонентом для компонента \"ProfileInfo\", который содержит данные\r\nпрофиля пользователя и интерфейс для перехода в режим редактирования этой информации.\r\nЭтот компонент подключается в компоненте \"ProfileInfo\".\r\n*/\r\nconst ProfileData: React.FC<ProfileDataPropsType> = ({profile, isOwner, activateEditMode}) => {\r\n    /*Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"ProfileDataPropsType\",\r\n    созданный нами выше. Также указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.profile\",\r\n    \"props.isOwner\" и так далее:\r\n    - \"profile\" - данные профиля пользователя для страницы профиля;\r\n    - \"isOwner\" - свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля;\r\n    - \"activateEditMode\" - функция, которая при вызове активирует режим редактирования профиля пользователя.\r\n    Такое мы делаем только в функциональных компонентах.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {isOwner && <div> {/*Если пользователь является владельцем открытого профиля, то отображаем\r\n            элемент \"div\",*/}\r\n                <button onClick={activateEditMode}>Edit</button> {/*внутри которого есть элемент \"button\", для\r\n                отображения кнопки перехода в режим редактирования данных профиля, для чего указано событие\r\n                при нажатии \"activateEditMode\".*/}\r\n            </div>}\r\n\r\n            <div><b>1. Full Name</b>: {profile.fullName}</div> {/*Этот элемент \"div\" содержит полное имя пользователя,\r\n            которое берется из \"props\".*/}\r\n\r\n            <div><b>2. About Me</b>: {profile.aboutMe}</div> {/*Этот элемент \"div\" содержит информацию о пользователе\r\n            \"Обо мне\", которая берется из \"props\".*/}\r\n\r\n            <div> {/*Этот элемент \"div\" содержит контакты пользователя, которые берутся из \"props\". Создаются\r\n            следующим образом:*/}\r\n                <b>3. Contacts</b>: {Object\r\n                    .keys(profile.contacts)\r\n                    .map(key => { /*При помощи метода \"keys\" глобального объекта \"Object\" мы можем проитерироваться по\r\n                    ключам переданного объекта \"profile.contacts\". Возьмутся все ключи \"key\" и завернутся в массив\r\n                    строк. А далее мы мапим этот массив, чтобы отрисовать однотипный JSX с полями контактов при помощи\r\n                    компонента \"Contact\".*/\r\n                return <Contact key={key} /*При использовании метода \"map\" нужно указывать атрибут \"key\"\r\n                                для избежания ошибок.*/\r\n                                contactTitle={key} /*Заголовок поля контакта.*/\r\n                                contactValue={profile.contacts[key as keyof ContactsType]} /*Значение поля контакта в\r\n                                соответствии с заголовком. Здесь указали \"as keyof ContactsType\", чтобы \"TypeScript\"\r\n                                понял, что это данные из свойств типа \"ContactsType\".*/\r\n                />\r\n            })}\r\n            </div>\r\n\r\n            <div><b>4. Is looking for a job?</b> {profile.lookingForAJob ? <span>Yes</span> : <span>No</span>}</div>\r\n            {/*Этот элемент \"div\" содержит информацию ищет ли в данный момент работу пользователь. Если свойство\r\n            \"lookingForAJob\", которое берется из \"props\", является \"TRUE\", то отрисуется элемент \"span\" с текстом \"Yes\",\r\n            иначе отрисуется элемент \"span\" с текстом \"No\".*/}\r\n\r\n            {profile.lookingForAJob && <div><b>Which one?</b> {profile.lookingForAJobDescription}</div>} {/*Если\r\n            свойство \"lookingForAJob\", которое берется из \"props\", является \"TRUE\", то отрисуется элемент \"div\"\r\n            с текстом из \"lookingForAJobDescription\", который означает работу, которую ищет пользователь.*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n/*\r\n\"Contact\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Contact(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Contact\" является внутренним вспомогательным компонентом для компонента \"ProfileData\", который содержит заготовку\r\nдля полей контактов пользователя, который используется в маппинге для отрисовки однотипного JSX.\r\nЭтот компонент подключается в компоненте \"ProfileData\".\r\n*/\r\nconst Contact: React.FC<ContactPropsType> = ({contactTitle, contactValue}) => { /*Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"ContactPropsType\", созданный нами выше. Также\r\nуказываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.contactTitle\" и так далее:\r\n- \"contactTitle\" - текст заголовка контакта;\r\n- \"contactValue\" - значение контакта.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return <div className={styles.contact}><b>{contactTitle}</b>: {contactValue}</div>\r\n    {/*Этот элемент \"div\" и есть наш корневой элемент. Внутри он будет из себя представлять следующее:\r\n    \"Текст заголовка поля контакта\": \"Текст со значение самого контакта\".*/}\r\n};\r\n\r\n\r\nexport default ProfileInfo; /*Экспортируем компонент \"ProfileInfo\" по default и будем его использовать в нашем проекте\r\nпод именем \"ProfileInfo\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Post.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Создаем общий тип для всех \"props\" компонента \"Post\". Все это нужно для указания типа \"props\" в функциональном\r\nкомпоненте \"Post\".*/\r\ntype PropsType = {\r\n    id: number /*\"ID\" поста должно быть числом. Мы это здесь не используем, но указываем, так как передаем этот \"ID\" в\r\n    компоненте \"MyPosts\" в компонент \"Post\" при использовании функции \"map\".*/\r\n    message: string /*Текст поста должен быть строкой.*/\r\n    likes: number /*Количество лайков должно быть числом.*/\r\n    avatar: string /*Путь к аватару пользователя должен быть строкой.*/\r\n};\r\n\r\n\r\n/*\r\n\"Post\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Post(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Post\" является компонентом, который описывает, как должны выглядеть посты пользователя в его профиле.\r\nЭтот компонент подключается в компоненте \"MyPosts\".\r\n*/\r\nexport const Post: React.FC<PropsType> = ({avatar, message, likes}) => { /*Указываем какие именно\r\n\"props\" мы получаем, чтобы не писать далее \"props.avatar\", \"props.message\" и так далее:\r\n- \"avatar\" - путь к аватару пользователя;\r\n- \"message\" - текст поста;\r\n- \"likes\" - количество лайков.\r\nТакое мы делаем только в функциональных компонентах. Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном\r\nкомпоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.item}> {/*Этот элемент \"div\" и есть наш корневой элемент. Этот элемент представляет из\r\n        себя типовое отображение постов пользователя в его профиле, которое будет отрисовываться в компоненте \"MyPosts\"\r\n        при помощи метода \"map\".*/}\r\n            <img src={avatar} alt=''/> {/*Пост пользователя в его профиле содержит аватар пользователя, ссылка на\r\n            который берется из параметров \"props\".*/}\r\n\r\n            {message} {/*Также пост пользователя в его профиле содержит текст этого поста, которое берется из параметров\r\n            \"props\".*/}\r\n\r\n            <div><span>likes: {likes}</span></div> {/*А также пост пользователя в его профиле содержит количество лайков\r\n            у этого поста, которое берется из параметров \"props\".*/}\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"AddPostForm\".\r\n- обворачиваем компонент \"AddPostForm\" HOC-ом \"reduxForm\" в компоненте \"AddPostReduxForm\", тем самым предоставляя\r\ncallback \"handleSubmit\" для компонента \"AddPostForm\".\r\n- компонент \"AddPostReduxForm\" указывается в компоненте \"MyPosts\", куда в событие \"onSubmit\" будет попадать\r\nобъект с данными, сформированный в событии \"onSubmit\" при помощи callback \"handleSubmit\" в компоненте \"AddPostForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"AddPostForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"addNewPost\" (доступен из контейнерного компонента \"AddPostReduxForm\") из компонента \"MyPosts\",\r\nв который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент\r\n\"AddPostReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под именем \"profileAddPostForm\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n\r\nВ компонент \"AddPostForm\" внедряются некие дополнительные \"props\" (например, тот же \"handleSubmit\") ХОКом, который\r\nобразуется при помощи компонента \"AddPostReduxForm\". Эти \"props\" содержатся под именем \"InjectedFormProps\". Эти\r\n\"InjectedFormProps\" также содержат добавленные нами \"props\". Поэтому мы импортировали \"InjectedFormProps\" из библиотеки\r\n\"reduxForm\", чтобы типизировать такие \"props\" в компоненте \"AddPostForm\".\r\n*/\r\nimport {maxLengthCreator, required} from '../../../utils/validators/validators'; /*Подключаем валидаторы для полей\r\nформ.*/\r\nimport {createField, GetValuesKeysType, Textarea} from '../../common/FormsControls/FormsControls'; /*Подключаем\r\nсозданный нами компонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию. Также\r\nимпортируем функцию \"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания\r\nформы в компоненте \"AddPostForm\". Дополнительно импортируем оттуда тип \"GetValuesKeysType\".*/\r\n\r\nimport styles from './MyPosts.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {Post} from './Post/Post'; /*Подключаем компонент \"Post\".*/\r\n\r\nimport {PostType} from '../../../types/types';\r\n\r\n\r\n/*Создаем общий тип для всех \"props\" компонента \"MyPosts\". Все это нужно для указания типа \"props\" в функциональном\r\nкомпоненте \"MyPosts\".*/\r\ntype MyPostsPropsType = {\r\n    postsData: Array<PostType> /*Данные о постах на странице пользователя должны быть массивом с элементами с типом\r\n    \"PostType\". Тип \"PostType\" был создан нами и импортирован сюда.*/\r\n    addPost: (newMessageText: string) => void /*AC для добавления нового поста на странице профиля, который принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n};\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"AddPostForm\". \"Собственные props\" в этом компоненте должны\r\nобязательно содержать следующие поля с указанными типами.*/\r\ntype AddPostFormOwnPropsType = {}; /*Указываем пустой объект, так как компонент \"AddPostForm\" не содержит \"собственных\r\nprops\".*/\r\n\r\n/*Создаем тип для \"props\" компонента \"AddPostForm\", которые будут использоваться в \"formData\" для компонента \"MyPosts\".\r\nЭти \"props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.*/\r\ntype AddPostFormValuesType = {\r\n    newPostText: string /*Текст нового поста на странице профиля, который должен быть строкой.*/\r\n};\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства \"name\" в \"createField\".\r\nЭто свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы использовали созданный\r\nнами и иимпортированный сюда вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"AddPostFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"AddPostFormValuesType\".*/\r\ntype AddPostFormValuesKeysType = GetValuesKeysType<AddPostFormValuesType>;\r\n\r\n\r\nconst maxLength10 = maxLengthCreator(10); /*Создали валидатор, который проверяет не введено ли больше 10\r\nсимволов в поле.*/\r\n\r\n\r\n/*\r\n\"AddPostForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function AddPostForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"AddPostForm\" является компонентом, который представляет из себя форму для добавления постов в профиле пользователя\r\nв виде заготовки для обворачивания ее в HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"AddPostReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым\r\nполучая callback \"handleSubmit\".\r\n*/\r\nconst AddPostForm:\r\n    React.FC<InjectedFormProps<AddPostFormValuesType, AddPostFormOwnPropsType> & AddPostFormOwnPropsType> =\r\n    ({handleSubmit}) => {\r\n    /*При помощии деструктуризации \"props\" указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n    \"props.handleSubmit\". Такое мы делаем только в функциональных компонентах.\r\n    Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип\r\n    \"InjectedFormProps<AddPostFormValuesType, AddPostFormOwnPropsType> & AddPostFormOwnPropsType>\". Такая\r\n    комбинация получилась следующим образом:\r\n    - \"InjectedFormProps<AddPostFormValuesType, AddPostFormOwnPropsType>\" - здесь мы уточнили внедренные ХОКом, который\r\n    образуется при помощи компонента \"AddPostReduxForm\", \"InjectedFormProps\". \"AddPostFormValuesType\" указывает, что\r\n    приходит из этого ХОКа, а \"AddPostFormOwnPropsType\" указывает, что приходит со стороны - в нашем случае ничего.\r\n    - \"& AddPostFormOwnPropsType\" - также этот компонент содержит некие свои собственные \"props\", которые не приходят от\r\n    ХОКа выше.\r\n    Это мы сделали на основании файла декларации \"InjectedFormProps\" (\"Ctrl+click\" в \"WebStorm\"). Там указано, что\r\n    первым параметром принимаются \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого\r\n    обворачиваем \"reduxForm\" (то есть компонент \"AddPostForm\"), и собственные \"props\" этого компонента \"AddPostForm\",\r\n    которые не приходят от ХОКа выше (так нужно для внутренней работы \"InjectedFormProps\"); а вторым параметром\r\n    принимаются еще раз некие свои собственные \"props\", которые не приходят от ХОКа выше (так уже надо для работы самого\r\n    этого компонента \"AddPostForm\"). Третьим параметром принимается вид ошибки формы типа строка, но данном случае мы\r\n    этого не указываем. Только все эти три параметра указываются как бы вместе как единый параметр, а не через запятую\r\n    как три разных параметра. ВОЗМОЖНО, это потому, что \"InjectedFormProps\" это объект (как единое целое состоит из\r\n    разных свойств, которые можно типизировать суммой разных типов), а тот же \"reduxForm\" это функция (принимает\r\n    последовательность параметров, где каждый параметр нужно отдельно типизировать).*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указывает\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            <div> {/*Создаем элемент \"div\", в котором создадим поле для ввода текста нового поста пользователя на\r\n            странице профиля при помощи импортированной функции \"createField\".*/}\r\n                {createField<AddPostFormValuesKeysType>\r\n                (\"Enter your message\", \"newPostText\", Textarea, [required, maxLength10])}\r\n                {/*Создали поле для ввода нового поста пользователя на странице профиля на основе импортированной\r\n                функции \"createField\". Уточняем здесь функцию \"createField\", что она имеет тип\r\n                \"AddPostFormValuesKeysType\", созданный нами выше.*/}\r\n            </div>\r\n\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>Add post</button>\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"AddPostForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"AddPostReduxForm\" будет заниматься общением\r\nс глобальным \"state\".*/\r\nconst AddPostReduxForm = reduxForm<AddPostFormValuesType, AddPostFormOwnPropsType>({ /*\"reduxForm\" является\r\n\"generic\", поэтому мы его уточнили. В файле декларации \"reduxForm\" (\"Ctrl+click\" в \"WebStorm\") указано, что он\r\nпринимает следующие данные:\r\n- \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого обворачиваем \"reduxForm\" (то\r\nесть компонент \"AddPostForm\");\r\n- \"собственные props\" компонента, вокруг которого обворачиваем \"reduxForm\" (то есть компонент \"AddPostForm\");\r\n- вид ошибки формы типа строка, но данном случае мы этого не указываем.*/\r\n    form: 'profileAddPostForm' /*Это то самое уникальное имя для данных этой формы, которые будут попадать\r\n    в глобальный \"state\".*/\r\n})(AddPostForm);\r\n\r\n\r\n/*\r\n\"MyPosts\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function MyPosts(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"MyPosts\" является компонентом, который отображает посты на странице профиля пользователя.\r\nЭтот компонент подключается в компоненте \"DialogsContainer\".\r\nВнутри компонента \"MyPosts\" подключается компонент \"AddPostReduxForm\", в котором обворачиваем компонент \"AddPostForm\"\r\nHOC-ом \"reduxForm\", тем самым предоставляя callback \"handleSubmit\" для компонента \"AddPostForm\".\r\n*/\r\nconst MyPosts: React.FC<MyPostsPropsType> = React.memo(({postsData, addPost}) => { /*Изначально это был\r\nклассовый компонент и он отрисовывался несколько лишних раз. Но, вроде, если использовать \"connect\", то лишних отрисовок\r\nне будет. В любом случае, мы сделали этот компонент функциональным, чтобы избежать этих лишних перерисовок. Для этого мы\r\nи использовали \"React.memo()\" (вроде это HOC), что содержит оптимизацию этих перерисовок, чтобы обвернуть этим наш\r\nфункциональный компонент.\r\nТакже указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.postsData\" и так далее:\r\n- \"postsData\" - данные о постах на странице пользователя;\r\n- \"addPost\" - AC для добавления нового поста на странице профиля.\r\nТакое мы делаем только в функциональных компонентах.\r\nТакже указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип\r\n\"MyPostsPropsType\", созданный нами выше.*/\r\n\r\n    /*\r\n    В JSX в массив можно вкладывать компоненты.\r\n    В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде строки.\r\n    \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования исходного массива.\r\n    Метод \"map\" принимает стрелочную функцию.\r\n    То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n    и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    Потом будет браться следующий объект из исходного массива объектов\r\n    и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n    То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов.\r\n    В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n    Массив \"postsElements\" содержит посты пользователя в его профиле.\r\n    При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n    */\r\n    let postsElements = postsData.map(p => <Post id={p.id}\r\n                                                       message={p.message}\r\n                                                       likes={p.likesCount}\r\n                                                       avatar={p.avatar}\r\n                                                       key={p.id}/>);\r\n\r\n    let addNewPost = (formData: AddPostFormValuesType) => { /*Создали специальный callback \"addNewPost\", который будет\r\n    вызываться при срабатывании события \"onSubmit\" в форме. Этот callback будет собирать все данные формы (текст нового\r\n    поста пользователя на странице профиля) в одном месте. Эти данные будут отдаваться AC \"addPost\" для добавляния\r\n    нового поста пользователя на странице профиля. Этот callback получает указанные данные на входе в объекте \"formData\"\r\n    с типом \"AddPostFormValuesType\".*/\r\n        addPost(formData.newPostText); /*Здесь мы вызываем AC \"addPost\", полученный из \"props\", и передаем ему\r\n        текст нового поста пользователя на странице профиля.*/\r\n        formData.newPostText = ''; /*После вывода поста зануляем поле для ввода текста.*/\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.postsBlock}> {/*Этот элемент \"div\" и есть наш корневой элемент. Он из себя представляет\r\n        блок с постами пользователя.*/}\r\n            <h3>My posts</h3> {/*При помощи элемента \"h3\" создаем заголовок для блока постов пользователя.*/}\r\n            <AddPostReduxForm onSubmit={addNewPost}/> {/*Здесь в событии \"onSubmit\" будет приходить объект с данными\r\n            из callback \"handleSubmit\" из компонента \"AddPostForm\", который обвернут компонентом \"AddPostReduxForm\".\r\n            Далее будет вызываться при этом событии нами созданный callback \"addNewPost\", в который будет передаваться\r\n            этот объект с данными. После этого эти данные будут отправлятся в часть глобального \"state\", которую\r\n            обрабатывает библиотека \"redux-form\", с целью осуществления работы нашей формы логина. Поскольку мы вызываем\r\n            функцию \"addNewPost\" как callback, поэтому не ставим \"()\" после имени функции. Но теперь после отправки\r\n            поста окно для ввода текста поста не будет очищаться, так как библиотека \"redux-form\" хоть и осуществляет\r\n            FLUX-круговорот, но очистку не осуществляет.*/}\r\n            <div className={styles.posts}>{postsElements}</div> {/*Отрисовываем посты пользователя.*/}\r\n        </div>\r\n    );\r\n});\r\n\r\n\r\nexport default MyPosts; /*Экспортируем компонент \"MyPosts\" по default и будем его использовать в нашем проекте под\r\nименем \"MyPosts\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\n\r\nimport MyPosts from './MyPosts'; /*Подключаем компонент \"MyPosts\".*/\r\n\r\nimport {profileAC} from '../../../redux/profile-reducer';/*Подключаем объект \"profileAC\", что использовать оттуда АC\r\n\"addPostActionCreator\" из \"profile-reducer\".*/\r\n\r\nimport {PostType} from '../../../types/types'; /*Подключаем типы.*/\r\nimport {AppStateType} from '../../../redux/redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"MapStateToProps\". \"MapStateToProps\" в этом компоненте должен обязательно содержать следующие поля с\r\nуказанными типами.*/\r\ntype MapStateToPropsType = {\r\n    postsData: Array<PostType> /*Данные о постах на странице пользователя должны быть массивом с элементами с типом\r\n    \"PostType\". Тип \"PostType\" был создан нами и импортирован сюда.*/\r\n};\r\n\r\n/*Создаем тип для \"MapDispatchToProps\". \"MapDispatchToProps\" в этом компоненте должен обязательно содержать следующие\r\nполя с указанными типами.*/\r\ntype MapDispatchToPropsType = {\r\n    addPost: (newMessageText: string) => void /*AC для добавления нового поста на странице профиля, который принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n};\r\n\r\n\r\n/*\r\n\"MyPostsContainer\" это не классовый компонент и не функциональный компонент.\r\n\"MyPostsContainer\" является только контейнерным компонентом для компонента \"MyPosts\".\r\nВ отличии от классового компонента, этот компонент не имеет методов жизненного цикла.\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.tsx\") из библиотеки \"react-redux\".\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВ этом компоненте мы просто создаем \"mapStateToProps\" и \"mapDispatchToProps\", тем самым формируя \"props\"\r\nдля презентационной компоненты \"MyPosts\". Поэтому нам не нужно создавать классовый компонент для этого.\r\nТаким же образом созданы контейнерные компоненты \"NavbarContainer\", \"DialogsContainer\".\r\n*/\r\n\r\n\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => { /*Здесь указываются данные из \"state\", которые\r\nнеобходимо передать в компонент \"MyPosts\". Эта функция возвращает указанные данные в виде объекта. На входе\r\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\r\nданные с типом \"MapStateToPropsType\".*/\r\n    return {\r\n        postsData: state.profilePage.postsData /*Данные о постах на странице пользователя.*/\r\n    }\r\n};\r\n\r\n\r\nexport default connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps,\r\n    {addPost: profileAC.addPost} /*При помощи метода \"connect\" создаем контейнерный\r\n        компонент, и тем самым передаем нужные данные BLL и DAL компоненту \"MyPosts\". Поскольку метод \"connect\"\r\n        является \"generic\", то его можно уточнить: первым в \"<>\" указан тип для \"MapStateToProps\", вторым для\r\n        \"MapDispatchToProps\", третьим для \"собственных props\" компонента, четвертым для \"state\". Эти параметры мы узнали\r\n        перейдя в файл декларации метода \"connect\", \"Ctrl+click\" в \"WebStorm\".*/\r\n)(MyPosts);\r\n/*При помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL компоненту\r\n\"MyPosts\". Экспортируем получившийся в итоге компонент, который будет использоваться в нашем проекте под именем\r\n\"MyPostsContainer\", по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Profile.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport ProfileInfo from './ProfileInfo/ProfileInfo'; /*Подключаем компонент \"ProfileInfo\".*/\r\nimport MyPostsContainer from './MyPosts/MyPostsContainer'; /*Подключаем компонент \"MyPostsContainer\".*/\r\n\r\nimport {ProfileType} from '../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\" для компонента \"Profile\". \"Props\" этого компонента должны обязательно содержать следующие поля\r\nс указанными типами.*/\r\ntype PropsType = {\r\n    profile:ProfileType | null /*Информация о профиле пользователя, полученная с сервера должна быть типа \"PostType\"\r\n    или иметь тип \"null\", то есть быть пустой. Тип \"PostType\" был создан нами и импортирован сюда.*/\r\n    status: string | null /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип \"null\",\r\n    то есть быть пустыми.*/\r\n    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля, должно быть булева типа.*/\r\n    updateUserStatus: (status: string) => void /*TC для изменения данных по статусу пользователя на странице профиля\r\n    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/\r\n    saveUserPhoto: (photoFile: File) => void /*TC для загрузки фото пользователя на странице профиля и дальнейшего его\r\n    отображения в нашем приложении должен быть функцией, которая принимает объект с фото пользователя, которое типа\r\n    \"File\" из \"TypeScript\" и ничего не возвращает.*/\r\n    saveProfile: (profile: ProfileType) => Promise<any> /*TC для отправки новых данных профиля пользователя на странице\r\n    профиля и дальнейшего их отображения в нашем приложении должен быть функцией, которая принимает объект типа\r\n    \"ProfileType\" и возвращает какой-либо промис, так как мы в файле \"ProfileInfo.tsx\" используем \"then.\" вместе с этим\r\n    TC.*/\r\n};\r\n\r\n\r\n/*\r\n\"Profile\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Profile(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Profile\" является презентационным компонентом.\r\n\"Profile\" является компонентом, который отображает профиль пользователя целиком.\r\nЭтот компонент подключается в компоненте \"ProfileContainer\".\r\nВнутри компонента \"Profile\" подключаются компоненты:\r\n- \"ProfileInfo\", который содержит информацию о пользователе;\r\n- \"MyPostsContainer\", который является контейнером для компонента \"MyPosts\", содержащего посты пользователя.\r\n*/\r\nconst Profile: React.FC<PropsType> = ({profile,\r\n                                       status,\r\n                                       updateUserStatus,\r\n                                       isOwner,\r\n                                       saveUserPhoto,\r\n                                       saveProfile}) => { /*При помощии деструктуризации \"props\" указываем какие именно\r\n    \"props\" мы получаем, чтобы не писать далее\r\n    \"props.profile\", \"props.status\" и так далее:\r\n    - \"profile\" - данные профиля пользователя для страницы профиля;\r\n    - \"status\" - данные статуся пользователя для страницы профиля;\r\n    - \"updateUserStatus\" - TC для изменения статуса пользователя на странице профиля;\r\n    - \"isOwner\" - свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля;\r\n    - \"saveUserPhoto\" - TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем\r\n    приложении;\r\n    - \"saveProfile\" - TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения\r\n    в нашем приложении.\r\n    Такое мы делаем только в функциональных компонентах.\r\n    Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {/*Далее отрисовываем компонент \"ProfileInfo\" и передаем ему через \"props\" необходимы для него данные.*/}\r\n            <ProfileInfo profile={profile} /*Данные профиля пользователя для страницы профиля.*/\r\n                         status={status} /*Данные статуся пользователя для страницы профиля.*/\r\n                         updateUserStatus={updateUserStatus} /*TC для изменения статуса пользователя на\r\n                         странице профиля.*/\r\n                         isOwner={isOwner} /*Свойство, которое показывает является ли залогиненный пользователь\r\n                         владельцем профиля, который в данный момент отображается на странице профиля.*/\r\n                         saveUserPhoto={saveUserPhoto} /*TC для загрузки фото пользователя на странице профиля и\r\n                         дальнейшего его отображения в нашем приложении.*/\r\n                         saveProfile={saveProfile} /*TC для отправки новых данных профиля пользователя на\r\n                         странице профиля и дальнейшего их отображения в нашем приложении.*/\r\n            />\r\n\r\n            {/*А также отрисовываем компонент \"MyPostsContainer\" помимо компонента \"ProfileInfo\".*/}\r\n            <MyPostsContainer/>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Profile; /*Экспортируем компонент \"Profile\" по default и будем его использовать в нашем проекте под\r\nименем \"Profile\", экспорт необходим для импорта.*/","import React, {ComponentType} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nИмпортируем \"ComponentType\" для типизации.\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {compose} from 'redux';\r\n/*\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и HOCs.\r\nОбвертки и HOCs указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\n*/\r\nimport {RouteComponentProps, withRouter} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nФункция \"withRouter\" это HOC.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nПоскольку URL тоже является источником данных, то компоненту иногда могут понадобиться эти данные.\r\nЧтобы их получить, можно воспользоваться \"withRouter\".\r\nHOC \"withRouter\" принимает в качестве параметра компонент и передает ему через \"props\" данные из URL, чтобы компонент\r\nзнал где он находиться - т.е. какой у него маршрут.\r\nЕсли подключить на самом высоком уровне дерева компонентов этот HOC, например, в \"App.tsx\", то данные URL будут доступны\r\nи в дочерних компонентах.\r\nТо есть здесь можно было и не указывать HOC \"withRouter\".\r\nПри использовании \"connect\" роутинг сбивается. Чтобы решить эту проблемы мы обварачиваем \"connect\" при помощи\r\n\"withRouter\". Но сейчас вроде и без этого все работает.\r\nТакже импортируем тип \"RouteComponentProps\".\r\n*/\r\n\r\nimport Profile from './Profile'; /*Подключаем компонент \"Profile\".*/\r\n\r\nimport {\r\n    getUserProfile, /*Подключаем TC \"getUserProfile\" из \"profile-reducer\".*/\r\n    getUserStatus, /*Подключаем TC \"getUserStatus\" из \"profile-reducer\".*/\r\n    saveProfile, /*Подключаем TC \"saveProfile\" из \"profile-reducer\".*/\r\n    saveUserPhoto, /*Подключаем TC \"saveUserPhoto\" из \"profile-reducer\".*/\r\n    updateUserStatus /*Подключаем TC \"updateUserStatus\" из \"profile-reducer\".*/\r\n} from '../../redux/profile-reducer';\r\n\r\nimport {ProfileType} from '../../types/types'; /*Подключаем типы.*/\r\nimport {AppStateType} from '../../redux/redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"MapStateToProps\". \"MapStateToProps\" в этом компоненте должен обязательно содержать следующие поля с\r\nуказанными типами.*/\r\ntype MapStateToPropsType = {\r\n    profile: ProfileType | null /*Информация о профиле пользователя, полученная с сервера должна быть типа \"PostType\"\r\n    или иметь тип \"null\", то есть быть пустой. Тип \"PostType\" был создан нами и импортирован сюда.*/\r\n    status: string | null /*Данные статуса пользователя для страницы профиля должны быть строкой или иметь тип \"null\",\r\n    то есть быть пустыми.*/\r\n    authUserID: number | null /*\"ID\" залогиненного пользователя должен быть число или иметь тип \"null\", то есть быть\r\n    пустым.*/\r\n};\r\n\r\n/*Создаем тип для \"MapDispatchToProps\". \"MapDispatchToProps\" в этом компоненте должен обязательно содержать следующие\r\nполя с указанными типами.*/\r\ntype MapDispatchToPropsType = {\r\n    getUserProfile: (userID: number) => void /*TC для запроса и установки данных по профилю пользователя на странице\r\n    профиля должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    getUserStatus: (userID: number) => void /*TC для запроса и установки данных по статусу пользователя на странице\r\n    профиля должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    updateUserStatus: (status: string) => void /*TC для изменения данных по статусу пользователя на странице профиля\r\n    должен быть функцией, которая принимает строковой параметр и ничего не возвращает.*/\r\n    saveUserPhoto: (photoFile: File) => void /*TC для загрузки фото пользователя на странице профиля и дальнейшего его\r\n    отображения в нашем приложении должен быть функцией, которая принимает объект с фото пользователя, которое типа\r\n    \"File\" из \"TypeScript\" и ничего не возвращает.*/\r\n    saveProfile: (profile: ProfileType) => any /*TC для отправки новых данных профиля пользователя на странице профиля\r\n    и дальнейшего их отображения в нашем приложении должен быть функцией, которая принимает объект типа \"ProfileType\" и\r\n    возвращает что угодно с типом \"any\", так как пока неизвестно как это здесь типизировать, так как мы в файле\r\n    \"ProfileInfo.tsx\" используем \"then.\" вместе с этим TC. В самом файле \"ProfileInfo.tsx\" этот TC типизирован как\r\n    функция, которая возвращает \"Promise<any>\", но если здесь указать также, то будет конфликт в типизации функции\r\n    \"connect\", то есть здесь можно указать тоже \"Promise<any>\", если избавиться от типизации в функции \"connect\".*/\r\n};\r\n\r\n/*Создали отдельный тип для объекта \"params\" из объекта \"match\" из функции \"withRouter\" из библиотеки\r\n\"react-router-dom\". Указали \"string\", так как все, что находится в этом объекте \"params\", является \"string\" (так\r\nустроена функция \"withRouter\").*/\r\ntype ProfileWithRouterParamsTypes = {\r\n    userID: string\r\n};\r\n\r\n/*Создаем общий тип для всех \"props\" путем комбинации двух созданных выше типов и типа \"RouteComponentProps\" из\r\nбиблиотеки \"react-router-dom\". Последний тип мы указали, так как этот компонент хочет получить объект \"match\" из\r\nфункции \"withRouter\". \"RouteComponentProps\" это тип для отдельного вида \"props\" из функции \"withRouter\". В этом типе\r\n\"RouteComponentProps\" мы уточнили какие свойства объекта \"params\" из объекта \"match\" из функции \"withRouter\" должны\r\nсодержаться внутри при помощи типа \"ProfileWithRouterParamsTypes\", который создали выше. Все это нужно для указания типа\r\n\"props\" в классовом компоненте.*/\r\ntype PropsType = MapStateToPropsType & MapDispatchToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>;\r\n\r\n\r\n/*\r\n\"ProfileContainer\" это классовый компонент.\r\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\r\nконцепцию ООП.\r\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\r\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\r\nвзаимодействует.\r\nНапример, у него можно постоянно запрашивать JSX.\r\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\r\nКомпонент это функция, которая возвращает JSX.\r\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\r\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\r\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileContainer\" является контейнерным компонентом для компонента \"Profile\".\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.tsx\") из библиотеки \"react-redux\".\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nclass ProfileContainer extends React.Component<PropsType/*, StateType*/> { /*Указали, что \"props\" в этом классовом\r\nкомпоненте имеют тип \"PropsType\". Еще здесь можно указать тип \"state\", но мы не указали.*/\r\n    refreshProfile() { /*Создаем специальный метод, который содержит необходимый функционал для обновления\r\n    страницы профиля.*/\r\n        let userID: number | null = +this.props.match.params.userID; /*Получаем \"ID\" пользователя. HOC \"withRouter\"\r\n        хранит некий объект, к которому можно обратиться как к \"match.params.userID\", чтобы получить значения\r\n        дополнения \":userID\" к пути \"/profile/\", как это указано у нас в компоненте \"App\". Добавили здесь \"+\" для\r\n        преобразования строкового значения \"this.props.match.params.userID\" в числовое в целях типизации. Также указали\r\n        явно тип \"number | null\" у \"userID\" для типизации.*/\r\n\r\n        if (!userID) { /*Если не удалось получить \"ID\" пользователя, то*/\r\n            userID = this.props.authUserID; /*пытаемся его получить от пользователя, под которым залогинены,*/\r\n            if (!userID) { /*а если же и после этого не удалось получить \"ID\" пользователя, то*/\r\n                this.props.history.push('/login/'); /*нас перенаправляет на страницу логирования. Желательно так не\r\n                использовать \"push\" в компонентах, поэтому в дальнейшем это нужно заменить на что-то другое.*/\r\n            };\r\n        };\r\n\r\n        if (!userID) { /*Написали вывод ошибки в консоль, если \"ID\" пользователя отсутствует. Но по идее не должно быть\r\n        ситуаций, когда \"ID\" пользователя полностью отсутствует, возможно надо что-то изменить в проекте, чтобы не\r\n        допускались такие случаи.*/\r\n            console.error('ID should exist in URI params or in state');\r\n        } else {/*Если же мы все-таки получили \"ID\" пользователя, то делаем следующее:*/\r\n            this.props.getUserProfile(userID); /*вызываем TC \"getUserProfile\" для получения данных профиля\r\n            пользователя и их установки на странице профиля. Без проверки на наличие \"ID\" пользователя в целях типизации\r\n            пришлось бы указать, чтобы \"userID\" воспринимался как число при помощи \"as number\".*/\r\n            this.props.getUserStatus(userID); /*вызываем TC \"getUserStatus\" для получения данных статуса\r\n            пользователя и их установки на странице профиля. Без проверки на наличие \"ID\" пользователя в целях типизации\r\n            пришлось бы указать, чтобы \"userID\" воспринимался как число при помощи \"as number\".*/\r\n        }\r\n    };\r\n\r\n    componentDidMount() { /*Это метод жизненного цикла классового компонента. Он вызывается в момент первой\r\n    отрисовки (монтирования) компонента.*/\r\n        this.refreshProfile(); /*Вызываем метод \"refreshProfile\".*/\r\n    };\r\n\r\n    componentDidUpdate\r\n    (prevProps:PropsType, prevState:MapStateToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>) {\r\n    /*Это метод жизненного цикла классового компонента. Он вызывается в момент обновления (изменения \"props\" или\r\n    \"state\") компонента. Указали тип для предыдущих \"props\" - \"prevProps\" в виде типа \"PropsType\", а для предыдущего\r\n    \"state\" в виде типа \"MapStateToPropsType & RouteComponentProps<ProfileWithRouterParamsTypes>\", так как мы еще\r\n    используем данный и из функции \"withRouter\".*/\r\n        if (this.props.match.params.userID !== prevProps.match.params.userID) { /*Проверяем изменился ли \"ID\"\r\n        пользователя в \"props\". Эта проверка нужна, чтобы избежать бесконечный цикл запроса новых \"props\" методом\r\n        \"refreshProfile\": изначально срабатывает метод \"refreshProfile\" из \"componentDidMount\", получает новые \"props\",\r\n        в свою очередь это триггерит метод \"refreshProfile\" из \"componentDidUpdate\", снова получаем новые \"props\" и\r\n        снова триггерим метод \"refreshProfile\" из \"componentDidUpdate\" и так до бесконечности.*/\r\n            this.refreshProfile(); /*Если изменился, то вызываем метод \"refreshProfile\".*/\r\n        }\r\n    };\r\n\r\n    render() {\r\n        /*\r\n        Здесь после return в компоненте начинается HTML разметка.\r\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n        */\r\n        return (\r\n            <Profile {...this.props} /*Отрисовываем компонент \"Profile\" и передаем ему через \"props\" необходимые для\r\n            него данные. Этот элемент \"Profile\" и есть наш корневой элемент. Здесь используется spread-оператор \"...\",\r\n            который из всех \"props\" создает атрибуты для компонента.*/\r\n                     isOwner={!this.props.match.params.userID} /*Свойство, которое показывает является ли залогиненный\r\n                     пользователь владельцем профиля, который в данный момент отображается на странице профиля. Будет\r\n                     равно \"TRUE\", если в данных URL не было найдено значения дополнения \":userID\" к пути \"/profile/\",\r\n                     как это указано у нас в компоненте \"App\", т.е. пользователь совершил переход просто на \"/profile/\",\r\n                     желая попасть на свою страницу, а не на чью-то другую. Это свойство нужно, чтобы интерфейс для\r\n                     редактирования информации в профиле появлялся только на собственной странице пользователя. Хотя\r\n                     тут есть проблема, когда мы переходим на свой профиль при помощи своего \"ID\" и не имеем\r\n                     упомянутого интерфейса. Далее передается в компонент \"ProfileInfo.tsx\".*/\r\n            />\r\n        )\r\n    }\r\n};\r\n\r\n\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => ({ /*Здесь указываются данные из \"state\", которые\r\nнеобходимо передать в компонент \"ProfileContainer\". Эта функция возвращает указанные данные в виде объекта. На входе\r\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\r\nданные с типом \"MapStateToPropsType\".*/\r\n    profile: state.profilePage.profile, /*Данные профиля пользователя для страницы профиля. Далее передается в\r\n    компонент \"ProfileInfo.tsx\".*/\r\n    status: state.profilePage.status, /*Данные статуса пользователя для страницы профиля. Далее передается в\r\n    компонент \"ProfileInfo.tsx\".*/\r\n    authUserID: state.auth.id, /*\"ID\" залогиненного пользователя.*/\r\n});\r\n\r\n\r\nexport default compose<ComponentType>( /*При помощи функции \"compose\" объеденяем HOCs \"withRouter\" и \"connect\",\r\nвозвращая итоговый компонент \"ProfileContainer\". Здесь мы уточнили тип только одним параметром, так как согласно файлу\r\nдекларации функции \"compose\" (раздел \"rest\"), нам нужно уточнить только такой компонент, свойства \"props\" которого не\r\nбудут переданы в этот компонент функциями, которые были переданы внутрь функции \"compose\", то есть функциями \"connect\" и\r\n\"withRouter\", то есть никакие свойства, так как мы не передаем извне ничего в компонент \"ProfileContainer\".*/\r\n    connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps, { /*При\r\n    помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL компоненту\r\n    \"ProfileContainer\" в этом файле. Поскольку метод \"connect\" является \"generic\", то его можно уточнить: первым в \"<>\"\r\n    указан тип для \"MapStateToProps\", вторым для \"MapDispatchToProps\", третьим для \"собственных props\" компонента,\r\n    четвертым для \"state\". Эти параметры мы узнали перейдя в файл декларации метода \"connect\", \"Ctrl+click\" в\r\n    \"WebStorm\".*/\r\n        getUserProfile, /*TC для получения данных профиля пользователя и их установки на странице профиля.*/\r\n        getUserStatus, /*TC для получения данных статуса пользователя и их установки на странице профиля.*/\r\n        updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/\r\n        saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем\r\n        приложении.*/\r\n        saveProfile}), /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их\r\n        отображения в нашем приложении.*/\r\n    withRouter /*Так же при помощи метода \"withRouter\" передаем в этот контейнерный компонент данные из URL.*/\r\n)(ProfileContainer);\r\n/*Получившийся в итоге компонент экспортируем, который будет использоваться в нашем проекте под именем\r\n\"ProfileContainer\", по default, экспорт необходим для импорта.*/"],"sourceRoot":""}