{"version":3,"sources":["assets/images/user.png","api/api.ts","redux/dialogs-reducer.ts","assets/images/preloader.gif","assets/images/headerlogo.png","components/Users/User.module.css","components/Navbar/Navbar.module.css","logo.svg","components/common/FormsControls/FormsControls.tsx","serviceWorker.js","components/Header/Header.jsx","redux/auth-reducer.ts","components/Header/HeaderContainer.jsx","components/Navbar/Sidebar/Sidebar.jsx","components/Navbar/Navbar.jsx","components/Navbar/NavbarContainer.jsx","utils/helpers/object-helpers.js","redux/users-reducer.ts","components/common/Paginator/Paginator.tsx","components/Users/User.jsx","components/Users/Users.tsx","redux/users-selectors.ts","components/Users/UsersContainer.tsx","components/Music/Music.jsx","components/News/News.jsx","components/Settings/Settings.jsx","components/Friends/Friends.jsx","components/Login/Login.tsx","redux/sidebar-reducer.ts","redux/app-reducer.ts","redux/redux-store.ts","App.js","hoc/WithSuspense.js","index.js","components/common/Preloader/Preloader.js","utils/validators/validators.ts","components/common/FormsControls/FormsControls.module.css","components/common/Paginator/Paginator.module.css","components/Header/Header.module.css","components/Navbar/Sidebar/Sidebar.module.css","redux/profile-reducer.ts"],"names":["module","exports","ResultCodeEnum","ResultCodeForCaptchaEnum","instance","axios","create","withCredentials","baseURL","headers","usersAPI","getUsers","currentPage","pageSize","get","then","response","data","unfollow","id","delete","follow","post","getUserProfile","userID","console","warn","profileAPI","getUserStatus","updateUserStatus","status","put","saveUserPhoto","photoFile","formData","FormData","append","saveProfile","profile","authAPI","me","login","email","password","rememberMe","captcha","logout","securityAPI","getCaptchaURL","ADD_MESSAGE","initialState","dialogs","name","avatar","avatarSource","messagesData","message","incomingMessagesData","addMessageActionCreator","newMessageText","type","dialogsReducer","state","action","newMessage","FormControl","meta","touched","error","children","hasError","className","styles","formControl","Textarea","props","input","restProps","Input","createField","placeholder","component","validators","text","validate","Boolean","window","location","hostname","match","Header","header","src","headerLogoSource","alt","loginBlock","isAuth","onClick","to","SET_USER_DATA","SET_CAPTCHA_URL","captchaURL","setAuthUserData","payload","setCaptchaURL","getAuthUserData","dispatch","a","resultCode","Success","url","authReducer","HeaderContainer","this","React","Component","connect","auth","SideBar","path","sidebar","activeClassName","active","Navbar","sidebarElements","friendsData","map","f","key","nav","item","activeLink","sidebarText","updateObjectInArray","items","itemID","objPropName","newObjProps","u","FOLLOW","UNFOLLOW","SET_USERS","SET_CURRENT_PAGE","SET_TOTAL_USERS_COUNT","TOGGLE_IS_FETCHING","TOGGLE_IS_FOLLOWING_IN_PROGRESS","users","totalUsersCount","isFetching","WhoIsInFollowingProgress","portionSize","followSuccess","unfollowSuccess","toggleIsFetching","toggleIsFollowingInProgress","isFollowingInProgress","_followUnfollowFlow","apiMethod","actionCreator","usersReducer","followed","count","filter","Paginator","totalItemsCount","onPageChange","pagesCount","Math","ceil","pages","i","push","portionCount","useState","currentPortionNumber","setCurrentPortionNumber","lowerBoundOfCurrentPortion","upperBoundOfCurrentPortion","paginator","p","cn","selectedPage","pageNumber","e","User","user","photos","small","userPhoto","disabled","some","Users","createSelector","usersPage","getPageSize","getPortionSize","getTotalUsersCount","getCurrentPage","getIsFetching","getWhoIsInFollowingProgress","UsersContainer","setCurrentPage","requestUsers","pageTitle","Preloader","compose","totalCount","bind","Music","News","Settings","Friends","maxLength30","maxLengthCreator","LoginReduxForm","reduxForm","form","handleSubmit","onSubmit","required","undefined","style","formSummaryError","CaptchaIsRequired","messages","length","stopSubmit","_error","sidebarReducer","INITIALIZATION_SUCCESSFUL","initialized","appReducer","rootReducer","combineReducers","profilePage","profileReducer","dialogsPage","formReducer","app","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","store","createStore","applyMiddleware","thunkMiddleWare","__store__","DialogsContainer","lazy","ProfileContainer","App","initializeApp","NavbarContainer","exact","render","fallback","AppContainer","withRouter","promise","Promise","all","AppMain","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","preloader","value","maxLength","ADD_POST","SET_USER_PROFILE","SET_USER_STATUS","DELETE_POST","IS_SAVING_USER_PHOTO_SUCCESSFUL","postsData","likesCount","addPostActionCreator","newPostText","setUserStatus","alert","getState","reject","newPost","postID"],"mappings":"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","file":"static/js/main.03797770.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/user.d88c2ebe.png\";","/*\r\nЭтот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер,\r\nчтобы компоненты не создавали \"side effects\" такого типа. Этот файл отвечает за \"DAL\" - \"Data Access Layer\".\r\n\"Cookie\" - это файл, который цепляется ко всем запросам на сервер.\r\n\"Cookie\" связаны с идентификацией пользователя.\r\nСервер при подтверждении пользователя записывает идентификатор пользователя в \"Cookie\" и\r\nотправляетв закодированном виде (в нашем случае - нет) пользователю.\r\nДалее эти \"Cookie\" записываются браузером до тех пор, пока не истечет срок их жизни, который\r\nв них установлен. Галочка \"Запомнить меня?\" - это про срок жизни \"Cookie\".\r\nВ дальнейшем при общении с сервером в \"Cookie\" будет использоваться идентификатор пользователя.\r\nТаким образом, сервер может определять пользователя. Кодировать или декодировать идентификатор может только сервер.\r\nДля каждого домена создаются отдельные \"Cookie\".\r\nЗапрещено делать кросс-доменные запросы, за исключением если домен дал на это разрешение.\r\nЭто важно поскольку наше приложение находится на локальном хосте и мы делаем запросы на другой домен из нашего\r\nприложения.\r\nЧтобы залогиниться в нашем приложении нужно сначала залогиниться на API сайта.\r\nНастройки в POST-запросе передаются третьим параметром.\r\nНастройки в DELETE-запросе и GET-запросе передаются вторым параметром.\r\nВсе запросы, кроме GET-запросов, требуют обязательно ключа доступа, который генерируется на сайте API в нашем случае.\r\nТакие коды указываются в параметрах запросов в свойстве \"headers\".\r\nПри осуществлении запросов в нашем приложении можно получить ошибку \"429\", которая означает, что превышен лимит\r\nзапросов.\r\nДля снятия этого ограничения нужно купить Premium-аккаунт на сайте API.\r\nПри кроссдоменных запросах, перед основным запросом, браузер отправляет OPTIONS-запрос для получения разрешения от\r\nсервера на осуществление кроссдоменных запросов. Это часть \"CORS\" - политики безопасности браузера.\r\nGET-запросы и DELETE-запросы ничего не могут передать на сервер, кроме адресной строки самого URL-адреса.\r\nPOST-запросы и PUT-запросы могут отправлять на сервер разные данные, некий \"payload\" (например, фото или текст).\r\n*/\r\n\r\nimport axios from 'axios';\r\n/*\r\nБиблиотека axios нужна для работы с запросами на сервер.\r\nЗапросы осуществляются на \"endpoints\", которые представляют из себя URL.\r\nНаш API сервера находится здесь: \"https://social-network.samuraijs.com/docs\".\r\nУ каждого API сервера есть базовый URL, в нашем случае это \"https://social-network.samuraijs.com/api/1.0\".\r\nК базовому URL дописываются определенные элементы (например, \"/users\"), чтобы получить какую-то категорию данных.\r\nВ запросе \"GET\" мы не можем передавать какую-либо информацию, кроме URL.\r\nВ нашем случае мы получаем ответы в формате JSON.\r\nСуществует подход \"API first\": сначала создается API, а потом уже front-end и back-end.\r\nВ библиотеке \"axios\" любой запрос \"GET\", \"POST\" или \"PUT\" являются \"generic\" и возвращают промис, который можно уточнить\r\nпри помощи \"TypeScript\".\r\n*/\r\n\r\nimport {ProfileType, PhotosType, UserType} from '../types/types'; /*Импортируем типы.*/\r\n\r\n\r\nconst instance = axios.create({ /*Создаем \"instance\". \"axios.create\" позволяет создавать экземпляры \"axios\". Этот\r\nэкземпляр будет содержать необходимые параметры для наших запросов.*/\r\n    withCredentials: true, /*Указываем, чтобы к запросам были прикреплены \"Cookie\".*/\r\n    baseURL: `https://social-network.samuraijs.com/api/1.0/`, /*Указываем базовый URL. Используем обратные\r\n    кавычки \"``\", чтобы можно было использовать спецсимволы.*/\r\n    headers: { /*Указываем обязательный ключ доступа, который сгенерирован на сайте API.*/\r\n        'API-KEY': 'd418a1c2-23eb-4c24-817d-5fabace62f03'\r\n    }\r\n});\r\n\r\n/*\r\nДалее идут объекты, которые содержат вспомогательные запросы на сервер. Эти объекты можно представить в виде категорий.\r\n*/\r\nexport const usersAPI = { /*\"usersAPI\" содержит запросы, связанные со страницей с постраничным выводом пользователей.*/\r\n    getUsers(currentPage: number, pageSize: number) { /*Эта функция является запросом на получение данных пользователей\r\n    в постраничном выводе. Эти данные на сервере структурированы по страницам, поэтому данная функция принимает два\r\n    параметра: текущая страница для отображения (1 \"default\") и количество пользователей на этой\r\n    странице (от 10 (\"default\") до 100). Эти два параметра должны быть .*/\r\n        return (\r\n            instance.get<getUsersType>(`users?page=${currentPage}&count=${pageSize}`) /*Указываем, что добавляем к\r\n            базовому URL, указанному в \"instance\", \"users\", чтобы получить данные пользователей. Знак \"?\" означает, что\r\n            дальше идут параметры GET-запроса, знак \"&\" используется для перечисления таких параметров. Названия этих\r\n            параметров и ограничения их значений описываются в API сервера. Указали, что этот запрос \"GET\" возвращает\r\n            промис с типом \"getUsersType\".*/\r\n                .then(response => { /*\"then\" создает \"promise\".\r\n                Эти данные придут от сервера и выполниться стрелочная функция \"response\".\r\n                Данные, которые конкретно будут нужны нам, будут находиться внутри \"response.data\".\r\n                Это \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных\r\n                в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                - \"items\" - массив с объектами, которые содержат данные по пользователям.\r\n                Каждый такой объект содержит следуюющее:\r\n                    - \"name\" - имя пользователя.\r\n                    - \"id\" - \"ID\" пользователя.\r\n                    - \"photos\": - объект с путями к фото пользователя.\r\n                        - \"small\" - уменьшенное фото.\r\n                        - \"large\" - увеличенное фото.\r\n                    - \"status\" - статус пользователя.\r\n                    - \"followed\" - говорит фолловим ли мы пользователя или нет.\r\n                - \"totalCount\" - количество всех пользователей.\r\n                - \"error\" - содержит сообщение об ошибке, если была.*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                чтобы установить их в наш \"state\" при помощи TC \"requestUsers\" в \"users-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    unfollow(id: number) { /*Эта функция является запросом на анфолловинг какого-либо пользователя. Оба запроса на\r\n    анфолловинг и фолловинг идут на один и тот же \"endpoint\", только для анфолловинга нужно делать DELETE-запрос,\r\n    а для фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать \"ID\" пользователя, которого\r\n    анфолловим или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи \"Cookie\" сервер\r\n    будет определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/\r\n        return (\r\n            instance.delete<unfollowFollowType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,\r\n            указанному в \"instance\", \"follow\" и \"ID\" пользователя, которого анфолловим, чтобы сформировать запрос на\r\n            анфолловинг. Указали, что этот запрос \"DELETE\" возвращает промис с типом \"unfollowFollowType\".*/\r\n                .then(response => { /*\"then\" создает \"promise\".\r\n                Какие-то данные придут от сервера и выполниться стрелочная функция \"response\".\r\n                Данные, которые конкретно будут нужны нам, будут находиться внутри \"response.data\".\r\n                Эта \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных\r\n                в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                - \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя, \"0\" - все хорошо,\r\n                \"1\" - какая-то ошибка.\r\n                - \"messages\" - информационное сообщение от сервера (например, при какой-либо ошибке во время обновления\r\n                статуса пользователя).\r\n                - \"data\" - какие-то дополнительные данные (в данный момент не используется).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                чтобы осуществить анфолловинг пользователя при помощи TC \"unfollow\" в \"users-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    follow(id: number) { /*Эта функция является запросом на фолловинг какого-либо пользователя. Оба запроса на\r\n    анфолловинг и фолловинг идут на один и тот же \"endpoint\", только для анфолловинга нужно делать DELETE-запрос, а для\r\n    фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать \"ID\" пользователя, которого анфолловим\r\n    или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи \"Cookie\" сервер будет\r\n    определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/\r\n        return (\r\n            instance.post<unfollowFollowType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,\r\n            указанному в \"instance\", \"follow\" и \"ID\" пользователя, которого фолловим, чтобы сформировать запрос на\r\n            фолловинг. Указали, что этот запрос \"POST\" возвращает промис с типом \"unfollowFollowType\".*/\r\n                .then(response => { /*\"then\" создает \"promise\".\r\n                Какие-то данные придут от сервера и выполниться стрелочная функция \"response\".\r\n                Данные, которые конкретно будут нужны нам, будут находиться внутри \"response.data\".\r\n                Эта \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных\r\n                в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                - \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя, \"0\" - все хорошо,\r\n                \"1\" - какая-то ошибка.\r\n                - \"messages\" - информационное сообщение от сервера (например, при какой-либо ошибке во время обновления\r\n                статуса пользователя).\r\n                - \"data\" - какие-то дополнительные данные (в данный момент не используется).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                чтобы осуществить фолловинг пользователя при помощи TC \"follow\" в \"users-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    getUserProfile(userID: number) { /*Это устаревший запрос на получение данных профиля пользователя для страницы\r\n    профиля в виде функции, которая принимает один параметр в виде \"ID\" пользователя, который должен быть числом. Сейчас\r\n    просто вызывает актуальный запрос \"getUserProfile\" из \"profileAPI\". То есть мы здесь делегировали управление\r\n    из \"userAPI\" в \"profileAPI\". При вызове же этого устаревшего метода появится информационное сообщение. В дальнейшем\r\n    лучше избавиться от этого устаревшего метода.*/\r\n        console.warn('Obsolete method. Use profileAPI object')\r\n        return (\r\n            profileAPI.getUserProfile(userID)\r\n        );\r\n    }\r\n};\r\n\r\nexport const profileAPI = { /*\"usersAPI\" содержит запросы, связанные со страницей профиля пользователя.*/\r\n    getUserProfile(userID: number) { /*Эта функция является запросом на получение данных профиля пользователя для\r\n    страницы профиля. Данная функция принимает один параметр в виде \"ID\" пользователя, который должен быть числом.*/\r\n        return (\r\n            instance.get<ProfileType>(`profile/${userID}`) /*Указываем, что добавляем к базовому URL, указанному в\r\n            \"instance\", чтобы получить данные профиля пользователя. Указали, что этот запрос \"GET\" возвращает промис с\r\n            типом \"ProfileType\", который был создан нами и импортирован сюда.\r\n            Данные придут от сервера и будут находиться внутри \"response.data\". Это \"data\" создается самим запросом и\r\n            туда помещается информация от сервера. Сама же структура данных в \"data\" определяется сервером. Согласно\r\n            API сервера там находятся:\r\n            \"aboutMe\" - информация \"обо мне\" (на сайте API этого нет, но на самом деле на сервере это поле имеется).\r\n            \"contacts\": - контакты.\r\n                \"github\"\r\n                \"vk\"\r\n                \"facebook\"\r\n                \"instagram\"\r\n                \"twitter\"\r\n                \"website\"\r\n                \"youtube\"\r\n                \"mainLink\".\r\n            \"fullName\" - полное имя.\r\n            \"lookingForAJob\" - ищет ли работу.\r\n            \"lookingForAJobDescription\" - какую ищет работу.\r\n            \"photos\": - фото.\r\n                \"small\"\r\n                \"large\".\r\n            \"userId\" - \"ID\" пользователя.\r\n            Здесь в отличии от \"getUsers\" мы не используем \".then(response => {...}\", и не вытаскиваем блок с нужными\r\n            данными из всего ответа от сервера. Это мы делаем уже в TC \"getUserProfile\" в \"profile-reducer.ts\", но\r\n            такое лучше не указывать в BLL, поэтому мы там используем \"async/await\" как аналог \".then\".*/\r\n        );\r\n    },\r\n\r\n    getUserStatus(userID: number) { /*Эта функция является запросом на получение данных статуса пользователя для\r\n    страницы профиля. Данная функция принимает один параметр в виде \"ID\" пользователя, который должен быть числом.*/\r\n        return (\r\n            instance.get<string>(`profile/status/${userID}`) /*Указываем, что добавляем к базовому URL, указанному\r\n            в \"instance\", чтобы получить данные статуса пользователя. Указали, что этот запрос \"GET\" возвращает промис\r\n            с типом строки.\r\n            Данные придут от сервера и будут находиться внутри \"response.data\". Это \"data\" создается самим запросом и\r\n            туда помещается информация от сервера. Сама же структура данных в \"data\" определяется сервером.\r\n            Согласно API сервера там находится текст статуса пользователя (хотя было бы лучше, чтобы данные приходили\r\n            в формате JSON, то есть в данном случае не возвращается объект со свойствами, как это происходит в других\r\n            запросах).\r\n            Здесь в отличии от \"getUsers\" мы не используем \".then(response => {...}\", и не вытаскиваем блок с нужными\r\n            данными из всего ответа от сервера. Это мы делаем уже в TC \"getUserStatus\" в \"profile-reducer.ts\", но такое\r\n            лучше не указывать в BLL, поэтому мы там используем \"async/await\" как аналог \".then\".*/\r\n        );\r\n    },\r\n\r\n    updateUserStatus(status: string) { /*Эта функция является запросом на изменение данных статуса пользователя для\r\n    страницы профиля на сервере. Данная функция принимает один параметр в виде строки с информацией из статуса.\r\n    Согласно API сервера максимальная длинна статуса 300 символов в формате JSON.*/\r\n        return (\r\n            instance.put<updateUserStatusType>(`profile/status`, {status: status}) /*Указываем, что добавляем\r\n            к базовому URL, указанному в \"instance\", чтобы отправить на сервер новые данные статуса пользователя.\r\n            А также указываем объект с этими данными. Указали, что этот запрос \"PUT\" возвращает промис с типом\r\n            \"updateUserStatusType\".\r\n            В ответ на этот запрос к нам придут данные, которые будут находиться внутри \"response.data\". Эта \"data\"\r\n            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в \"data\"\r\n            определяется сервером. Согласно API сервера там находятся:\r\n            - \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя, \"0\" - все хорошо,\r\n            \"1\" - какая-то ошибка.\r\n            - \"messages\" - информационное сообщение от сервера (например, при какой-либо ошибке во время обновления\r\n            статуса пользователя).\r\n            - \"data\" - какие-то дополнительные данные (в данный момент не используется).\r\n            Здесь в отличии от \"getUsers\" мы не используем \".then(response => {...}\", и не вытаскиваем блок с нужными\r\n            данными из всего ответа от сервера. Это мы делаем уже в TC \"updateUserStatus\" в \"profile-reducer.ts\", но\r\n            такое лучше не указывать в BLL, поэтому мы там используем \"async/await\" как аналог \".then\".*/\r\n        );\r\n    },\r\n\r\n    saveUserPhoto(photoFile: any) { /*Эта функция является запросом на загрузку фото пользователя на сервер. Данная\r\n    функция принимает один параметр в виде файла. Тип этого файла указан как \"any\", так как мы пока не знаем какого\r\n    именно типа он будет.*/\r\n        const formData = new FormData();\r\n        formData.append(\"image\", photoFile); /*Поскольку здесь мы передаем не просто JSON-данные, а изображение,\r\n        то поэтому формируем специальный объект при помощи \"FormData()\". При помощи метода \"append\" добавляем в этот\r\n        объект файл с фото. \"image\" - так указывается согласно API сервера. Третьим параметром отправляется объект\r\n        со специфическими заголовками, но в данном случае и без них все работает.*/\r\n\r\n        return (\r\n            instance.put<saveUserPhotoType>(`profile/photo`, formData/*, {headers: {'Content-Type': 'multipart/form-data'}}*/)\r\n            /*Указываем, что добавляем к базовому URL, указанному в \"instance\", чтобы отправить на сервер\r\n            фото пользователя. А также указываем объект с этим фото. Указали, что этот запрос \"PUT\" возвращает промис\r\n            с типом \"saveUserPhotoType\".\r\n            В ответ на этот запрос к нам придут данные, которые будут находиться внутри \"response.data\". Эта \"data\"\r\n            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в \"data\"\r\n            определяется сервером. Согласно API сервера там находятся:\r\n            - \"resultCode\" - код, означающий успешно ли прошла загрузка фото пользователя, \"0\" - все хорошо,\r\n            другие числа - какая-то ошибка.\r\n            - \"messages\" - информационное сообщение от сервера (например, при какой-либо ошибке во время загрузки фото).\r\n            - \"data\" - дополнительные данные, в которых содержится еще один объект \"photos\", который в свою очередь\r\n            имеет еще два свойства:\r\n            1) \"small\" - URL фото в маленьком размере, если отсутствует, то будет \"NULL\".\r\n            2) \"large\" - URL фото в большом размере, если отсутствует, то будет \"NULL\".\r\n            Помимо наличия объекта \"photos\", \"data\" имеет также свои свойства \"small\" и \"large\", копирующие аналогичные\r\n            свойства у объекта \"photos\". Предположительно это ошибочно добавили на сервере.\r\n            Здесь в отличии от \"getUsers\" мы не используем \".then(response => {...}\", и не вытаскиваем блок с нужными\r\n            данными из всего ответа от сервера. Это мы делаем уже в TC \"saveUserPhoto\" в \"profile-reducer.ts\", но\r\n            такое лучше не указывать в BLL, поэтому мы там используем \"async/await\" как аналог \".then\".*/\r\n        );\r\n    },\r\n\r\n    saveProfile(profile: ProfileType) { /*Эта функция является запросом на отправку новых данных профиля пользователя\r\n    на сервер. Данная функция принимает один параметр в виде объекта с данными типа \"ProfileType\", который создан был\r\n    нами и импортирован сюда. Согласно API сервера в этом объекте должно находится следующее:\r\n            \"aboutMe\" - информация \"обо мне\" (на сайте API этого нет, но на самом деле на сервере это поле имеется).\r\n            \"contacts\": - контакты.\r\n                \"github\"\r\n                \"vk\"\r\n                \"facebook\"\r\n                \"instagram\"\r\n                \"twitter\"\r\n                \"website\"\r\n                \"youtube\"\r\n                \"mainLink\".\r\n            \"fullName\" - полное имя.\r\n            \"lookingForAJob\" - ищет ли работу.\r\n            \"lookingForAJobDescription\" - какую ищет работу.\r\n            \"photos\": - фото.\r\n                \"small\"\r\n                \"large\".\r\n            \"userId\" - \"ID\" пользователя.*/\r\n        return (\r\n            instance.put<saveProfileType>(`profile`, profile) /*Указываем, что добавляем к базовому URL, указанному\r\n            в \"instance\", чтобы отправить на сервер новые данные профиля пользователя. А также указываем объект с этими\r\n            данными. Указали, что этот запрос \"PUT\" возвращает промис с типом \"saveProfileType\".\r\n            В ответ на этот запрос к нам придут данные, которые будут находиться внутри \"response.data\". Эта \"data\"\r\n            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в \"data\"\r\n            определяется сервером. Согласно API сервера там находятся:\r\n            - \"resultCode\" - код, означающий успешно ли прошла отправка новых данных профиля пользователя, \"0\" - все\r\n            хорошо, другие числа - какая-то ошибка.\r\n            - \"messages\" - информационное сообщение от сервера (например, при какой-либо ошибке во время отправки\r\n            новых данных профиля пользователя).\r\n            - \"data\" - какие-то дополнительные данные (в данный момент не используется).\r\n            Здесь в отличии от \"getUsers\" мы не используем \".then(response => {...}\", и не вытаскиваем блок с нужными\r\n            данными из всего ответа от сервера. Это мы делаем уже в TC \"saveProfile\" в \"profile-reducer.ts\"., но\r\n            такое лучше не указывать в BLL, поэтому мы там используем \"async/await\" как аналог \".then\"*/\r\n        );\r\n    }\r\n};\r\n\r\nexport const authAPI = { /*\"usersAPI\" содержит запросы, связанные с аутентификацией.*/\r\n    me() { /*Эта функция является запросом на запрос информации для залогинивания через наше приложение.\r\n    Перед этим необходимо либо залогиниться на API сайта, чтобы создались \"Cookie\", чтобы при запросе сервер мог нас\r\n    идентифицировать, или же ввести данные для залогинивания в нашем приложении.*/\r\n        return (\r\n            instance.get<MeResponseType>(`auth/me`) /*Делаем GET-запрос для залогинивания в нашем приложении на\r\n            адрес как указано в API сайта. Указали, что этот запрос \"GET\" возвращает промис с типом \"MeResponseType\".*/\r\n                .then(response => response.data) /*\"then\" создает \"promise\".\r\n                Эти данные придут от сервера и выполниться стрелочная функция \"response\".\r\n                Данные, которые конкретно будут нужны нам, будут находиться внутри \"response.data\".\r\n                Это \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных\r\n                в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                - еще один объект \"data\", который в свою очередь содержит \"id\" (\"ID\" залогиненного пользователя),\r\n                \"email\" (\"email\" залогиненного пользователя) и\"login\" (\"login\" залогиненного пользователя).\r\n                - \"resultCode\" - код ответа сервера (\"0\" - все хорошо, \"1\" - какая-то ошибка).\r\n                - \"messages\" - информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n                залогинивания).\r\n                Затем получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш\r\n                \"state\" при помощи TC \"getAuthUserData\" в \"auth-reducer.ts\".*/\r\n        );\r\n    },\r\n\r\n    login(email: string, password: string, rememberMe = false, captcha: null | string = null) { /*Эта функция\r\n    является запросом на залогинивание через наше приложение. Перед этим не нужно залогиниваться на API сайта, чтобы\r\n    создались \"Cookie\". Нужно просто ввести свои данные для залогинивания в нашем приложении. На сервер отправится\r\n    запрос вместе с объектом данных, которые включают в себя почту (должна быть строкой), пароль (должен быть строкой),\r\n    флаг \"Запомнить?\" (должен быть булева типа) и введенная капча (должна быть строкой или \"null\", то есть\r\n    быть пустым), если таковая была.*/\r\n        return (\r\n            instance.post<LoginResponseType>(`auth/login`, {email, password, rememberMe, captcha}) /*Делаем\r\n            POST-запрос для залогинивания в нашем приложении на адрес как указано в API сайта. В результате сервер\r\n            создаст куки. Указали, что этот запрос \"POST\" возвращает промис с типом \"LoginResponseType\".*/\r\n                .then(response => response.data) /*\"then\" создает \"promise\".\r\n                Какие-то данные придут от сервера и выполниться стрелочная функция \"response\".\r\n                Данные, которые конкретно будут нужны нам, будут находиться внутри \"response.data\".\r\n                Эта \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных\r\n                в \"data\" определяется сервером. Согласно API сервера там находятся\r\n                - \"resultCode\" - код, означающий успешно ли мы залогинились или нет (\"0\" - все хорошо,\r\n                \"10\" - нужно ввести капчу).\r\n                - \"messages\" - массив, содержащий какие-то информационные сообщения от сервера, если они есть.\r\n                - \"data\" - объект, содержащий свойство \"userId\" с \"ID\" залогиненного пользователя.\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                чтобы осуществить логинизацию пользователя при помощи TC \"login\" в \"auth-reducer.ts\".*/\r\n        );\r\n    },\r\n\r\n    logout() { /*Эта функция является запросом на разлогинивание через наше приложение. Перед этим нужно быть уже\r\n    залогинен, чтобы создались \"Cookie\".*/\r\n        return (\r\n            instance.delete<LogoutResponseType>(`auth/login`) /*Делаем DELETE-запрос для разлогинивания в нашем\r\n            приложении на адрес как указано в API сайта. В результате сервер удалит куки. Указали, что этот запрос\r\n            \"DELETE\" возвращает промис с типом \"LogoutResponseType\".\r\n            Также какие-то данные придут от сервера, которые будут находиться внутри \"response\". Внутри \"response\"\r\n            будет \"data\".\r\n            Эта \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных\r\n            в \"data\" определяется сервером. Согласно API сервера там находятся\r\n            - \"resultCode\" - код, означающий успешно ли мы залогинились или нет (\"0\" - все хорошо,\r\n            другие номера - какая-то ошибка).\r\n            - \"messages\" - массив, содержащий какие-то информационные сообщения от сервера, если они есть.\r\n            - \"data\" - пустой объект, потенциально может содержать какую-то дополнительную информацию.\r\n            Получив ответ от сервера в виде нужных данных, возвращаем их (весь \"response\" в отличие от \"login\",\r\n            вытаскиваем \"data\" в самом TC) далее, чтобы осуществить разлогинивание пользователя при помощи TC \"logout\"\r\n            в \"auth-reducer.ts\", но такое лучше не указывать в BLL, поэтому мы там используем \"async/await\" как\r\n            аналог \".then\".*/\r\n        );\r\n    }\r\n};\r\n\r\nexport const securityAPI = { /*\"usersAPI\" содержит запросы, связанные с безопасностью.*/\r\n    getCaptchaURL() { /*Если нашему серверу необходимо, чтобы мы ввели капчу после нескольких неудачных попыток\r\n    залогиниться, то он сообщит браузеру, что тот должен сделать запрос на специальный \"endpoint\" и в ответ получить\r\n    картинку с капчей (в виде объекта, содержащего URL). Эта функция является запросом на получение капчи.*/\r\n        return (\r\n            instance.get<getCaptchaURLResponseType>(`security/get-captcha-url`) /*Указываем, что добавляем к\r\n            базовому URL, указанному в \"instance\", чтобы отправить запрос на сервер для получения капчи. Указали, что\r\n            этот запрос \"GET\" возвращает промис с типом \"getCaptchaURLResponseType\".\r\n            В ответ на этот запрос к нам придут  данные, которые будут находиться внутри \"response.data\". Эта \"data\"\r\n            создается самим запросом и туда помещается информация от сервера. Сама же структура данных в \"data\"\r\n            определяется сервером. Согласно API сервера там находится строковой элемент \"url\", в котором указан URL\r\n            капчи.\r\n            Здесь в отличии от \"getUsers\" мы не используем \".then(response => {...}\", и не вытаскиваем блок с нужными\r\n            данными из всего ответа от сервера. Это мы делаем уже в TC \"getCaptchaURL\" в \"auth-reducer.ts\", но такое\r\n            лучше не указывать в BLL, поэтому мы там используем \"async/await\" как аналог \".then\".*/\r\n        );\r\n    }\r\n};\r\n\r\n\r\n/*\"enum\" в JS перечисляют строки или числа. При помощи \"enum\" создали список кодов ответа от сервера, которые\r\nиспользуются в TC \"getAuthUserData\" и в TC \"login\" в \"auth-reducer.ts\".*/\r\nexport enum ResultCodeEnum {\r\n    Success = 0,\r\n    Error = 1\r\n};\r\n\r\n/*\"enum\" в JS перечисляют строки или числа. При помощи \"enum\" создали список кодов ответа от сервера, которые\r\nиспользуются в TC \"login\" в \"auth-reducer.ts\".*/\r\nexport enum ResultCodeForCaptchaEnum {\r\n    CaptchaIsRequired = 10\r\n};\r\n\r\n\r\n/*Создаем типы промисов, который возвращаются в запросах в этом API.*/\r\n/*Создаем типы для промисов запросов из \"usersAPI\"*/\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"GET\" в \"getUsers\" из \"usersAPI\".*/\r\ntype getUsersType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными\r\nтипами.*/\r\n    items: Array<UserType> /*Там должна содержаться информация по пользователям в виде массива объектов с типом\r\n    \"UserType\", который был создан нами и импортирован сюда.*/\r\n    totalCount: number /*Количество всех пользователей должно быть числом.*/\r\n    error: string | null /*Сообщение с ошибкой от сервера (например, при какой-либо ошибке во время получения данных\r\n    по пользователям) должно быть строкой или \"null\", то есть быть пустым.*/\r\n};\r\n\r\n/*Создаем тип для промисов, которые будут возвращаться из запроса \"DELETE\" в \"unfollow\" и из запроса \"POST\" в \"follow\"\r\nиз \"usersAPI\".*/\r\ntype unfollowFollowType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными\r\nтипами.*/\r\n    data: { /*Там должен быть объект \"data\", который потенциально может содержать дополнительную информацию.*/\r\n        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/\r\n    }\r\n    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа \"ResultCodeEnum\", который мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    анфолловинга пользователя) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем типы для промисов запросов из \"profileAPI\"*/\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"PUT\" в \"updateUserStatus\" из \"profileAPI\".*/\r\ntype updateUserStatusType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными\r\nтипами.*/\r\n    data: { /*Там должен быть объект \"data\", который потенциально может содержать дополнительную информацию.*/\r\n        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/\r\n    }\r\n    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа \"ResultCodeEnum\", который мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    обновления статуса пользователя) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"PUT\" в \"saveUserPhoto\" из \"profileAPI\".*/\r\ntype saveUserPhotoType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными\r\nтипами.*/\r\n    data: { /*Там должен быть объект \"data\", содержащий информацию о залогиненном пользователе.*/\r\n        photos: PhotosType /*Объект с фото пользователя должно быть типа \"PhotosType\", который мы создали ниже.*/\r\n        small: string | null /*Путь к уменьшенной версии фото пользователя должен быть строкой или \"null\" (то есть\r\n        быть пустым). Это свойство видимо добавлено на сервере ошибочно, так как дублирует часть объекта \"photos\".*/\r\n        large: string | null /*Путь к увеличенной версии фото пользователя должен быть строкой или \"null\" (то есть\r\n        быть пустым). Это свойство видимо добавлено на сервере ошибочно, так как дублирует часть объекта \"photos\".*/\r\n    }\r\n    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа \"ResultCodeEnum\", который мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    сохранения фото пользователя) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"PUT\" в \"saveProfile\" из \"profileAPI\".*/\r\ntype saveProfileType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/\r\n    data: { /*Там должен быть объект \"data\", который потенциально может содержать дополнительную информацию.*/\r\n        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/\r\n    }\r\n    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа \"ResultCodeEnum\", который мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    сохранения данных профиля) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем типы для промисов запросов из \"authAPI\"*/\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"GET\" в \"me\" из \"authAPI\".*/\r\ntype MeResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/\r\n    data: { /*Там должен быть объект \"data\", содержащий информацию о залогиненном пользователе.*/\r\n        id: number /*\"ID\" залогиненного пользователя, которое должно быть числом.*/\r\n        email: string /*\"Email\" залогиненного пользователя, который должен быть строкой.*/\r\n        login: string /*\"Login\" залогиненного пользователя, который должен быть строкой.*/\r\n    }\r\n    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа \"ResultCodeEnum\", который мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    залогинивания) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"POST\" в \"login\" из \"authAPI\".*/\r\ntype LoginResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/\r\n    data: { /*Там должен быть объект \"data\", содержащий информацию о залогиненном пользователе.*/\r\n        userId: number /*\"ID\" залогиненного пользователя, которое должно быть числом.*/\r\n    }\r\n    resultCode: ResultCodeEnum | ResultCodeForCaptchaEnum /*Код ответа сервера должен быть либо типа \"ResultCodeEnum\",\r\n    либо типа \"ResultCodeForCaptchaEnum\", которые мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    залогинивания) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"DELETE\" в \"logout\" из \"authAPI\".*/\r\ntype LogoutResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными типами.*/\r\n    data: { /*Там должен быть объект \"data\", который потенциально может содержать дополнительную информацию.*/\r\n        [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/\r\n    }\r\n    resultCode: ResultCodeEnum /*Код ответа сервера должен быть типа \"ResultCodeEnum\", который мы создали выше.*/\r\n    messages: Array<string> /*Информационное сообщение от сервера (например, при какой-либо ошибке во время\r\n    разлогинивания) должно быть массивом с элементами типа строк.*/\r\n};\r\n\r\n/*Создаем типы для промисов запросов из \"securityAPI\"*/\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"GET\" в \"getCaptchaURL\" из \"securityAPI\".*/\r\ntype getCaptchaURLResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными\r\nтипами.*/\r\n    url: string /*Информация о пути к изображению с капчей должна быть строкой.*/\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за страницу диалогов. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport avatarSource from '../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\n\r\n/*\r\nЭто константы для указания значения свойства \"type\" в объекте \"action\".\r\nЭто сделано специально, что не использовать захардкоденные значения в \"AC\" и \"reducers\".\r\nСогласно модульному паттерну \"Redux Ducks\" чтобы избежать случаев одиноковых значений\r\nиз-за чего один и тот же объект \"action\" может сработать в нескольких \"reducers\", в значениях констант для\r\nсвойств \"type\" в объекте \"action\" \"указываются имя-проекта/имя-файла/имя-объекта-action\".\r\n*/\r\nconst ADD_MESSAGE = 'react-samurai-01/dialogs-reducer/ADD-MESSAGE'; /*Объект \"action\" для добавления исходящего\r\nсообщения на странице диалогов.*/\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialStateType = typeof initialState;\r\n\r\n/*Создаем тип для объектов с данными для диалога. Объект, содержащий информацию с данными для диалога должен обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype DialogType = {\r\n    id: number /*\"ID\" диалога должно быть числом.*/\r\n    name: string /*Имя, с кем ведется диалог, должно быть строкой.*/\r\n    avatar: typeof avatarSource /*Аватар того, с кем ведется диалог, получаем на основе самого изображения аватара при\r\n    помощи \"typeof\".*/\r\n};\r\n\r\n/*Создаем тип для объектов с данными для исходящих сообщений в диалогах. Объект, содержащий информацию с данными для\r\nисходящих сообщений в диалогах должен обязательно содержать следующие поля с указанными типами.*/\r\ntype MessageType = {\r\n    id: number /*\"ID\" исходящего сообщения должно быть числом.*/\r\n    message: string /*Текст исходящего сообщения должно быть строкой.*/\r\n    avatar: typeof avatarSource /*Аватар того, от кого отправлено исходящее сообщение, получаем на основе самого\r\n    изображения аватара при помощи \"typeof\".*/\r\n};\r\n\r\n/*Создаем тип для объектов с данными для входящих сообщений в диалогах. Объект, содержащий информацию с данными для\r\nвходящих сообщений в диалогах должен обязательно содержать следующие поля с указанными типами.*/\r\ntype IncomingMessageType = {\r\n    id: number /*\"ID\" входящего сообщения должно быть числом.*/\r\n    message: string /*Текст входящего сообщения должно быть строкой.*/\r\n    avatar: typeof avatarSource /*Аватар того, от кого отправлено входящее сообщение, получаем на основе самого\r\n    изображения аватара при помощи \"typeof\".*/\r\n};\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    dialogs: [ /*Создаем массив объектов, которые хранят информацию о диалогах на странице диалогов.*/\r\n        {id: 1, name: 'Abba', avatar: avatarSource},\r\n        {id: 2, name: 'Bret', avatar: avatarSource},\r\n        {id: 3, name: 'Carry', avatar: avatarSource},\r\n        {id: 4, name: 'Daemon', avatar: avatarSource},\r\n        {id: 5, name: 'Eric', avatar: avatarSource},\r\n        {id: 6, name: 'Frye', avatar: avatarSource}\r\n    ] as Array<DialogType>, /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"DialogType\".*/\r\n\r\n    messagesData: [ /*Создаем массив объектов, которые хранят информацию о исходящих сообщениях в диалогах на странице\r\n    диалогов.*/\r\n        {id: 1, message: 'Hi', avatar: avatarSource},\r\n        {id: 2, message: '..', avatar: ''},\r\n        {id: 3, message: 'Fine', avatar: avatarSource},\r\n        {id: 4, message: 'You?', avatar: avatarSource}\r\n    ] as Array<MessageType>, /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"MessageType\".*/\r\n\r\n    incomingMessagesData: [ /*Создаем массив объектов, которые хранят информацию о входящих сообщениях в диалогах на\r\n    странице диалогов.*/\r\n        {id: 1, message: '..', avatar: ''},\r\n        {id: 2, message: 'How are you?', avatar: avatarSource},\r\n        {id: 3, message: '..', avatar: ''},\r\n        {id: 4, message: '..', avatar: ''},\r\n        {id: 5, message: 'OK', avatar: avatarSource}\r\n    ] as Array<IncomingMessageType> /*Указываем, что этот массив объектов имеет тип массива элементов с\r\n    типом \"IncomingMessageType\".*/\r\n};\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst dialogsReducer = (state = initialState, action: ActionsType): InitialStateType => { /*Указываем, что тип\r\n\"state\" на выходе имеет тот же тип \"InitialStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case ADD_MESSAGE:\r\n            let newMessage = { /*Создаем новое исходящее сообщение в виде объекта.*/\r\n                id: 6, /*Указываем \"ID\" исходящего сообщения.*/\r\n                message: action.newMessageText, /*Указываем текст исходящего сообщения.*/\r\n                avatar: avatarSource /*Указываем аватар пользователя, которые будет отрисовываться рядом с исходящим\r\n                сообщением.*/\r\n            };\r\n            return { /*Добавляем это новое исходящее сообщение в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                messagesData: [...state.messagesData, newMessage] /*Делаем глубокую копию \"state\". Добавляем данные для\r\n                нового исходящего сообщения в диалогах в \"state\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = AddMessageActionCreatorActionType; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип.*/\r\n\r\ntype AddMessageActionCreatorActionType = { /*Создали тип для объекта \"action\" \"ADD_MESSAGE\" на основе\r\nсамого \"ADD_MESSAGE\" при помощи \"typeof\". А свойство \"newMessageText\" в этом объекте \"action\" должно быть строкой.*/\r\n    type: typeof ADD_MESSAGE\r\n    newMessageText: string\r\n};\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const addMessageActionCreator = (newMessageText: string): AddMessageActionCreatorActionType => ({ /*AC для\r\nдобавления нового исходящего сообщения. Объект \"action\" на выходе имеет тип \"AddMessageActionCreatorActionType\". На\r\nвходе получает \"newMessageText\", которое дожно быть строкой.*/\r\n    type: ADD_MESSAGE, /*Обязательно свойство \"type\" для AC.*/\r\n    newMessageText /*Это равносильно \"newMessageText: newMessageText\". Создаем свойство, которое содержит текст\r\n    исходящего сообщения.*/\r\n});\r\n\r\n\r\nexport default dialogsReducer; /*Экспортируем \"dialogsReducer\" по default, экспорт необходим для импорта.*/","module.exports = __webpack_public_path__ + \"static/media/preloader.3990e106.gif\";","module.exports = \"data:image/png;base64,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\"","// extracted by mini-css-extract-plugin\nmodule.exports = {\"userPhoto\":\"User_userPhoto__2T2y8\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"nav\":\"Navbar_nav___hfIq\",\"item\":\"Navbar_item__NgXYt\",\"activeLink\":\"Navbar_activeLink__2OOkO\",\"sidebarText\":\"Navbar_sidebarText__3a_XV\"};","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","/*\r\nОдной из задач этого файла является настройка графического отображения срабатываний валидаторов.\r\n*/\r\n\r\nimport React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Field, WrappedFieldMetaProps, WrappedFieldProps} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\n\"WrappedFieldMetaProps\" - этот тип мы нашли в файле декларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и использовали его\r\nдля указания типа созданного нами компонента \"FormControl\". Поэтому импортировали этот тип сюда из библиотеки\r\n\"redux-form\".\r\n\"WrappedFieldProps\" - этот тип мы нашли в файле декларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и использовали его для\r\nуказания типа созданных нами компонентов \"Textarea\" и \"Input\". Поэтому импортировали этот тип сюда из библиотеки\r\n\"redux-form\".\r\n*/\r\nimport {FieldValidatorType} from '../../../utils/validators/validators'; /*Импортируем типы.*/\r\n\r\nimport styles from './FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Типизируем \"props\" для компонента \"FormControl\". \"Props\" в этом компоненте должны обязательно содержать следующие\r\nполя с указанными типами. Все это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype FormControlPropsType = {\r\n    meta: WrappedFieldMetaProps /*Объект \"meta\" с мета-данными, который приходит к нам сверху из элемента \"Field\" из\r\n    библиотеки \"redux-form\", должен иметь тип \"WrappedFieldMetaProps\", который мы нашли в файле декларации \"Field\"\r\n    (\"Ctrl+click\" в \"WebStorm\") и импортировали сюда.*/\r\n};\r\n\r\n/*\r\n\"FormControl\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function FormControl(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"FormControl\" является компонентом, который будет содержать общую логику для графического отображения срабатывания\r\nвалидаторов независимо от типа элемента. Этот компонент получает на входе мета-данные, содержащие информацию о том, что\r\nкасались ли мы элемента и есть ли какая-либо ошибка (вроде это все берется из библиотеки \"redux-form\", текст ошибки\r\nвроде берется из того, что возвращают валидаторы при срабатывании и передают это в элемент \"Field\", собственно от\r\nэлемента \"Field\" этот компонент и будет получать эти данные при помощи замыкания), а также получает информацию\r\nо дочернем элементе.\r\n*/\r\nconst FormControl: React.FC<FormControlPropsType> = ({meta: {touched, error}, children}) => {\r\n    const hasError = touched && error; /*Создали специальную константу для удобства, которая содержит условие, что\r\n    в мета-данных указано, что мы касались элемента (meta.touched) и что присутствует какая-то ошибка (meta.error).\r\n    Этот объект \"meta\" с мета-данными придет к нам сверху из элемента \"Field\". Указали при помощи \"React.FC<>\", что\r\n    \"props\" в этом функциональном компоненте имеют тип \"FormControlPropsType\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.formControl + \" \" + (hasError ? styles.error : \"\")}> {/*Этот элемент \"div\" и есть наш\r\n        корневой элемент. Этот компонент возврщает JSX, в котором будет элемент \"div\", внутри которого будет меняться\r\n        CSS в зависимости от значения константы \"hasError\".\r\n        То есть будет два варианта:\r\n        - \"styles.formControl styles.error\"\r\n        - \"styles.formControl \"*/}\r\n            <div> {/*Внутри отрисовываем еще один элемент \"div\". \"children\" это ключевое слово в \"ReactJS\". При помощи\r\n            этого слова этот элемент \"div\" будет отрисовывать потомков, которые будут указаны в месте вызова компонента\r\n            \"FormControl\".*/}\r\n                {children}\r\n            </div>\r\n            <div> {/*Также внутри отрисовываем еще один элемент \"div\". В этом элементе будет отображаться элемент \"span\"\r\n            с текстом ошибки, указанного в валидаторе.*/}\r\n                {hasError && <span>{error}</span>}\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\n/*Далее создаем два компонента на экспорт, которые будут использоваться для отрисовки элементов \"textarea\" и \"input\" в\r\nдругих местах, где в таких элементах требуется валидация.*/\r\nexport const Textarea: React.FC<WrappedFieldProps> = (props) => { /*Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"WrappedFieldProps\". Этот тип мы нашли в файле\r\nдекларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и импортировали сюда.*/\r\n    const {input, meta, ...restProps} = props; /*Таким образом при помощи деструктуризации мы создаем константы:\r\n    - const input = props.input; (здесь внутри есть \"input.value\" - это то, что введено в поле, создается элементом\r\n    \"Field\" из библиотеки \"redux-form\")\r\n    - const meta = props.meta. (это мета-данные (тоже создаются элементом \"Field\" из библиотеки \"redux-form\"), например,\r\n    внутри них есть \"touched\" или \"error\", которые используются в компоненте \"FormControl\")\r\n    А \"...restProps\" это остальные \"props\" (в виде объекта), которые в дальнейшем можно передавать как \"...restProps\",\r\n    например, там будет \"placeholder\" для элементов \"textarea\" или \"input\".*/\r\n    return <FormControl {...props}><textarea {...input} {...restProps}/></FormControl> /*Этот компонент возвращает\r\n    компонент \"FormControl\", который получит \"props\" свыше и деструктуризирует их и передаст дочерним элементам. А в\r\n    качестве дочернего элемента этот компонент будет иметь элемент \"textarea\", внутри которого будет при помощи\r\n    деструктуризации передано:\r\n    - \"input.value\" - то, что введено в поле;\r\n    - остальные \"input.\" свойства;\r\n    - и объект с остальными \"props\".\r\n\r\n    То есть поскольку компонент \"Textarea\" будет использоваться в элементе \"Field\" из библиотеки \"redux-form\" (цепочка\r\n    будет такая: элемент \"Field\" - компонент \"Textarea\" - компонент \"FormControl\" - элемент \"textarea\"), то значит, что\r\n    компонент \"FormControl\" получит \"сверху\" \"props.meta.touched\" и \"props.meta.error\" при помощи\r\n    библиотеки \"redux-form\", которые ему необходимы для работы. А также компонент \"FormControl\" получит информацию о\r\n    своем дочернем элементе \"textarea\", так использует ключевое слово \"children\" из React, поэтому он сможет передать\r\n    этому дочернему элементу необходимые для него \"props\", например \"placeholder\" (то есть при помощи замыкание будет\r\n    доступ к \"props\" из элемента \"Field\", компонента \"Textarea\" и компонента \"FormControl\").*/\r\n};\r\n\r\nexport const Input: React.FC<WrappedFieldProps> = (props) => { /*Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"WrappedFieldProps\". Этот тип мы нашли в файле\r\nдекларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и импортировали сюда.*/\r\n    const {input, meta, ...restProps} = props; /*Таким образом при помощи деструктуризации мы создаем константы:\r\n    - const input = props.input; (здесь внутри есть \"input.value\" - это то, что введено в поле, создается элементом\r\n    \"Field\" из библиотеки \"redux-form\")\r\n    - const meta = props.meta. (это мета-данные (тоже создаются элементом \"Field\" из библиотеки \"redux-form\"), например,\r\n    внутри них есть \"touched\" или \"error\", которые используются в компоненте \"FormControl\")\r\n    А \"...restProps\" это остальные \"props\" (в виде объекта), которые в дальнейшем можно передавать как \"...restProps\",\r\n    например, там будет \"placeholder\" для элементов \"textarea\" или \"input\".*/\r\n    return <FormControl {...props}><input {...input} {...restProps}/></FormControl> /*Этот компонент возвращает\r\n    компонент \"FormControl\", который получит \"props\" свыше и деструктуризирует их и передаст дочерним элементам. А в\r\n    качестве дочернего элемента этот компонент будет иметь элемент \"input\", внутри которого будет при помощи\r\n    деструктуризации передано:\r\n    - \"input.value\" - то, что введено в поле;\r\n    - остальные \"input.\" свойства;\r\n    - и объект с остальными \"props\".\r\n\r\n    То есть поскольку компонент \"Input\" будет использоваться в элементе \"Field\" из библиотеки \"redux-form\" (цепочка\r\n    будет такая: элемент \"Field\" - компонент \"Input\" - компонент \"FormControl\" - элемент \"input\"), то значит, что\r\n    компонент \"FormControl\" получит \"сверху\" \"props.meta.touched\" и \"props.meta.error\" при помощи\r\n    библиотеки \"redux-form\", которые ему необходимы для работы. А также компонент \"FormControl\" получит информацию о\r\n    своем дочернем элементе \"input\", так использует ключевое слово \"children\" из React, поэтому он сможет передать этому\r\n    дочернему элементу необходимые для него \"props\", например \"placeholder\" (то есть при помощи замыкание будет доступ\r\n    к \"props\" из элемента \"Field\", компонента \"Input\" и компонента \"FormControl\").*/\r\n};\r\n\r\n/*Создали функцию \"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания\r\nформы в \"Login.tsx\".*/\r\nexport function createField<FormKeysType extends string>( /*Указали, что \"createField\" теперь обобщенный, то есть\r\n\"generic\". Если бы мы описали эту функцию стрелочным синтаксисом, то у нас так не получилось бы ее сделать \"generic\".\r\nТо есть теперь мы можем уточнять эту функцию при ее использовании, а точнее мы будем уточнять свойство \"name\", поэтому\r\nуказываем придуманный нами тип \"FormKeysType\" здесь и в самом \"name\" дальше. При помощи \"extends string\" указали, что\r\nэтот тип экстендится от типа строки, хотя и может быть более сложным. Последнее нам нужно, чтобы не было ошибки ниже в\r\n\"name={name}\", так как там по сути ожидается строка.*/\r\n                            placeholder: string | undefined, /*Текст \"placeholder\". Должен быть строкой или \"undefined\"\r\n                            (то есть отсуствовать вовсе, а не быть пустым).*/\r\n                            name: FormKeysType, /*Имя данных, которые будут вводится в это поле. Имеют тип\r\n                            \"FormKeysType\", то есть здесь указываются какие-то ключи, но какие именно мы должны\r\n                            указывать сами в каждой форме. Нам это нужно для того, чтобы проводить типизацию в целях\r\n                            избежания ошибки при указании свойства \"name\" в \"createField\" в компонентах. Это свойство\r\n                            важно для формирования имен свойств \"formData\", то есть данных формы.*/\r\n                            component: React.FC<WrappedFieldProps>, /*Какой компонент отрисовываем (например,\r\n                            \"Textarea\"). Указали при помощи \"React.FC<>\", что \"props\" в этих функциональных компонентах\r\n                            имеют тип \"WrappedFieldProps\". Этот тип мы нашли в файле декларации \"Field\" (\"Ctrl+click\"\r\n                            в \"WebStorm\") и импортировали сюда.*/\r\n                            validators: Array<FieldValidatorType>, /*Валидаторы. Должны быть в виде массива элементов с\r\n                            типом \"FieldValidatorType\", который мы создали и импортировали сюда.*/\r\n                            props = {}, /*Любые другие \"props\".*/\r\n                            text = '' /*Текст, который необходим некоторым элементам (например, \"Remember me?\"\r\n                            для чек-бокса \"Запомнить меня?\"). Должно быть по умолчанию строкой.*/\r\n) {\r\n/*???*/\r\n    return (\r\n        <div> {/*В итоге функция создает отдельный элемент \"div\", в котором внутри есть элемент \"Field\" из библиотеки\r\n        \"redux-form\". Что из себя будет представлять этот элемент \"Field\" будет зависеть от параметров выше.*/}\r\n            <Field placeholder={placeholder}\r\n                   name={name}\r\n                   component={component}\r\n                   validate={validators}\r\n                   {...props}\r\n            /> {text}\r\n        </div>\r\n    )\r\n};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './Header.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport headerLogoSource from '../../assets/images/headerlogo.png'; /*Импортируем из ассетов проекта логотип сайта.*/\r\n\r\n\r\n/*\r\n\"Header\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Header(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Header\" является компонентом, который отрисовывает \"хэдер\" нашего сайта, который содержит логотип сайта\r\nи отдельный блок, отображающий ссылку на форму логина или имя залогиненного пользователя и кнопку логаута.\r\nЭтот компонент подключается в компоненте \"HeaderContainer\".\r\n*/\r\nconst Header = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <header className={styles.header}> {/*Этот элемент \"header\" и есть наш корневой элемент.*/}\r\n            <img src={headerLogoSource} alt=''/> {/*\"Хэдер\" нашего сайта содержит логотип.*/}\r\n\r\n            <div className={styles.loginBlock}> {/*А также \"хэдер\" нашего сайта содержит отдельный блок,\r\n            отображающий ссылку на форму логина или имя залогиненного пользователя и кнопку логаута.*/}\r\n                {props.isAuth ? /*Если свойство \"isAuth\", которое указывает залогинен ли пользователь, является \"TRUE\",\r\n                то*/\r\n                    <div>{props.login} - <button onClick={props.logout}>Log out</button></div> /*отрисуется элемент\r\n                    \"div\" с логином пользователя, который берется из \"props\", и с элементом \"button\", который является\r\n                    кнопкой логаута (сработает TC \"logout\"),*/\r\n                    : <NavLink to={'/login/'}>Log in</NavLink>} {/*иначе отрисуется элемент \"NavLink\" для перехода\r\n                    на страницу логинизации.*/}\r\n            </div>\r\n        </header>\r\n    );\r\n};\r\n\r\nexport default Header; /*Экспортируем компонент \"Header\" по default, экспорт необходим для импорта.*/","/*\r\nЭто файл \"reducer\", отвечающего за аутентификацию и связанные с ней процессы. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {authAPI, ResultCodeEnum, ResultCodeForCaptchaEnum, securityAPI} from '../api/api'; /*Импортируем блоки запросов,\r\nсвязанных с аутентификацией и связанных с капчей из \"api.ts\". Так же оттуда импортируем списки кодов ответов от\r\nсервера.*/\r\nimport {stopSubmit} from 'redux-form'; /*Импортируем специальный AC \"stopSubmit\" из библиотеки \"redux-form\", который\r\nсообщает UI, что что-то пошло не так, и останавливает \"submit\" данных в форме.*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Импортируем типы.*/\r\nimport {Dispatch} from 'redux'; /*Импортировали из библиотеки \"redux\", чтобы создать тип для \"dispatch\", который\r\nпередается в \"thunks\" и TC.*/\r\nimport {ThunkAction} from 'redux-thunk'; /*Импортировали из библиотеки \"redux-thunk\", чтобы создать тип для \"thunks\".*/\r\n\r\n\r\n/*\r\nЭто константы для указания значения свойства \"type\" в объекте \"action\".\r\nЭто сделано специально, что не использовать захардкоденные значения в \"AC\" и \"reducers\".\r\nСогласно модульному паттерну \"Redux Ducks\" чтобы избежать случаев одиноковых значений\r\nиз-за чего один и тот же объект \"action\" может сработать в нескольких \"reducers\", в значениях констант для\r\nсвойств \"type\" в объекте \"action\" \"указываются имя-проекта/имя-файла/имя-объекта-action\".\r\n*/\r\nconst SET_USER_DATA = 'react-samurai-01/auth-reducer/SET-USER-DATA'; /*Объект \"action\" для установки данных\r\nзалогиненного пользователя.*/\r\nconst SET_CAPTCHA_URL = 'react-samurai-01/auth-reducer/SET-CAPTCHA-URL'; /*Объект \"action\" для установки URL\r\nизображения с капчей.*/\r\n\r\n/*Сначала создали тип \"state\", но не используем его здесь. \"state\" обязательно должен был содержать следующие поля\r\nуказанного типа.*/\r\n/*type InitialStateType2 = {\r\n    id: number | null, //\"ID\" пользователя может быть или числом, или \"null\", то есть быть пустым.\r\n    email: string | null, //\"email\" пользователя может быть или строкой, или \"null\", то есть быть пустым.\r\n    login: string | null, //\"login\" пользователя может быть или строкой, или \"null\", то есть быть пустым.\r\n    isAuth: boolean, //Информация залогинен ли пользователь должна быть булева типа.\r\n    captchaURL: string | null //Информация с путем к капче может быть или строкой, или \"null\", то есть быть пустым.\r\n};*/\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    id: null as number | null, /*Свойство, которое хранит \"ID\" залогиненного пользователя. Указываем, что изначально\r\n    это свойство может иметь тип \"null\", то есть быть пустым, или быть числом.*/\r\n    email: null as string | null, /*Свойство, которое хранит \"email\" залогиненного пользователя. Указываем, что\r\n    изначально это свойство может иметь тип \"null\", то есть быть пустым, или быть строкой.*/\r\n    login: null as string | null, /*Свойство, которое хранит \"login\" залогиненного пользователя. Указываем, что\r\n    изначально это свойство может иметь тип \"null\", то есть быть пустым, или быть строкой.*/\r\n    isAuth: false, /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    captchaURL: null as string | null /*Свойство, которое хранит URL изображения с капчей. Указываем, что изначально\r\n    это свойство может иметь тип \"null\", то есть быть пустым, или быть строкой.*/\r\n};\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst authReducer = (state = initialState, action: ActionsType): InitialStateType => { /*Указываем, что тип \"state\"\r\nна выходе имеет тот же тип \"InitialStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case SET_USER_DATA:\r\n        case SET_CAPTCHA_URL: /*Здесь для обоих случаев один и тот же код потому, что в обоих соотвествующих AC\r\n        используется \"payload\". Благодаря деструктуризации мы сможет передать нужные значение свойств из \"payload\" в\r\n        нужные свойства \"state\" при совпадении имен свойств.*/\r\n            return { /*Устанавливаем данные по залогиненному пользователю в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                ...action.payload, /*Объект \"action\" будет иметь объект \"payload\", который содержит \"id\", \"email\",\r\n                \"login\" и \"isAuth\". Аналогично может прийти такой же объект \"payload\", но он может содержать только\r\n                \"captchaURL\" - URL изображения с капчей. Делаем глубокую копию, чтобы установить эти данные в \"state\",\r\n                деструктурируя этот объект \"payload\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = SetAuthUserDataActionType | SetCaptchaURLActionType; /*Здесь мы\r\nвсе созданные раннее типы для объектов \"action\" объеденили в один тип.*/\r\n\r\ntype SetAuthUserDataActionType = { /*Создали тип для объекта \"action\" \"SET_USER_DATA\" на основе самого \"SET_USER_DATA\"\r\nпри помощи \"typeof\". А свойство \"payload\" в этом объекте \"action\" имеет тип \"SetAuthUserDataActionPayloadType\",\r\nсозданный нами ниже.*/\r\n    type: typeof SET_USER_DATA\r\n    payload: SetAuthUserDataActionPayloadType\r\n};\r\n\r\ntype SetAuthUserDataActionPayloadType = { /*Создали тип для свойства \"payload\" в объекте \"action\" \"SET_USER_DATA\".*/\r\n    id: number | null /*\"ID\" пользователя может быть числом или \"null\", то есть быть пустым.*/\r\n    email: string | null /*\"email\" пользователя может быть строкой или \"null\", то есть быть пустым.*/\r\n    login: string | null /*\"login\" пользователя может быть строкой или \"null\", то есть быть пустым.*/\r\n    isAuth: boolean /*Информация залогинен ли пользователь должна быть булева типа.*/\r\n};\r\n\r\ntype SetCaptchaURLActionType = { /*Создали тип для объекта \"action\" \"SET_CAPTCHA_URL\" на основе самого \"SET_CAPTCHA_URL\"\r\nпри помощи \"typeof\". А свойство \"payload\" в этом объекте \"action\" имеет тип объекта, который внутри содержит свойство\r\n\"captchaURL\" с типом строки.*/\r\n    type: typeof SET_CAPTCHA_URL,\r\n    payload: { captchaURL: string }\r\n};\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nconst setAuthUserData = (id: number | null, /*На входе получает \"ID\" пользователя, который должен быть числом или\r\n                         \"null\", то есть быть пустым.*/\r\n                         email: string | null, /*На входе получает \"email\" пользователя, который должен быть строкой или\r\n                         \"null\", то есть быть пустым.*/\r\n                         login: string | null, /*На входе получает \"login\" пользователя, который должен быть строкой или\r\n                         \"null\", то есть быть пустым.*/\r\n                         isAuth: boolean /*На входе получает информацию залогинен ли пользователь, которая должна быть\r\n                         булева типа.*/\r\n): SetAuthUserDataActionType => ({\r\n/*AC для установки данных залогиненного пользователя в \"state\". Объект \"action\" на выходе имеет\r\nтип \"SetAuthUserDataActionType\".*/\r\n    type: SET_USER_DATA, /*Обязательно свойство \"type\" для AC.*/\r\n    payload: { /*Объект с данными по залогиненному пользователю. Далее мы его деструктурируем в \"authReducer\".*/\r\n        id, /*Свойство, которое хранит \"ID\" залогиненного пользователя.*/\r\n        email, /*Свойство, которое хранит \"email\" залогиненного пользователя.*/\r\n        login, /*Свойство, которое хранит \"login\" залогиненного пользователя.*/\r\n        isAuth /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    }\r\n});\r\n\r\nconst setCaptchaURL = (captchaURL: string): SetCaptchaURLActionType => ({ /*AC для установки URL изображения с капчей\r\nв \"state\". Объект \"action\" на выходе имеет тип \"SetCaptchaURLActionType\". На входе получает \"captchaURL\", которое\r\nдожно быть строкой.*/\r\n    type: SET_CAPTCHA_URL, /*Обязательно свойство \"type\" для AC.*/\r\n    payload: { /*Объект с URL изображения с капчей. Далее мы его деструктурируем в \"authReducer\".*/\r\n        captchaURL /*Свойство, которое хранит URL изображения с капчей.*/\r\n    }\r\n});\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype GetStateType = () => AppStateType; /*Создали тип для \"getState()\", который получает \"thunks\" и TC. \"getState()\"\r\nдолжен быть функцией, которая не получает ничего на входе и возвращает объект с типом \"AppStateType\", созданным нами и\r\nимпортированным сюда. Мы это здесь не используем, так как типизация \"thunks\" перекрывает эту типизацию, поскольку\r\nтипизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше,\r\nто есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n\r\ntype DispatchType = Dispatch<ActionsType>; /*Создали тип для \"dispatch\", передается в \"thunks\" и TC. \"dispatch\" должен\r\nбыть \"Dispatch\" из библиотеки \"redux\", работающий с объектами \"action\" тип \"ActionsType\", который мы создали выше.*/\r\n\r\ntype ThunkType = ThunkAction<Promise<void>, AppStateType, unknown, ActionsType> /*Создали тип для \"thunks\". \"thunks\"\r\nдолжны быть объектами \"action\" для \"thunks\" из библиотеки \"redux-thunk\", работающими с:\r\n1) промисами, которые ничего не возвращают (промисы потому, что у нас асинхронные \"thunks\" из-за использования\r\n\"async/await\", хотя обычно \"thunks\" ничего не возвращают);\r\n2) \"state\" с типом \"AppStateType\", созданным нами и импортированным сюда;\r\n3) какими-то неизвестными дополнительными аргументами;\r\n4) объектами \"action\" тип \"ActionsType\", который мы создали выше.\r\nЭти уточнения мы нашли в файле декларации \"ThunkAction\", \"Ctrl+click\" в \"WebStorm\".\r\n*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const getAuthUserData = (): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных залогиненного пользователя в \"state\". Здесь вместо использования \".then\" мы\r\nиспользуем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе возвращает\r\n\"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\"\r\nи дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\"\r\nбудет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const data = await authAPI.me(); /*Делаем запрос на сервер для получения данных залогиненного пользователя. Здесь\r\n    будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"data\". Здесь \"return\" не нужен, так как\r\n    асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (data.resultCode === ResultCodeEnum.Success) { /*Если свойство \"resultCode\", которое пришло в ответе от сервера,\r\n    содержит код \"0\", то есть ошибки при залогинивании не было, то*/\r\n        let {id, email, login} = data.data; /*деструктурируем объект \"data\", который пришел в ответе от сервера,\r\n        и получаем \"ID\", \"email\" и \"login\" залогиненного пользователя*/\r\n        dispatch(setAuthUserData(id, email, login, true)); /*и устанавливаем эти данные в \"state\" при помощи\r\n        AC \"setAuthUserData\", четвертый параметр это \"isAuth\", чтобы сообщить, что пользователь залогинился.*/\r\n    }\r\n};\r\n\r\nexport const login = (email: string, /*На входе получает \"email\" пользователя, который должен быть строкой.*/\r\n                      password: string, /*На входе получает пароль пользователя, который должен быть строкой.*/\r\n                      rememberMe: boolean, /*На входе получает информацию запомнить ли пользователя, которая должна быть\r\n                      булева типа.*/\r\n                      captcha: string /*На входе получает путь к капче, который должен быть строкой.*/\r\n) => async (dispatch: any) => {\r\n/*Это TC для осуществления логинизации через наше приложение. Здесь вместо использования \".then\" мы используем\r\n\"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает \"dispatch\" типа\r\n\"any\", так как пока мы конкретно не знаем какого он будет типа.*/\r\n    const data = await authAPI.login(email, password, rememberMe, captcha); /*Делаем запрос на сервер для залогинивания\r\n    пользователя. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"data\". Здесь \"return\"\r\n    не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе\r\n    с ответом от сервера.*/\r\n\r\n    if (data.resultCode === ResultCodeEnum.Success) { /*Если свойство \"resultCode\", которое пришло в ответе от сервера,\r\n    содержит код \"0\", то есть ошибки при залогинивании не было, то*/\r\n        dispatch(getAuthUserData()) /*вызываем TC \"getAuthUserData\" для запроса и установки данных залогиненного\r\n        пользователя в \"state\".*/\r\n    } else {\r\n        if (data.resultCode === ResultCodeForCaptchaEnum.CaptchaIsRequired) { /*Иначе если свойство \"resultCode\",\r\n        которое пришло в ответе от сервера, содержит код \"10\", то есть нужно ввести капчу, то*/\r\n            dispatch(getCaptchaURL()); /*вызываем TC \"getCaptchaURL\" для получения URL изображения с капчей с сервера\r\n            и установки его в \"state\".*/\r\n        } /*Также иначе если пришло какое-то информационное сообщение об ошибке при логинизации от сервера в\r\n        массиве \"messages\", то мы положим первый элемент этого массива в переменную \"message\", если длина этого массива\r\n        больше нуля, или же положим в переменную \"message\" текст \"unknown error\".*/\r\n        let message = data.messages.length > 0 ? data.messages[0] : 'unknown error'\r\n        dispatch(stopSubmit('login', {_error: message})); /*Затем задиспатчим специальный AC \"stopSubmit()\"\r\n        из библиотеки \"redux-form\", который сообщит UI, что что-то пошло не так, и остановит \"submit\" данных. Первым\r\n        параметром указывается какую форму необходимо остановить, а вторым параметром указывается объект, в котором\r\n        должно быть свойство \"_error\" (из библиотеки \"redux-form\", означает ошибку для всей формы, но здесь можно\r\n        использовать и имена других полей, которые мы создали), которому присваивается значение с текстом ошибки.\r\n\r\n        Но сейчас со \"stopSubmit\" проблемы. При его использовании возникает проблема асинхроности, так как\r\n        библиотека \"redux-form\" вызывает \"setSubmitSuccessed()\" сразу после \"stopSubmit()\", не успев вернуть ошибку.\r\n        Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно использовать\r\n        такой костыль:\r\n        setTimeout(async () => await dispatch(stopSubmit('login', {_error: message})))\r\n\r\n        Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки \"redux-form\" (8.3.6).*/\r\n    }\r\n};\r\n\r\nconst getCaptchaURL = (): ThunkType => async (dispatch) => {\r\n/*Это TC для получения URL изображения с капчей с сервера и установки его в \"state\". Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе возвращает\r\n\"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\"\r\nи дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\"\r\nбудет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await securityAPI.getCaptchaURL(); /*Делаем запрос на сервер для получения капчи. Здесь будет\r\n    ожидаться промис. Когда он зарезольвиться, он сохраниться в \"data\". Здесь \"return\" не нужен, так как асинхронная\r\n    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n    const captchaURL = response.data.url; /*Получив ответ от сервера, сохраняем из ответа сервера URL капчи.*/\r\n\r\n    dispatch(setCaptchaURL(captchaURL)); /*Затем устанавливаем этот URL капчи в \"state\" при помощи AC \"setCaptchaURL\".*/\r\n};\r\n\r\nexport const logout = (): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления логаута. Здесь вместо использования \".then\" мы используем \"async/await\". Промис будет\r\nожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await authAPI.logout(); /*Делаем запрос на сервер для разлогинивания пользователя. Здесь будет\r\n    ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как асинхронная\r\n    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.data.resultCode === 0) { /*Если свойство \"resultCode\", которое пришло в ответе от сервера, содержит\r\n    код \"0\", то есть ошибки при разлогинивании не было, то*/\r\n        dispatch(setAuthUserData(null, null, null, false)); /*обнуляем данные пользователя\r\n        в \"state\" при помощи AC \"setAuthUserData\", четвертый параметр это \"isAuth\", чтобы сообщить, что пользователь\r\n        разлогинился.*/\r\n    }\r\n};\r\n\r\n\r\nexport default authReducer; /*Экспортируем \"authReducer\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\n\r\nimport Header from './Header'; /*Подключаем компонент \"Header\".*/\r\n\r\nimport {logout} from '../../redux/auth-reducer'; /*Подключаем TC \"logout\" из \"auth-reducer\".*/\r\n\r\n\r\n/*\r\n\"HeaderContainer\" это классовый компонент.\r\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\r\nконцепцию ООП.\r\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\r\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\r\nвзаимодействует.\r\nНапример, у него можно постоянно запрашивать JSX.\r\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\r\nКомпонент это функция, которая возвращает JSX.\r\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\r\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\r\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"HeaderContainer\" является контейнерным компонентом для компонента \"Header\".\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.js\") из библиотеки \"react-redux\".\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nclass HeaderContainer extends React.Component {\r\n    render() {\r\n        /*\r\n        Здесь после return в компоненте начинается HTML разметка.\r\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n        */\r\n        return (\r\n            <Header {...this.props}/> /*Отрисовываем компонент \"Header\" и передаем ему через \"props\" необходимые\r\n            для него данные. Этот элемент \"Header\" и есть наш корневой элемент. Здесь используется\r\n            spread-оператор \"...\", который из всех \"props\" создает атрибуты для компонента.*/\r\n        );\r\n    };\r\n};\r\n\r\nconst mapStateToProps = (state) => ({ /*Здесь указываются данные из \"state\", которые необходимо передать\r\nв компонент \"HeaderContainer\". Эта функция возвращает указанные данные в виде объекта.*/\r\n    isAuth: state.auth.isAuth, /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    login: state.auth.login, /*\"login\" залогиненного пользователя.*/\r\n});\r\n\r\nexport default connect(mapStateToProps, {logout})(HeaderContainer); /*\"logout\" это TC для\r\nосуществления логаута.*/\r\n/*\r\nПри помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\r\nв другой контейнерный компонент \"HeaderContainer\" из этого файла.\r\nПолучившийся в итоге компонент экспортируем, который будет использоваться под именем \"HeaderContainer\", по default,\r\nэкспорт необходим для импорта.\r\n*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './Sidebar.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"Sidebar\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Sidebar(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"SideBar\" является компонентом, который описывает типовое отображение друзей в онлайне в навигационном меню сайта.\r\nЭтот компонент подключается в компоненте \"NavBar\".\r\n*/\r\nconst SideBar = (props) => {\r\n    let path = '/dialogs/' + props.id; /*Путь для \"NavLink\" формируется на основе \"ID\" пользователя, который берется из\r\n    параметров \"props\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <nav className={styles.sidebar}> {/*Этот элемент \"nav\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовой пункт меню навигации по друзьям в онлайне, который будет\r\n        отрисовываться в компоненте \"NavBar\" при помощи метода \"map\".*/}\r\n            <div>\r\n                <NavLink to={path} activeClassName={styles.active}> {/*Типовой пункт меню навигации по друзьям в онлайне\r\n                содержит элемент \"NavLink\".*/}\r\n                    <img src={props.avatar} alt=''/> {/*Этот элемент \"NavLink\" содержит аватар пользователя, ссылка\r\n                    на который берется из параметров \"props\".*/}\r\n\r\n                    <div>{props.name}</div> {/*Также этот элемент \"NavLink\" содержит имя пользователя, которое\r\n                    берется из параметров \"props\".*/}\r\n                </NavLink>\r\n            </div>\r\n        </nav>\r\n    );\r\n};\r\n\r\nexport default SideBar; /*Экспортируем компонент \"Sidebar\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './Navbar.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport SideBar from './Sidebar/Sidebar'; /*Подключаем компонент \"Sidebar\".*/\r\n\r\n\r\n/*\r\n\"Navbar\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Navbar(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Navbar\" является компонентом, который отрисовывает меню навигации нашего сайта.\r\nЭтот компонент подключается в компоненте \"NavbarContainer\".\r\n*/\r\nconst Navbar = (props) => {\r\n    /*\r\n    В JSX в массив можно вкладывать компоненты.\r\n    В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде строки.\r\n    \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования исходного массива.\r\n    Метод \"map\" принимает стрелочную функцию.\r\n    То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n    и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    Потом будет браться следующий объект из исходного массива объектов\r\n    и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n    То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов.\r\n    В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n    Массив \"sidebarElements\" содержит список друзей в онлайне.\r\n    При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n    */\r\n    let sidebarElements = props.sidebar.friendsData.map(f => <SideBar name={f.name}\r\n                                                                      id={f.id}\r\n                                                                      avatar={f.avatar}\r\n                                                                      key={f.id}/>);\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <nav className={styles.nav}> {/*Этот элемент \"nav\" и есть наш корневой элемент. Этот элемент представляет\r\n        из себя меню навигации.*/}\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"Profile\".*/}\r\n                <NavLink to='/profile/' activeClassName={styles.activeLink}>Profile</NavLink> {/*Этот пункт содержит\r\n                элемент \"NavLink\" со ссылкой страницу \"Profile\".*/}\r\n            </div>\r\n\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"Dialogs\".*/}\r\n                <NavLink to='/dialogs/' activeClassName={styles.activeLink}>Dialogs</NavLink> {/*Этот пункт содержит\r\n                элемент \"NavLink\" со ссылкой страницу \"Dialogs\".*/}\r\n            </div>\r\n\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"Users\".*/}\r\n                <NavLink to='/users/' activeClassName={styles.activeLink}>Users</NavLink> {/*Этот пункт содержит\r\n                элемент \"NavLink\" со ссылкой страницу \"Users\".*/}\r\n            </div>\r\n\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"News\".*/}\r\n                <NavLink to='/news/' activeClassName={styles.activeLink}>News</NavLink> {/*Этот пункт содержит\r\n                элемент \"NavLink\" со ссылкой страницу \"News\".*/}\r\n            </div>\r\n\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"Music\".*/}\r\n                <NavLink to='/music/' activeClassName={styles.activeLink}>Music</NavLink> {/*Этот пункт содержит\r\n                элемент \"NavLink\" со ссылкой страницу \"Music\".*/}\r\n            </div>\r\n\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"Settings\".*/}\r\n                <NavLink to='/settings/' activeClassName={styles.activeLink}>Settings</NavLink> {/*Этот пункт\r\n                содержит элемент \"NavLink\" со ссылкой страницу \"Settings\".*/}\r\n            </div>\r\n\r\n            <div className={styles.item}> {/*Создаем пункт меню для страницы \"Friends\".*/}\r\n                <NavLink to='/friends/' activeClassName={styles.activeLink}>Friends</NavLink> {/*Этот пункт\r\n                содержит элемент \"NavLink\" со ссылкой страницу \"Friends\".*/}\r\n            </div>\r\n\r\n            <div className={styles.sidebarText}>Online:</div> {/*Также меню навигации содержит отдельный сайдбар,\r\n            отображающий друзей в онлайне.*/}\r\n\r\n            {sidebarElements} {/*Сами элементы сайдбара, отображающие друзей в онлайне.*/}\r\n        </nav>\r\n    );\r\n};\r\n\r\nexport default Navbar; /*Экспортируем компонент \"Navbar\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\n\r\nimport Navbar from './Navbar'; /*Подключаем компонент \"Navbar\".*/\r\n\r\n\r\n/*\r\n\"NavbarContainer\" это не классовый компонент и не функциональный компонент.\r\n\"NavbarContainer\" является только контейнерным компонентом для компонента \"Navbar\".\r\nВ отличии от классового компонента, этот компонент не имеет методов жизненного цикла.\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.js\") из библиотеки \"react-redux\".\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВ этом компоненте мы просто создаем \"mapStateToProps\" и \"mapDispatchToProps\", тем самым формируя \"props\"\r\nдля презентационной компоненты \"Navbar\". Поэтому нам не нужно создавать классовый компонент для этого.\r\nТаким же образом созданы контейнерные компоненты \"MyPostsContainer\", \"DialogsContainer\".\r\n*/\r\n\r\nconst mapStateToProps = (state) => { /*Здесь указываются данные из \"state\", которые необходимо передать\r\nв компонент \"Navbar\". Эта функция возвращает указанные данные в виде объекта.*/\r\n    return {\r\n        sidebar: state.sidebar /*Данные необходимые для работы сайдбара.*/\r\n    }\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => { /*Здесь указываются данные (\"callbacks - \"AC\" или \"TC\") \"dispatch\",\r\nкоторые необходимо передать в компонент \"Navbar\". Эта функция возвращает указанные данные в виде объекта.\r\nКак работает функция \"mapDispatchToProps\" описано в \"DialogsContainer.jsx\".*/\r\n    return {\r\n        /*В нашем случае никакие AC или TC для работы компонента \"Navbar\" не требуются.*/\r\n    }\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(Navbar);\r\n/*\r\nПри помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\r\nкомпоненту \"Navbar\". Экспортируем получившийся в итоге компонент, который будет использоваться под именем\r\n\"NavbarContainer\", по default, экспорт необходим для импорта.\r\n*/","/*\r\nЧтобы избавиться от повторяющегося кода в \"users-reducer.ts\" в \"reducer\" в \"FOLLOW\" и \"UNFOLLOW\", мы создали\r\nэтот файл, который содержит общую логику для \"FOLLOW\" и \"UNFOLLOW\". При помощи этой логики можно перебирать\r\nэлемента (объекты) в любом массиве и менять какое-либо свойство при срабатывании условия у какого-то\r\nэлемента (объекта) в этом массиве.\r\n*/\r\n\r\nexport const updateObjectInArray = (items, itemID, objPropName, newObjProps) => {\r\n    /*\r\n    \"items\" - будет получать массив объектов (информация о пользователях для постраничного вывода из \"state\"\r\n    для \"FOLLOW\" и \"UNFOLLOW\").\r\n    \"itemID\" - значение для сравнения при поиске нужного объекта в массиве (\"ID\" пользователя для фолловинга из\r\n    объекта \"action\" для \"FOLLOW\" и \"UNFOLLOW\").\r\n    \"objPropName\" - имя свойство в объектах, по которому идет проверка сравнением ('id' для \"FOLLOW\" и \"UNFOLLOW\").\r\n    \"newObjProps\" - объект со свойствами и их значениями, который нужно подменить на место старого в найденном объекте\r\n    (\"{followed: true}\" для фолловинга и \"{followed: true}\" для анфолловинга для \"FOLLOW\" и \"UNFOLLOW\").\r\n    */\r\n    return items.map(u => { /*Мапим полученный массив объектов. \"u\" - это каждый элемент массива. Метод \"map\" возвращает\r\n    новый массив в итоге на основе полученного массива.*/\r\n        if (u[objPropName] === itemID) { /*(Вспомним, что \"u.id\" и \"u[\"id\"]\" это одно и тоже) Если у какого-либо\r\n        элемента (объекта, содержащего информацию о пользователе для постраничного вывода в случае для \"FOLLOW\" и\r\n        \"UNFOLLOW\") массива указанное свойство \"objPropName\" (\"u.id\", то есть \"ID\" пользователя в случае для \"FOLLOW\" и\r\n        \"UNFOLLOW\") равно значению для сравнения \"itemID\" (из объекта \"action\" там будет \"ID\" пользователя для\r\n        фолловинга/анфолловинга для \"FOLLOW\" и \"UNFOLLOW\"),*/\r\n            return {...u, ...newObjProps} /*то делаем деструктуризацию этого элемента (объекта, содержащего информацию о\r\n            пользователе для постраничного вывода в случае для \"FOLLOW\" и \"UNFOLLOW\") и подменяем ему указанное свойство\r\n            со значением в \"newObjProps\" за место старого значения этого свойства (\"{followed: true}\" для фолловинга и\r\n            \"{followed: true}\" для анфолловинга для \"FOLLOW\" и \"UNFOLLOW\").*/\r\n        }\r\n        return u; /*Если же условие выше не срабатывает, то \"map\" вернет элемент массива как есть.*/\r\n    }) /*В итоге \"map\" соберет новый массив с теми же объектами, где у одного из них измениться значение одного из\r\n    свойств (\"{followed: true}\" для фолловинга и \"{followed: true}\" для анфолловинга для \"FOLLOW\" и \"UNFOLLOW\")*/\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за страницу постраничного вывода пользователей. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {usersAPI} from '../api/api'; /*Импортируем блок запросов, связанных со страницей с постраничным выводом\r\nпользователей из \"api.ts\".*/\r\n\r\nimport {updateObjectInArray} from '../utils/helpers/object-helpers'; /*Импортируем вспомогательную функцию, которая\r\nсодержит общую логику для \"FOLLOW\" и \"UNFOLLOW\" в \"reducer\".*/\r\n\r\nimport {UserType} from '../types/types'; /*Импортируем типы.*/\r\nimport {AppStateType} from './redux-store'; /*Импортируем типы.*/\r\nimport {Dispatch} from 'redux'; /*Импортировали из библиотеки \"redux\", чтобы создать тип для \"dispatch\", который\r\nпередается в \"thunks\" и TC.*/\r\nimport {ThunkAction} from 'redux-thunk'; /*Импортировали из библиотеки \"redux-thunk\", чтобы создать тип для \"thunks\".*/\r\n\r\n\r\n/*\r\nЭто константы для указания значения свойства \"type\" в объекте \"action\".\r\nЭто сделано специально, что не использовать захардкоденные значения в \"AC\" и \"reducers\".\r\nСогласно модульному паттерну \"Redux Ducks\" чтобы избежать случаев одиноковых значений\r\nиз-за чего один и тот же объект \"action\" может сработать в нескольких \"reducers\", в значениях констант для\r\nсвойств \"type\" в объекте \"action\" \"указываются имя-проекта/имя-файла/имя-объекта-action\".\r\n*/\r\nconst FOLLOW = 'react-samurai-01/users-reducer/FOLLOW'; /*Объект \"action\" для фолловинга пользователей.*/\r\nconst UNFOLLOW = 'react-samurai-01/users-reducer/UNFOLLOW'; /*Объект \"action\" для анфолловинга пользователей.*/\r\nconst SET_USERS = 'react-samurai-01/users-reducer/SET-USERS'; /*Объект \"action\" для установки данных пользователей для\r\nпостраничного вывода.*/\r\nconst SET_CURRENT_PAGE = 'react-samurai-01/users-reducer/SET-CURRENT-PAGE'; /*Объект \"action\" для установки значения\r\nтекущего номера выбранной страницы в постраничном выводе пользователей.*/\r\nconst SET_TOTAL_USERS_COUNT = 'react-samurai-01/users-reducer/SET-TOTAL-USERS-COUNT'; /*Объект \"action\" для установки\r\nзначения общего количества пользователей. Используется, чтобы рассчитать сколько страниц нужно будет при постраничном\r\nвыводе пользователей.*/\r\nconst TOGGLE_IS_FETCHING = 'react-samurai-01/users-reducer/TOGGLE-IS-FETCHING'; /*Объект \"action\" для указания находится\r\nли в процессе запрос на сервер на получение данных по пользователям для постраничного вывода. Если в процессе, то будет\r\nотрисовываться компонент-заглушка \"Preloader\".*/\r\nconst TOGGLE_IS_FOLLOWING_IN_PROGRESS = 'react-samurai-01/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS'; /*Объект\r\n\"action\" для указания находится ли в процессе анфолловинга/фолловинга какой-либо пользователь. Если в процессе, то\r\nкнопка для анфолловинга/фолловинга будет отключена.*/\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    users: [] as Array<UserType>, /*Свойство, которое будет хранить объекты с информацией о пользователях для\r\n    постраничного вывода, полученные с сервера. Указываем, что этот массив объектов имеет тип массива элементов с\r\n    типом \"UserType\". Тип \"UserType\" был создан нами и импортирован сюда.*/\r\n    pageSize: 30, /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводится\r\n    на одной странице в постраниченом выводе пользователей.*/\r\n    totalUsersCount: 0, /*Свойство, которое хранит значение, обозначающее общее количество пользователей.\r\n    Получается с сервера.*/\r\n    currentPage: 1, /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в постраничном\r\n    выводе пользователей.*/\r\n    isFetching: false, /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение\r\n    данных по пользователям для постраничного вывода. Если в процессе, то будет отрисовываться\r\n    компонент-заглушка \"Preloader\".*/\r\n    WhoIsInFollowingProgress: [] as Array<number>, /*Специальное свойство, которое содержит массив, который будет\r\n    хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга,\r\n    то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя. Указываем, что это свойство\r\n    имеет тип массива элементов с типом \"number\" (число).*/\r\n    portionSize: 20 /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе\r\n    может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное\r\n    количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться\r\n    между этими порциями страниц.*/\r\n};\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst usersReducer = (state = initialState, action: ActionsType): InitialStateType => { /*Указываем, что тип\r\n\"state\" на выходе имеет тот же тип \"InitialStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case FOLLOW:\r\n            return { /*Меняем флаг у пользователя, что мы его теперь фоллловим.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                users: updateObjectInArray(state.users, action.userID, 'id', {followed: true})\r\n                /*\r\n                Вызываем вспомогательную функцию \"updateObjectInArray\" и передаем ей:\r\n                \"state.users\" - информацию о пользователях для постраничного вывода из \"state\".\r\n                \"action.userID\" - \"ID\" пользователя для фолловинга из объекта \"action\".\r\n                \"'id'\" - имя свойство в объектах, по которому идет проверка сравнением в \"updateObjectInArray\".\r\n                \"{followed: true}\" - объект со свойствами и их значениями, который нужно подменить на место старого\r\n                в найденном объекте.\r\n                В результате получим новый измененным массив объектов с информацией о пользователях для постраничного\r\n                вывода, в котором у одного из пользователей свойство \"followed\" станет \"true\", что будет означать, что\r\n                мы его зафолловили.\r\n                */\r\n            };\r\n\r\n        case UNFOLLOW:\r\n            return { /*Меняем флаг у пользователя, что мы больше его не фоллловим.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                users: updateObjectInArray(state.users, action.userID, 'id', {followed: false})\r\n                /*\r\n                Вызываем вспомогательную функцию \"updateObjectInArray\" и передаем ей:\r\n                \"state.users\" - информацию о пользователях для постраничного вывода из \"state\".\r\n                \"action.userID\" - \"ID\" пользователя для анфолловинга из объекта \"action\".\r\n                \"'id'\" - имя свойство в объектах, по которому идет проверка сравнением в \"updateObjectInArray\".\r\n                \"{followed: false}\" - объект со свойствами и их значениями, который нужно подменить на место старого\r\n                в найденном объекте.\r\n                В результате получим новый измененным массив объектов с информацией о пользователях для постраничного\r\n                вывода, в котором у одного из пользователей свойство \"followed\" станет \"false\", что будет означать, что\r\n                мы его больше не фолловим.\r\n                */\r\n            };\r\n\r\n        case SET_USERS:\r\n            return { /*Добавляем данные о пользователях \"users\" в \"state\", полученные с сервера.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                users: action.users /*Добавляем данные о пользователях \"users\" в \"state\". Здесь мы не добавляем к\r\n                существующим данным новые. Мы затираем старые данные, добавляя новые. Здесь мы не делаем глубокую копию,\r\n                так как работаем с примитивом.*/\r\n            };\r\n\r\n        case SET_CURRENT_PAGE:\r\n            return { /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей в\"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                currentPage: action.currentPage /*Устанавливаем значение текущей выбранной страницы в постраничном\r\n                выводе пользователей. Здесь мы не делаем глубокую копию, так как работаем с примитивом.*/\r\n            };\r\n\r\n        case SET_TOTAL_USERS_COUNT:\r\n            return { /*Устанавливаем общее количество пользователей в\"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                totalUsersCount: action.count /*Устанавливаем общее количество пользователей. Здесь мы не делаем\r\n                глубокую копию, так как работаем с примитивом.*/\r\n            };\r\n\r\n        case TOGGLE_IS_FETCHING:\r\n            return { /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для\r\n            постраничного вывода. Если в процессе, то будет отрисовываться компонент-заглушка \"Preloader\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                isFetching: action.isFetching /*Указываем находится ли в процессе запрос на сервер на получение данных\r\n                по пользователям для постраничного вывода. Здесь мы не делаем глубокую копию, так как работаем\r\n                с примитивом.*/\r\n            };\r\n\r\n        case TOGGLE_IS_FOLLOWING_IN_PROGRESS:\r\n            return { /*Оперируем массивом \"WhoIsInFollowingProgress\" для указания находятся ли или нет какие-либо\r\n            пользователи в процессе анфолловинга/фолловинга.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                WhoIsInFollowingProgress: action.isFollowingInProgress /*Если свойство \"isFollowingInProgress\" (нужен\r\n                только для того, чтобы попасть в первую или вторую строку)*/\r\n                    ? [...state.WhoIsInFollowingProgress, action.userID] /*является \"TRUE\", то делаем глубокую копию и\r\n                    помещаем \"ID\" пользователя, который находится в процессе анфолловинга/фолловинга\r\n                    в массив \"WhoIsInFollowingProgress\",*/\r\n                    : state.WhoIsInFollowingProgress.filter(id => id !== action.userID) /*иначе если является \"FALSE\",\r\n                    то делаем глубокую копию и удаляем \"ID\" этого пользователя из массива \"WhoIsInFollowingProgress\"\r\n                    при помощи метода \"filter()\", который создает новый массив (тем самым мы делаем копию), в который\r\n                    войдут только те элементы, которые не равны \"ID\" указанного пользователя.*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = FollowSuccessActionType | UnfollowSuccessActionType | SetUsersActionType |\r\n    SetCurrentPageActionType | SetTotalUsersCountActionType | ToggleIsFetchingActionType |\r\n    ToggleIsFollowingInProgressActionType; /*Здесь мы все созданные раннее типы для объектов \"action\" объеденили в\r\n    один тип.*/\r\n\r\ntype FollowSuccessActionType = { /*Создали тип для объекта \"action\" \"FOLLOW\" на основе самого \"FOLLOW\" при\r\nпомощи \"typeof\". А свойство \"userID\" в этом объекте \"action\" должно быть числом.*/\r\n    type: typeof FOLLOW\r\n    userID: number\r\n};\r\n\r\ntype UnfollowSuccessActionType = { /*Создали тип для объекта \"action\" \"UNFOLLOW\" на основе самого \"UNFOLLOW\" при\r\nпомощи \"typeof\". А свойство \"userID\" в этом объекте \"action\" должно быть числом.*/\r\n    type: typeof UNFOLLOW\r\n    userID: number\r\n};\r\n\r\ntype SetUsersActionType = { /*Создали тип для объекта \"action\" \"SET_USERS\" на основе самого\r\n\"SET_USERS\" при помощи \"typeof\". А свойство \"users\" в этом объекте \"action\" должно быть типа массива объектов с\r\nтипом \"UserType\", созданного нами и импортированного сюда.*/\r\n    type: typeof SET_USERS\r\n    users: Array<UserType>\r\n};\r\n\r\ntype SetCurrentPageActionType = { /*Создали тип для объекта \"action\" \"SET_CURRENT_PAGE\" на основе самого\r\n\"SET_CURRENT_PAGE\" при помощи \"typeof\". А свойство \"currentPage\" в этом объекте \"action\" должно быть числом.*/\r\n    type: typeof SET_CURRENT_PAGE\r\n    currentPage: number\r\n};\r\n\r\ntype SetTotalUsersCountActionType = { /*Создали тип для объекта \"action\" \"SET_TOTAL_USERS_COUNT\" на основе самого\r\n\"SET_TOTAL_USERS_COUNT\" при помощи \"typeof\". А свойство \"count\" в этом объекте \"action\" должно быть числом.*/\r\n    type: typeof SET_TOTAL_USERS_COUNT\r\n    count: number\r\n};\r\n\r\ntype ToggleIsFetchingActionType = { /*Создали тип для объекта \"action\" \"TOGGLE_IS_FETCHING\" на основе самого\r\n\"TOGGLE_IS_FETCHING\" при помощи \"typeof\". А свойство \"isFetching\" в этом объекте \"action\" должно быть булева типа.*/\r\n    type: typeof TOGGLE_IS_FETCHING\r\n    isFetching: boolean\r\n};\r\n\r\ntype ToggleIsFollowingInProgressActionType = { /*Создали тип для объекта \"action\" \"TOGGLE_IS_FOLLOWING_IN_PROGRESS\" на\r\nоснове самого \"TOGGLE_IS_FOLLOWING_IN_PROGRESS\" при помощи \"typeof\". А свойство \"isFollowingInProgress\" в этом объекте\r\n\"action\" должно быть булева типа, а свойство \"userID\" должно быть числом.*/\r\n    type: typeof TOGGLE_IS_FOLLOWING_IN_PROGRESS\r\n    isFollowingInProgress: boolean\r\n    userID: number\r\n};\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nconst followSuccess = (userID: number): FollowSuccessActionType => ({ /*AC для указания того, что мы зафолловили\r\nпользователя. Объект \"action\" на выходе имеет тип \"FollowSuccessActionType\". На входе получает \"userID\", которое дожно\r\nбыть числом.*/\r\n    type: FOLLOW, /*Обязательно свойство \"type\" для AC.*/\r\n    userID /*Это равносильно \"userID: userID\". \"ID\" пользователя, которого мы фолловим.*/\r\n});\r\n\r\nconst unfollowSuccess = (userID: number): UnfollowSuccessActionType => ({ /*AC для указания того, что мы анфолловили\r\nпользователя. Объект \"action\" на выходе имеет тип \"UnfollowSuccessActionType\". На входе получает \"userID\", которое дожно\r\nбыть числом.*/\r\n    type: UNFOLLOW, /*Обязательно свойство \"type\" для AC.*/\r\n    userID /*Это равносильно \"userID: userID\". \"ID\" пользователя, которого мы анфолловим.*/\r\n});\r\n\r\nconst setUsers = (users: Array<UserType>): SetUsersActionType => ({ /*AC для установки данных пользователей \"users\"\r\nв \"state\", которые получены с сервера. Объект \"action\" на выходе имеет тип \"SetUsersActionType\". На входе получает\r\n\"users\", которое дожно быть массивом с объектами типа \"UserType\", созданного нами и импортированного сюда.*/\r\n    type: SET_USERS, /*Обязательно свойство \"type\" для AC.*/\r\n    users /*Это равносильно \"users: users\". Данные по пользователям для постраничного вывода пользователей,\r\n    полученные с сервера.*/\r\n});\r\n\r\nexport const setCurrentPage = (currentPage: number): SetCurrentPageActionType => ({ /*AC для установки значения текущей\r\nвыбранной страницы в постраничном выводе пользователей в \"state\". Объект \"action\" на выходе имеет\r\nтип \"SetCurrentPageActionType\". На входе получает \"currentPage\", которое дожно быть числом.*/\r\n    type: SET_CURRENT_PAGE, /*Обязательно свойство \"type\" для AC.*/\r\n    currentPage /*Это равносильно \"currentPage: currentPage\". Номер выбранной текущей страницы в постраничном выводе\r\n    пользователей.*/\r\n});\r\n\r\nconst setTotalUsersCount = (totalUsersCount: number): SetTotalUsersCountActionType => ({ /*AC для установки\r\nобщего количество пользователей в \"state\". Объект \"action\" на выходе имеет тип \"SetTotalUsersCountActionType\". На входе\r\nполучает \"totalUsersCount\", которое дожно быть числом.*/\r\n    type: SET_TOTAL_USERS_COUNT, /*Обязательно свойство \"type\" для AC.*/\r\n    count: totalUsersCount /*Значение обозначающее общее количество пользователей.*/\r\n});\r\n\r\nconst toggleIsFetching = (isFetching: boolean): ToggleIsFetchingActionType => ({ /*AC для указания\r\nнаходится ли в процессе запрос на сервер на получение данных по пользователям для постраничного вывода. Если в процессе,\r\nто будет отрисовываться компонент-заглушка \"Preloader\". Объект \"action\" на выходе имеет\r\nтип \"ToggleIsFetchingActionType\". На входе получает \"isFetching\", которое дожно быть булева типа.*/\r\n    type: TOGGLE_IS_FETCHING, /*Обязательно свойство \"type\" для AC.*/\r\n    isFetching /*Это равносильно \"isFetching: isFetching\". Специальное свойство, которое обозначает находится ли\r\n    в процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/\r\n});\r\n\r\nconst toggleIsFollowingInProgress = (isFollowingInProgress: boolean, /*На входе получает \"isFollowingInProgress\",\r\n                                     которое дожно быть булева типа.*/\r\n                                     userID: number /*На входе получает \"userID\", которое дожно быть числом.*/\r\n): ToggleIsFollowingInProgressActionType => ({\r\n/*AC для указания находится ли в процессе анфолловинга/фолловинга какой-либо пользователь. Если в процессе, то кнопка\r\nдля анфолловинга/фолловинга будет отключена. Объект \"action\" на выходе имеет\r\nтип \"ToggleIsFollowingInProgressActionType\".*/\r\n    type: TOGGLE_IS_FOLLOWING_IN_PROGRESS, /*Обязательно свойство \"type\" для AC.*/\r\n    isFollowingInProgress, /*Это равносильно \"isFollowingInProgress: isFollowingInProgress\". Специальное свойство,\r\n    которое указывает находится ли какой-либо пользователь в процессе анфолловинга/фолловинга.*/\r\n    userID /*Это равносильно \"userID: userID\". Специальное свойство, которое указывает \"ID\" пользователя по которому\r\n    идет проверка находится ли он в процессе анфолловинга/фолловинга.*/\r\n});\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype GetStateType = () => AppStateType; /*Создали тип для \"getState()\", который получает \"thunks\" и TC. \"getState()\"\r\nдолжен быть функцией, которая не получает ничего на входе и возвращает объект с типом \"AppStateType\", созданным нами и\r\nимпортированным сюда. Мы это здесь не используем, так как типизация \"thunks\" перекрывает эту типизацию, поскольку\r\nтипизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше,\r\nто есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n\r\ntype DispatchType = Dispatch<ActionsType>; /*Создали тип для \"dispatch\", передается в \"thunks\" и TC. \"dispatch\" должен\r\nбыть \"Dispatch\" из библиотеки \"redux\", работающий с объектами \"action\" тип \"ActionsType\", который мы создали выше.*/\r\n\r\ntype ThunkType = ThunkAction<Promise<void>, AppStateType, unknown, ActionsType> /*Создали тип для \"thunks\". \"thunks\"\r\nдолжны быть объектами \"action\" для \"thunks\" из библиотеки \"redux-thunk\", работающими с:\r\n1) промисами, которые ничего не возвращают (промисы потому, что у нас асинхронные \"thunks\" из-за использования\r\n\"async/await\", хотя обычно \"thunks\" ничего не возвращают);\r\n2) \"state\" с типом \"AppStateType\", созданным нами и импортированным сюда;\r\n3) какими-то неизвестными дополнительными аргументами;\r\n4) объектами \"action\" тип \"ActionsType\", который мы создали выше.\r\nЭти уточнения мы нашли в файле декларации \"ThunkAction\", \"Ctrl+click\" в \"WebStorm\".\r\n*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const requestUsers = (currentPage: number, /*На входе принимает номер текущей выбранной страницы в постраничном\r\n                             выводе пользователей, который должен быть числом.*/\r\n                             pageSize: number /*На входе принимает свойство, которое хранит значение, обозначающее\r\n                             сколько пользователей может максимально выводится на одной странице в постраниченом выводе\r\n                             пользователей, которое должно быть числом.*/\r\n): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных по пользователям в постраничном выводе. Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе\r\nвозвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\",\r\n\"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали,\r\nчто в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n\r\n    dispatch(toggleIsFetching(true)); /*Включаем компонент-заглушку \"Preloader\" перед началом запроса\r\n    на сервер.*/\r\n\r\n    const response = await usersAPI.getUsers(currentPage, pageSize); /*Делаем запрос на сервер для получения данных по\r\n    пользователям для постраничного вывода и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он\r\n    зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически\r\n    вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    dispatch(toggleIsFetching(false)); /*После получения ответа от сервера, отключаем компонент-заглушку\r\n    \"Preloader\".*/\r\n    dispatch(setUsers(response.items)); /*При помощи AC \"setUsers\" устанавливаем данные по пользователям для\r\n    постраничного вывода в \"state\".*/\r\n    dispatch(setTotalUsersCount(response.totalCount)); /*Устанавливаем общее количество пользователей в \"state\".*/\r\n};\r\n\r\n/*Это вспомогательный TC для осуществления анфолловинга/фоллофинга пользователей \"_followUnfollowFlow\". Он вызывается\r\nвнутри TC \"unfollow\" или \"follow\". Для своей работы он принимает следующие параметры: метод \"dispatch\" (обязателен для\r\n\"thunk\", \"store\" из \"redux\" его сам закинет), \"ID\" пользователя для анфолловинга/фолловинга, запрос на сервер для\r\nанфолловинга/фолловинга, AC для анфолловинга/фолловинга. Эти параметры он получает от TC \"unfollow\" или \"follow\".\r\nЗдесь вместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC\r\nасинхронным.*/\r\nconst _followUnfollowFlow = async (dispatch: DispatchType, /*На входе принимает \"dispatch\", который должен быть типа\r\n                                   \"DispatchType\", который мы создали выше.*/\r\n                                   id: number, /*На входе принимает \"ID\" пользователя, которого мы фолловим/анфолловим,\r\n                                   которое должно быть числом.*/\r\n                                   apiMethod: any, /*На входе принимает метод API, которое типа \"any\", так как пока\r\n                                   мы не знаем какого типо он будет.*/\r\n                                   actionCreator: (id: number) => FollowSuccessActionType | UnfollowSuccessActionType\r\n                                   /*На входе принимает AC, который должен быть функцией, которая на входе принимает\r\n                                   числовой параметр, а на выходе возвращает объекты \"action\" либо с типом\r\n                                   \"FollowSuccessActionType\", либо с типом \"UnfollowSuccessActionType\", оба эти типа\r\n                                   были созданы нами выше.*/\r\n) => {\r\n\r\n    dispatch(toggleIsFollowingInProgress(true, id)); /*Указываем, что анфолловим/фолловим какого-то\r\n    пользователя.*/\r\n\r\n    const response = await apiMethod(id); /*Делаем запрос на сервер на анфолловинг/фолловинг и ждем ответа от сервера.\r\n    Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как\r\n    асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === 0) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\" (т.е. операция\r\n    прошла успешно), то диспатчим AC на анфолловинг/фолловинг, передав в этот AC \"ID\" пользователя, которого\r\n    анфолловим/фолловим.*/\r\n        dispatch(actionCreator(id))\r\n    }\r\n\r\n    dispatch(toggleIsFollowingInProgress(false, id)); /*Указываем, что больше не анфолловим/фолловим\r\n    какого-то пользователя.*/\r\n}\r\n\r\n/*Далее идут два основных TC для осуществления анфолловинга/фоллофинга пользователей \"unfollow\" и \"follow\". Все, что они\r\nделают это вызывают вспомогательный TC для осуществления анфолловинга/фоллофинга пользователей \"_followUnfollowFlow\" и\r\nпередают ему ряд параметров для его работы: метод \"dispatch\" (обязателен для \"thunk\", \"store\" из \"redux\" его сам\r\nзакинет), \"ID\" пользователя для анфолловинга/фолловинга, запрос на сервер для анфолловинга/фолловинга, AC для\r\nанфолловинга/фолловинга. Здесь вместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться\r\nв \"await\". \"async\" делает TC асинхронным.*/\r\nexport const unfollow = (id: number): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления анфолловинга какого-либо пользователя. На входе принимает \"ID\" пользователя, которого мы\r\nанфолловим, которое должно быть числом. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный\r\nнами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что\r\nвозвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    _followUnfollowFlow(dispatch, id, usersAPI.unfollow.bind(usersAPI), unfollowSuccess); /*Так как мы берем метод у\r\n    объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли этот метод какие-нибудь\r\n    свойства с \"this\" и т.д., поэтому мы используем здесь \"bind()\", чтобы не потерять контекст \"this\". Но вроде и без\r\n    этого должно работать.*/\r\n};\r\n\r\nexport const follow = (id: number): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления фолловинга какого-либо пользователя. На входе принимает \"ID\" пользователя, которого мы\r\nфолловим, которое должно быть числом. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный\r\nнами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что\r\nвозвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    _followUnfollowFlow(dispatch, id, usersAPI.follow.bind(usersAPI), followSuccess); /*Так как мы берем метод у\r\n    объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли этот метод какие-нибудь\r\n    свойства с \"this\" и т.д., поэтому мы используем здесь \"bind()\", чтобы не потерять контекст \"this\". Но вроде и без\r\n    этого должно работать.*/\r\n};\r\n\r\n\r\nexport default usersReducer; /*Экспортируем \"usersReducer\" по default, экспорт необходим для импорта.*/","/*\r\nЭто специальный файл, содержащий логику для высчитывания и отображения текущей страницы в постраничном\r\nвыводе пользователей. Но этот файл можно использовать по идее и для постраничного вывода любых других элементов.\r\n*/\r\n\r\nimport React, {useState} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\n*/\r\n\r\nimport styles from './Paginator.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport cn from 'classnames';\r\n/*\r\n\"classnames\" - это библиотека для простого условного объединения имен классов .Для этого мы здесь используем\r\nфункцию \"cn\" из этой библиотеки.\r\nКак можно добавить два класса:\r\nclassName = {styles.first + ' ' + styles.second} (без библиотеки \"classnames\")\r\nclassName = {`${styles.first} ${styles.second}`} (без библиотеки \"classnames\")\r\nclassName = {cn(styles.second, styles.first)} (с библиотекой \"classnames\")\r\nТакже при использовании этой библиотеки можно добавлять условия:\r\nclassName = {cn(\r\n                styles.first,\r\n                {[styles.second] : true}\r\n                )\r\n            };\r\n*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    totalItemsCount: number /*Общее количество элементов для постраничного вывода должно быть числом.*/\r\n    pageSize: number /*Максимальное количество элементов на одной странице в постраничном выводе должно быть числом.*/\r\n    currentPage: number /*Текущая выбранная страница в постраничном выводе должна быть числом.*/\r\n    onPageChange: (p: number) => void /*Метод для обновления данных при смене текущей выбранной страницы в постраничном\r\n    выводе должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    portionSize?: number /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном\r\n    выводе может отображаться в одной порции таких страниц, должно быть числом. Не является обязательным.*/\r\n};\r\n\r\n/*\r\n\"Paginator\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Paginator(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Paginator\" является компонентом, который способен создавать постраничный вывод элементов.\r\nВ нашем приложении он используется для постраничного вывода пользователей.\r\nЭтот компонент подключается в компоненте \"Users\".\r\n*/\r\nconst Paginator: React.FC<PropsType> = ({ /*Указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n\"props.totalItemsCount\", \"props.pageSize\" и так далее. Такое мы делаем только в функциональных компонентах. Указали при\r\nпомощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n                                        totalItemsCount, /*Общее количество элементов для постраничного\r\n                                        вывода.*/\r\n                                        pageSize, /*Максимальное количество элементов на одной странице в\r\n                                        постраничном выводе.*/\r\n                                        currentPage, /*Текущая выбранная страница в постраничном выводе.*/\r\n                                        onPageChange, /*Метод для обновления данных при смене текущей выбранной страницы\r\n                                        в постраничном выводе.*/\r\n                                        portionSize = 10 /*Свойство, которое указывает какое\r\n                                        максимальное количество номеров страниц в постраничном выводе может отображаться\r\n                                        в одной порции таких страниц. Это сделано, чтобы не выводились все номера\r\n                                        страниц, коих огромное количество, а имелась возможность\r\n                                        выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться\r\n                                        между этими порциями страниц. Если значение этого свойства не будет указано, то\r\n                                        по умолчанию оно будет равно 10.*/\r\n                                    }) => {\r\n\r\n    let pagesCount = Math.ceil(totalItemsCount / pageSize); /*Высчитываем сколько страниц пользователей нам\r\n    нужно (делим общее количество элементов на максимальное количество элементов на одной странице) и помещаем\r\n    результат в переменную \"pagesCount\". Метод \"Math.ceil\" округляет в большую сторону.*/\r\n\r\n    let pages: Array<number> = []; /*Создаем массив, который будет содержать такое количество элементов\r\n    (например, 1,2,3 и т.д., т.е. номера страниц), которое будет равно количеству страниц в постраничном выводе\r\n    пользователей \"pagesCount\". Далее мы будем мапить этот массив, чтобы вывести список номеров страниц для\r\n    навигации по постраничному выводу элементов. Этот массив имеет тип массива чисел.*/\r\n\r\n    for (let i = 1; i <= pagesCount; i++) { /*Заполняем массив \"pages\" путем перебора \"pagesCount\".*/\r\n        pages.push(i); /*При помощи метода \"push()\" добавляем в конец массива \"pages\" каждый \"i\".*/\r\n    }\r\n\r\n    /*\r\n    \"portionCount\" - how many portions of pages we have. Количество порций страниц, которое мы имеем.\r\n\r\n    \"portionSize\" - how many pages in a portion, you can get it from state. Максимальное количество страниц в одной\r\n    порции. Мы это берем из \"state\".\r\n\r\n    \"lowerLimitOfCurrentPortion\" - the number of the page which is a lower bound of the current portion of pages. Номер\r\n    страницы, который является нижней границей текущей порции страниц.\r\n\r\n    \"upperLimitOfCurrentPortion\" - the number of the page which is an upper bound of the current portion of pages. Номер\r\n    страницы, который является верхней границей текущей порции страниц.\r\n\r\n    \"currentPortionNumber\" - the number of the current portion of pages, used in \"useState\". Номер текущей порции\r\n    страниц, используется в хуке \"useState\".\r\n\r\n    \"setCurrentPortionNumber\" - a function that can change the number of the current portion of pages, used in\r\n    \"useState\". Функция, которая может менять номер текущей порции страниц, используется в хуке \"useState\".\r\n\r\n    \"useState\" - a hook from \"ReactJS\". Хук из \"ReactJS\".\r\n    */\r\n\r\n    let portionCount = Math.ceil(pagesCount / portionSize); /*Вычисляем количество порций страниц, путем деления\r\n    количества всех страниц с пользователями на максимальное количество страниц в одной порции. Метод \"Math.ceil\"\r\n    округляет в большую сторону.*/\r\n    let [currentPortionNumber, setCurrentPortionNumber] = useState(1); /*При помощи деструктуризирующего\r\n    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент\r\n    будет означать номер текущей порции страниц (изначально \"1\"). Вторая переменная будет хранить функцию из хука\r\n    \"useState\", которая будет изменять первый элемент (то есть менять номер текущей порции страниц).*/\r\n    let lowerBoundOfCurrentPortion = (currentPortionNumber - 1) * portionSize + 1; /*Высчитываем номер страницы, который\r\n    является нижней границей текущей порции страниц. Изначально это будет \"(1 - 1) + 1 = 1\".*/\r\n    let upperBoundOfCurrentPortion = currentPortionNumber * portionSize; /*Высчитываем номер страницы, который является\r\n    верхней границей текущей порции страниц. Изначально это будет \"1 * 20 = 20\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.paginator}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n\r\n            {currentPortionNumber > 1 && /*Если текущий номер порции страниц больше 1,*/\r\n            <button onClick={() => { /*то отрисовываем элемент \"button\", при нажатии на который будет уменьшаться\r\n            текущий номер порции страниц на 1, то есть мы будем переходить назад на предыдущую порцию страниц (например,\r\n            с \"от 21 до 40\" до  \"1 до 20\"). Соотвественно изначально это кнопка не отрисовывается, так как мы\r\n            по дефолтку находимся на 1-ой порции страниц.*/\r\n                setCurrentPortionNumber(currentPortionNumber - 1)\r\n            }}>\r\n                PREV {/*Текст кнопки \"предыдущая порция страниц\".*/}\r\n            </button>}\r\n\r\n            {pages\r\n                .filter(p => p >= lowerBoundOfCurrentPortion && p <= upperBoundOfCurrentPortion) /*Из массива \"pages\"\r\n                берем только те номера страниц, которые больше или равны нижней границе текущей порции страниц и\r\n                меньше или равны верхней границе текущей порции страниц.*/\r\n                .map(p => { /*Далее мапим отфильтрованный массив \"pages\".*/\r\n                    return ( /*Здесь возвращаем JSX в виде \"span\" элементов. Количество этих \"span\" элементов будет\r\n                    равно количеству элементов в массиве \"pages\". Это будет список номеров страниц для навигации в\r\n                    постраничном выводе пользователей.*/\r\n                        <span className={cn({[styles.selectedPage]: currentPage === p}, styles.pageNumber)}\r\n                        /*Будет применяться особый стиль к странице \"p\", номер которой равен номеру текущей выбранной\r\n                        страницы в постраничном выводе из \"state\", благодаря использованию функции \"cn\".*/\r\n                              key={p} /*При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания\r\n                              ошибок.*/\r\n                              onClick={(e) => { /*Это анонимная функция, которая будет\r\n                              вызываться при событии нажатия на элемент.*/\r\n                                  onPageChange(p) /*Эта анонимная функция будет вызывать наш метод \"onPageChange\" и\r\n                                  передавать в него номер страницы, на которую мы нажали. В результате мы изменим\r\n                                  текущую выбранную страницу в постраничном выводе в \"state\".*/\r\n                              }}>\r\n                            {p} {/*Выводим текст самого номера страницы в элементе \"span\".*/}\r\n                        </span>\r\n                    )\r\n                })\r\n            }\r\n\r\n            {portionCount > currentPortionNumber && /*Если количество порций страниц, которое мы имеем, больше текущего\r\n            номера порции страниц,*/\r\n            <button onClick={() => { /*то отрисовываем элемент \"button\", при нажатии на который будет увеличиваться\r\n            текущий номер порции страниц на 1, то есть мы будем переходить вперед на следующуюю порцию страниц\r\n            (например, с \"от 1 до 20\" до  \"21 до 40\"). Соотвественно на последнее порции страниц это кнопка\r\n            не отрисовывается, так текущая порция страниц, которая является последней порцией страниц, равна\r\n            максимальному количеству порций страниц.*/\r\n                setCurrentPortionNumber(currentPortionNumber + 1)\r\n            }}>\r\n                NEXT {/*Текст кнопки \"следующая порция страниц\".*/}\r\n            </button>}\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Paginator; /*Экспортируем компонент \"Paginator\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './User.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport userPhoto from '../../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя,\r\nна случай если у пользователя нет фото.*/\r\n\r\n\r\n/*\r\n\"User\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function User(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Users\" является компонентом, который описывает, как должны выглядеть блоки с информацией о пользователе на странице\r\nс постраничным выводом пользователей.\r\nЭтот компонент подключается в компоненте \"Users\".\r\n*/\r\nconst User = ({/*Указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.user\",\r\n\"props.WhoIsInFollowingProgress\" и так далее. Такое мы делаем только в функциональных компонентах.*/\r\n                  user, /*Объект с данным по пользователю.*/\r\n                  WhoIsInFollowingProgress, /*Специальное свойство, которое содержит массив, который будет хранить\r\n                  \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе\r\n                  анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга\r\n                  от пользователя.*/\r\n                  unfollow, /*TC для анфолловинга пользователей.*/\r\n                  follow /*TC для фолловинга пользователей.*/\r\n}) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <span>\r\n                <div> {/*Это отдельный элемент \"div\" для отображения фото пользователя в виде элемента \"NavLink\" для\r\n                перехода на профиль пользователя.*/}\r\n                    <NavLink to={'/profile/' + user.id}> {/*Создаем маршрут для пути перехода на страницу выбранного\r\n                    пользователя. Отрисуется компонент \"Profile\".*/}\r\n                        <img src={user.photos.small != null ? user.photos.small : userPhoto}\r\n                             alt='' className={styles.userPhoto}/> {/*Отображаем фото пользователя, если его нет, то\r\n                             подгружаем дефолтный аватар из проекта приложения.*/}\r\n                    </NavLink>\r\n                </div>\r\n\r\n                <div> {/*Это отдельный элемент \"div\" для кнопок с функционалом \"Follow/Unfollow\".*/}\r\n                    {user.followed /*Если значение \"followed\" (свойство, которое говорит фолловим ли мы уже\r\n                    пользователя или нет, это свойство меняется в \"usersReducer\") у пользователя*/\r\n                        ? <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)} /*является \"TRUE\", то\r\n                        отображаем элемент кнопки (причем кнопка будет отключена, если на нее нажали и происходит\r\n                        процесс анфолловинга пользователя, то есть мы берем массив \"WhoIsInFollowingProgress\" и вызываем\r\n                        для него метод \"some()\", который вернет \"TRUE\" если в указанном массиве есть \"ID\" пользователя\r\n                        равное \"ID\" пользователя, указанного при создании отдельного экземпляра компонента \"User\"\r\n                        в результате маппинга)*/\r\n                                  onClick={() => { /*и если нажать на кнопку, то*/\r\n                                      unfollow(user.id); /*сработает TC \"unfollow\", чтобы заанфолловить пользователя,*/\r\n                                  }}>Unfollow</button> /*и отображаем текст \"Unfollow\" на кнопке.*/\r\n\r\n                        : <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)} /*является \"FALSE\", то\r\n                        отображаем элемент кнопки (причем кнопка будет отключена, если на нее нажали и происходит\r\n                        процесс фолловинга пользователя, то есть мы берем массив \"WhoIsInFollowingProgress\" и вызываем\r\n                        для него метод \"some()\", который вернет \"TRUE\" если в указанном массиве есть \"ID\" пользователя\r\n                        равное \"ID\" пользователя, указанного при создании отдельного экземпляра компонента \"User\"\r\n                        в результате маппинга)*/\r\n                                  onClick={() => { /*и если нажать на кнопку, то*/\r\n                                      follow(user.id); /*сработает TC \"follow\", чтобы зафолловить пользователя.*/\r\n                                  }}>Follow</button> /*и отображаем текст \"Follow\" на кнопке.*/\r\n                    }\r\n                </div>\r\n            </span>\r\n\r\n            <span> {/*Это отдельный элемент \"span\" для отображения информации с id, именем и статусом пользователя.\r\n            А также имеется заглушка для страны и города пользователя, так как на данный момент на сервере такой\r\n            информации нет.*/}\r\n                <span> {/*Это отдельный элемент \"span\" для отображения информации с id, именем и статусом\r\n                пользователя.*/}\r\n                    <div>{user.id}</div> {/*Этот элемент \"div\" отображает \"ID\" пользователя.*/}\r\n                    <div>{user.name}</div> {/*Этот элемент \"div\" отображает имя пользователя.*/}\r\n                    <div>{user.status}</div> {/*Этот элемент \"div\" отображает статус пользователя.*/}\r\n                </span>\r\n                <span> {/*Это отдельный элемент \"span\" для отображения заглушки для страны и города пользователя.*/}\r\n                    <div>{\"user.location.country\"}</div> {/*Этот элемент \"div\" отображает заглушку для страны\r\n                    пользователя.*/}\r\n                    <div>{\"user.location.city\"}</div> {/*Этот элемент \"div\" отображает заглушку для города\r\n                    пользователя.*/}\r\n                </span>\r\n            </span>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default User; /*Экспортируем компонент \"User\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport Paginator from '../common/Paginator/Paginator'; /*Подключаем компонент \"Paginator\".*/\r\nimport User from './User'; /*Подключаем компонент \"User\".*/\r\n\r\nimport {UserType} from '../../types/types'; /*Импортируем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    totalUsersCount: number /*Общее количество пользователей должно быть числом.*/\r\n    pageSize: number /*Максимальное количество пользователей на одной странице в постраничном выводе должно быть\r\n    числом.*/\r\n    currentPage: number /*Номер текущей выбранной страницы в постраничном выводе должен быть числом.*/\r\n    onPageChange: (p: number) => void /*Метод для обновления данных при смене текущей выбранной страницы в постраничном\r\n    выводе должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    portionSize: number /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном\r\n    выводе может отображаться в одной порции таких страниц, должно быть числом.*/\r\n    users: Array<UserType> /*Данные по пользователям для постраничного вывода должны быть в виде массива элементов с\r\n    типом \"UserType\", который был создан нами и импортирован сюда.*/\r\n    WhoIsInFollowingProgress: Array<number> /*Специальное свойство, которое содержит массив, который будет хранить \"ID\"\r\n    пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним\r\n    отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя, должно быть массивом чисел.*/\r\n    unfollow: (id: number) => void /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой\r\n    параметр и ничего не возвращает.*/\r\n    follow: (id: number) => void /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой\r\n    параметр и ничего не возвращает.*/\r\n};\r\n\r\n/*\r\n\"Users\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Users(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Users\" является компонентом, который отображает страницу с постраничным выводом пользователей.\r\nЭтот компонент подключается в компоненте \"UsersContainer\".\r\nВнутри компонента \"Users\" подключаются компоненты:\r\n- \"User\", который описывает, как должны выглядеть блоки с информацией о пользователе на странице с постраничным\r\nвыводом пользователей;\r\n- \"Paginator\", который осуществляет функционал постраничного вывода информации.\r\n*/\r\nconst Users: React.FC<PropsType> = ({/*Указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n\"props.users\". Остальные \"props\" передаем при помощи деструктуризации. Такое мы делаем только в функциональных\r\nкомпонентах. Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n                                        users,\r\n                                        ...props\r\n}) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {/*Далее отрисовываем компонент \"Users\" и передаем ему через \"props\" необходимы для него данные.*/}\r\n            <Paginator totalItemsCount={props.totalUsersCount} /*Общее количество пользователей. Переименовали\r\n                       в \"totalItemsCount\", так как компонент \"Paginator\" может использоваться для постраничного вывода\r\n                       любых элементов, не только пользователей.*/\r\n                       pageSize={props.pageSize} /*максимальное количество пользователей на одной странице\r\n                       в постраничном выводе.*/\r\n                       currentPage={props.currentPage} /*Номер текущей выбранной страницы в постраничном выводе.*/\r\n                       onPageChange={props.onPageChange} /*Метод \"onPageChange\" для обновления данных при смене текущей\r\n                       выбранной страницы в постраничном выводе.*/\r\n                       portionSize={props.portionSize} /*Свойство, которое указывает какое максимальное количество\r\n                       номеров страниц в постраничном выводе может отображаться в одной порции таких страниц. Это\r\n                       сделано, чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность\r\n                       выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими\r\n                       порциями страниц.*/\r\n            />\r\n\r\n            <div>\r\n                {/*\r\n                В JSX в массив можно вкладывать компоненты.\r\n                В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде\r\n                строки.\r\n                \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования\r\n                исходного массива.\r\n                Метод \"map\" принимает стрелочную функцию.\r\n                То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n                и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n                будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n                Потом будет браться следующий объект из исходного массива объектов\r\n                и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n                будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n                И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n                То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов\r\n                в изначальном массиве объектов.\r\n                В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n                Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n                В этом элементе <div> будут выводится компоненты \"User\", отображающие информацию о каждом пользователе\r\n                в постраничном выводе пользователей.\r\n                При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n                */}\r\n                {users.map(u => <User key={u.id}\r\n                                      user={u} /*Объект с данным по пользователю.*/\r\n                                      WhoIsInFollowingProgress={props.WhoIsInFollowingProgress} /*Специальное свойство,\r\n                                      которое содержит массив, который будет хранить \"ID\" пользователей, которые\r\n                                      в какой-то определенный момент находятся в процессе анфолловинга/фолловинга,\r\n                                      то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга\r\n                                      от пользователя.*/\r\n                                      unfollow={props.unfollow} /*TC для анфолловинга пользователей.*/\r\n                                      follow={props.follow} /*TC для фолловинга пользователей.*/\r\n                />)}\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Users; /*Экспортируем компонент \"Users\" по default, экспорт необходим для импорта.*/","/*\r\nСелектор - это функция, которая принимает \"state\", достает из него то, что ей нужно и возвращает это в BLL.\r\nСелекторы осуществляют определенную выборку данных из \"state\".\r\nЗдесь содержаться селекторы для компонента \"UsersContainer\".\r\n*/\r\n\r\nimport {createSelector} from 'reselect';\r\n/*\r\n\"mapStateToProps\" в методе \"connect\" срабатывает каждый раз, когда что-то меняется в \"state\". Если мы будем использовать\r\nсложные селекторы с дополнительной внутренней логикой, то такие селекторы будут вызывать большую нагрузку и заставлять\r\nчасто перерисовывать приложение. Также такие селекторы сложно дебажить. Чтобы избежать этих проблем мы используем\r\nбиблиотеку \"reselect\". Эта библиотека помогает нам не перезапускать наши сложные селекторы, если в этом нет\r\nнеобходимости. Наш селектор после запуска не только должен отправить что-то в \"mapStateToProps\", но и сохранить это\r\nчто-то в отдельном месте, чтобы в следующий вызов этого селектора он не срабатывал снова, а просто возвращалось это\r\nсохраненное что-то, если оно не было изменено, то есть мы должны указывать от чего зависит наш селектор.\r\nИмпортируем \"createSelector\" из библиотеки \"reselect\", чтобы создавать наши селекторы. \"createSelector\" - это\r\nспециальная функция, которая возвращает селектор, а внутри она получает функцию, описывающую логику селектора. Для того,\r\nчтобы передать \"state\" в \"createSelector\" нам нужно создать примитивный селектор, получающий \"state\". Можно создавать\r\nсложные селекторы на основе нескольких примитивных селекторов или на основе нескольких примитивных и сложных селекторов.\r\n*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Импортируем типы.*/\r\n\r\n\r\n/*Селекторы для компонента \"UsersContainer\".*/\r\nconst getUsersPrimitive = (state: AppStateType) => { /*Создали примитивный селектор, получающий \"users\" из \"state\".\r\nНа входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.usersPage.users\r\n};\r\n\r\nexport const getUsers = createSelector (getUsersPrimitive, (users) => { /*Создали сложный селектор\r\nна основе примитивного селектора \"getUsersPrimitive\". Можно указать несколько таких селекторов через запятую. Этот\r\nпримитивный селектор будет создавать \"(users)\" - данные по пользователям. Внутри этого сложного логика просто передается\r\nвесь \"users\" как есть. Если бы мы указали, например два селектора вместо одного, то и помимо \"users\" нужно было бы\r\nуказать еще что-то. Этот селектор возвращает данные по пользователям для постраничного вывода.*/\r\n    return users.filter(u => true)\r\n});\r\n\r\n\r\nexport const getPageSize = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор.\r\nОн возвращает максимальное количество пользователей, которое выводится в постраничном выводе пользователей. На входе\r\nэтот селектор принимает \"state\" с типом \"AppStateType\", который мы создали и имопртировали сюда.*/\r\n    return state.usersPage.pageSize\r\n};\r\n\r\nexport const getPortionSize = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор.\r\nОн возвращает свойство, которое указывает какое количество номеров страниц в постраничном выводе может отображаться\r\nв одной порции таких страниц. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы создали и\r\nимпортировали сюда.*/\r\n    return state.usersPage.portionSize\r\n};\r\n\r\nexport const getTotalUsersCount = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор.\r\nОн возвращает общее количество пользователей. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который\r\nмы создали и импортировали сюда.*/\r\n    return state.usersPage.totalUsersCount\r\n};\r\n\r\nexport const getCurrentPage = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор.\r\nОн возвращает текущий номер выбранной страницы в постраничном выводе пользователей. На входе этот селектор принимает\r\n\"state\" с типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.usersPage.currentPage\r\n};\r\n\r\nexport const getIsFetching = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор.\r\nОн возвращает специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение данных по\r\nпользователям для постраничного вывода. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы\r\nсоздали и имопртировали сюда.*/\r\n    return state.usersPage.isFetching\r\n};\r\n\r\nexport const getWhoIsInFollowingProgress = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\"\r\nселектор. Он возвращает специальное свойство, которое содержит массив, который будет хранить \"ID\" пользователей, которые\r\nв какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы\r\nдля анфолловинга/фолловинга от пользователя. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который\r\nмы создали и импортировали сюда.*/\r\n    return state.usersPage.WhoIsInFollowingProgress\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {compose} from 'redux';\r\n/*\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и ХОКи.\r\nОбвертки и ХОКи указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\n*/\r\n\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC \"withAuthRedirect\" для\r\nдобавления редиректа. В данный момент не используется.*/\r\n\r\nimport {\r\n    setCurrentPage, /*Подключаем AC \"setCurrentPage\" из \"users-reducer\".*/\r\n    requestUsers, /*Подключаем TC \"requestUsers\" из \"users-reducer\".*/\r\n    follow, /*Подключаем TC \"follow\" из \"users-reducer\".*/\r\n    unfollow /*Подключаем TC \"unfollow\" из \"users-reducer\".*/\r\n} from '../../redux/users-reducer';\r\n\r\nimport Users from './Users'; /*Подключаем компонент \"Profile\".*/\r\nimport Preloader from '../common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\r\n\r\nimport {\r\n    getCurrentPage, /*Импортируем селектор, который возвращает общее количество пользователей.*/\r\n    getIsFetching, /*Импортируем селектор, который возвращает специальное свойство, которое обозначает находится ли в\r\n    процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/\r\n    getPageSize, /*Импортируем селектор, который возвращает максимальное количество пользователей, которое выводится в\r\n    постраничном выводе пользователей.*/\r\n    getTotalUsersCount, /*Импортируем селектор, который возвращает общее количество пользователей.*/\r\n    getWhoIsInFollowingProgress, /*Импортируем селектор, который возвращает специальное свойство, которое содержит\r\n    массив, который будет хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе\r\n    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\n    getUsers, /*Импортируем селектор, который возвращает данные по пользователям для постраничного вывода.*/\r\n    getPortionSize /*Импортируем селектор, который возвращает свойство, которое указывает какое количество номеров\r\n    страниц в постраничном выводе может отображаться в одной порции таких страниц.*/\r\n} from '../../redux/users-selectors'; /*Импортируем селекторы для компонента \"UsersContainer\".*/\r\n\r\nimport {UserType} from '../../types/types'; /*Импортируем типы.*/\r\nimport {AppStateType} from '../../redux/redux-store'; /*Импортируем типы.*/\r\n\r\n\r\n/*Создаем тип для \"MapStateToProps\". \"MapStateToProps\" в этом компоненте должен обязательно содержать следующие поля с\r\nуказанными типами.*/\r\ntype MapStateToPropsType = {\r\n    currentPage: number /*Номер текущей выбранной страницы в постраничном выводе должен быть числом.*/\r\n    pageSize: number /*Максимальное количество пользователей на одной странице в постраничном выводе должно быть\r\n    числом.*/\r\n    isFetching: boolean /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение\r\n    данных по пользователям для постраничного вывода (если в процессе, то будет отрисовываться компонент-заглушка\r\n    \"Preloader\"), должно быть булева типа.*/\r\n    totalUsersCount: number /*Общее количество пользователей должно быть числом.*/\r\n    users: Array<UserType> /*Данные по пользователям для постраничного вывода должны быть в виде массива элементов с\r\n    типом \"UserType\", который был создан нами и импортирован сюда.*/\r\n    portionSize: number /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном\r\n    выводе может отображаться в одной порции таких страниц, должно быть числом.*/\r\n    WhoIsInFollowingProgress: Array<number> /*Специальное свойство, которое содержит массив, который будет хранить \"ID\"\r\n    пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним\r\n    отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя, должно быть массивом чисел.*/\r\n};\r\n\r\n/*Создаем тип для \"MapDispatchToProps\". \"MapDispatchToProps\" в этом компоненте должен обязательно содержать следующие\r\nполя с указанными типами.*/\r\ntype MapDispatchToPropsType = {\r\n    requestUsers: (currentPage: number, pageSize: number) => void /*TC для запроса и установки данных по пользователям\r\n    в постраничном выводе должно быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    setCurrentPage: (pageNumber: number) => void /*AC для установки значения текущей выбранной страницы в постраничном\r\n    выводе пользователей в \"state\" должно быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    unfollow: (id: number) => void /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой\r\n    параметр и ничего не возвращает.*/\r\n    follow: (id: number) => void /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой\r\n    параметр и ничего не возвращает.*/\r\n};\r\n\r\n/*Создаем тип для \"собственных props\" (для учебных целей в рамках изучения типов для \"props\" свойство\"pageTitle\"\r\nпередали сюда в \"App.js\"). \"Собственные props\" в этом компоненте должны обязательно содержать следующие поля с\r\nуказанными типами.*/\r\ntype OwnPropsType = {\r\n    pageTitle: string /*Свойство \"pageTitle\" должно быть строкой.*/\r\n};\r\n\r\n/*Создаем общий тип для всех \"props\" путем комбинации трех созданные выше типов. Все это нужно для указания типа\r\n\"props\" в классовом компоненте.*/\r\ntype PropsType = MapStateToPropsType & MapDispatchToPropsType & OwnPropsType;\r\n\r\n/*\r\n\"UsersContainer\" это классовый компонент.\r\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\r\nконцепцию ООП.\r\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\r\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\r\nвзаимодействует.\r\nНапример, у него можно постоянно запрашивать JSX.\r\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\r\nКомпонент это функция, которая возвращает JSX.\r\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\r\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\r\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"UsersContainer\" является контейнерным компонентом для компонента \"Users\".\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.js\") из библиотеки \"react-redux\".\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nclass UsersContainer extends React.Component<PropsType/*, StateType*/> { /*Указали, что \"props\" в этом классовом\r\nкомпоненте имеют тип \"PropsType\". Еще здесь можно указать тип \"state\", но мы не указали.*/\r\n    componentDidMount() {/*Это метод жизненного цикла классового компонента. Он вызывается в момент первой\r\n    отрисовки (монтирования) компонента.*/\r\n        const {currentPage, pageSize} = this.props; /*Создаем две константы \"currentPage\" (текущая выбранная страница\r\n        в постраничном выводе) и \"pageSize\" (максимальное количество пользователей на одной странице в постраничном\r\n        выводе), и передаем в них значения из \"props\", эти значения подхватяться из-за совпадения имен. В классовом\r\n        компоненте порой лучше сделать деструктуризацию параметров из \"props\", так как возможно могут быть какие-то\r\n        проблемы с лишней перерисовкой. \"{}\" здесь обозначают деструктуризацию.*/\r\n        this.props.requestUsers(currentPage, pageSize); /*Вызываем TC \"requestUsers\" для запроса и установки данных\r\n        по пользователям в постраничном выводе, передав значение текущей выбранной страницы и максимальное количество\r\n        пользователей на одной странице в постраничном выводе.*/\r\n    };\r\n\r\n    onPageChange = (pageNumber: number) => { /*Создали специальный метод, который будет вызываеться при смене страницы\r\n    в постраничном выводе пользователей, принимает номер новой текущей выбранной страницы.*/\r\n        const {pageSize} = this.props; /*Создаем константу \"pageSize\" (количество пользователей на одной странице\r\n        в постраничном выводе), и передаем в нее значение из \"props\", это значение подхватится из-за совпадения имен.\r\n        В классовом компоненте порой лучше сделать деструктуризацию параметров из \"props\", так как возможно могут быть\r\n        какие-то проблемы с лишней перерисовкой. \"{}\" здесь обозначают деструктуризацию.*/\r\n        this.props.setCurrentPage(pageNumber); /*Вызываем AC \"setCurrentPage\" для установки значения текущей выбранной\r\n        страницы в постраничном выводе пользователей в \"state\", передав номер новой текущей выбранной страницы.*/\r\n        this.props.requestUsers(pageNumber, pageSize); /*Вызывае TC \"requestUsers\" для запроса и установки данных\r\n        по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы и максимальное\r\n        количество пользователей на одной странице в постраничном выводе.*/\r\n    };\r\n\r\n    render() {\r\n        /*\r\n        Здесь после return в компоненте начинается HTML разметка.\r\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n        */\r\n        return <> {/*Этот пустой элемент и есть наш корневой элемент.*/}\r\n            <h2>{this.props.pageTitle}</h2> {/*Для учебных целей в рамках изучения типов для \"props\" выводим значение\r\n            свойства \"pageTitle\" в элементе \"h2\"*/}\r\n\r\n            {this.props.isFetching ? <Preloader/> : null} {/*Если в \"state\" значение \"isFetching\" является \"true\",\r\n            то показываем компонент \"Preloader\". Этот элемент \"Preloader\" и будет нашим корневым элементом.\r\n            Если же компонент \"Preloader\" не отрисовывается, то далее отрисовываем компонент \"Users\" и передаем ему\r\n            через \"props\" необходимые для него данные. Этот элемент \"Users\" и будет нашим корневым элементом.*/}\r\n            <Users totalUsersCount={this.props.totalUsersCount} /*Общее количество пользователей. Далее передается\r\n                   в компонент \"Paginator\".*/\r\n                   pageSize={this.props.pageSize} /*Максимальное количество пользователей на одной странице в\r\n                   постраничном выводе. Далее передается в компонент \"Paginator\".*/\r\n                   currentPage={this.props.currentPage} /*Номер текущей выбранной страницы в постраничном выводе. Далее\r\n                   передается в компонент \"Paginator\".*/\r\n                   onPageChange={this.onPageChange} /*Метод \"onPageChange\" для обновления данных при смене текущей\r\n                   выбранной страницы в постраничном выводе. Далее передается в компонент \"Paginator\".*/\r\n                   users={this.props.users} /*Данные по пользователям для постраничного вывода. Далее мапиться для\r\n                   отрисовки компонентов \"User\".*/\r\n                   WhoIsInFollowingProgress={this.props.WhoIsInFollowingProgress} /*Специальное свойство, которое\r\n                   содержит массив, который будет хранить \"ID\" пользователей, которые в какой-то определенный момент\r\n                   находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для\r\n                   анфолловинга/фолловинга от пользователя. Далее передается в компонент \"User\".*/\r\n                   unfollow={this.props.unfollow} /*TC для анфолловинга пользователей. Далее передается в\r\n                   компонент \"User\".*/\r\n                   follow={this.props.follow} /*TC для фолловинга пользователей. Далее передается в компонент \"User\".*/\r\n                   portionSize={this.props.portionSize} /*Свойство, которое указывает какое максимальное количество\r\n                   номеров страниц в постраничном выводе может отображаться в одной порции таких страниц. Это сделано,\r\n                   чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность выбирать\r\n                   страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими порциями страниц.\r\n                   Далее передается в компонент \"Paginator\".*/\r\n            />\r\n        </>\r\n    }\r\n};\r\n\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => {/*Здесь указываются данные из \"state\", которые\r\nнеобходимо передать в компонент \"ProfileContainer\". Эта функция возвращает указанные данные в виде объекта. Эти данные\r\nмы получаем при помощи созданных нами селекторов из \"users-selectors.ts\". На входе \"mapStateToProps\" принимает \"state\"\r\nс типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает данные с типом\r\n\"MapStateToPropsType\".*/\r\n    return {\r\n        users: getUsers(state), /*Данные по пользователям для постраничного вывода пользователей.*/\r\n        pageSize: getPageSize(state), /*Максимальное количество пользователей, которое выводится в постраничном выводе\r\n        пользователей.*/\r\n        totalUsersCount: getTotalUsersCount(state), /*Общее количество пользователей.*/\r\n        currentPage: getCurrentPage(state), /*Текущий номер выбранной страницы в постраничном выводе пользователей.*/\r\n        isFetching: getIsFetching(state), /*Специальное свойство, которое обозначает находится ли в процессе запрос\r\n        на сервер на получение данных по пользователям для постраничного вывода. Если в процессе, то будет\r\n        отрисовываться компонент-заглушка \"Preloader\".*/\r\n        WhoIsInFollowingProgress: getWhoIsInFollowingProgress(state), /*Специальное свойство, которое содержит массив,\r\n        который будет хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе\r\n        анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\n        portionSize: getPortionSize(state) /*Свойство, которое указывает какое количество номеров страниц в постраничном\r\n        выводе может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц,\r\n        коих огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40)\r\n        и переключаться между этими порциями страниц.*/\r\n    }\r\n};\r\n\r\nexport default compose( /*При помощи функции \"compose\" объеденяем ХОКи \"withAuthRedirect\" и \"connect\", возвращая\r\nитоговый компонент \"AppContainer\".*/\r\n    // TStateProps = {}, TDispatchProps = {}, TOwnProps = {}, State = DefaultState\r\n    connect<MapStateToPropsType, MapDispatchToPropsType, OwnPropsType, AppStateType>(mapStateToProps, {\r\n    /*При помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL в\r\n    другой контейнерный компонент \"UsersContainer\" из этого файла. Поскольку метод \"connect\" является \"generic\", то\r\n    его можно уточнить: первым в \"<>\" указан тип для \"MapStateToProps\", вторым для \"MapDispatchToProps\", третьим для\r\n    \"собственных props\" компонента, четвертым для \"state\". Эти параметры мы узнали перейдя в файл декларации метода\r\n    \"connect\", \"Ctrl+click\" в \"WebStorm\".*/\r\n        setCurrentPage, /*AC для установки текущего номера выбранной страницы в постраничном выводе пользователей.*/\r\n        requestUsers, /*TC для запроса с сервера и установки в \"state\" данных по пользователя для постраничного вывода\r\n        пользователей.*/\r\n        follow, /*TC для фолловинга пользователей в постраничном выводе пользователей.*/\r\n        unfollow /*TC для анфолловинга пользователей в постраничном выводе пользователей.*/\r\n    }),\r\n    //withAuthRedirect /*При помощи ХОКа \"withAuthRedirect\" добавляем логику по редиректу в компонент.*/\r\n)(UsersContainer);\r\n/*\r\nПолучившийся в итоге компонент экспортируем, который будет использоваться под именем \"UsersContainer\", по default,\r\nэкспорт необходим для импорта.\r\n*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Music.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"Music\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Music(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Music\" является компонентом, который отображает музыку пользователя.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nfunction Music(props) {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            Music\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Music; /*Экспортируем компонент \"Music\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './News.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"News\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function News(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"News\" является компонентом, который отображает новости пользователя.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nconst News = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            News\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default News; /*Экспортируем компонент \"News\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Settings.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"Settings\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Settings(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Settings\" является компонентом, который отображает настройки сайта.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nconst Settings = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            Settings\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Settings; /*Экспортируем компонент \"Settings\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Friends.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"Friends\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Friends(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Friends\" является компонентом, который отображает друзей пользователя.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nconst Friends = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            Friends\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Friends; /*Экспортируем компонент \"Friends\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Redirect} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\n\"Redirect\" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется\r\nатрибут \"to\".\r\nМаршрут для пути редиректа уже должен быть создан.\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"LoginForm\".\r\n- обворачиваем компонент \"LoginForm\" HOC-ом \"reduxForm\" в компоненте \"LoginReduxForm\", тем самым предоставляя\r\ncallback \"handleSubmit\" для компонента \"LoginForm\".\r\n- компонент \"LoginReduxForm\" указывается в компоненте \"Login\", куда в событие \"onSubmit\" будет попадать объект\r\nс данными, сформированный в событии \"onSubmit\" при помощи callback \"handleSubmit\" в компоненте \"LoginForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"LoginForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"onSubmitForm\" (доступен из контейнерного компонента \"LoginReduxForm\") из компонента \"Login\",\r\nв который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент\r\n\"LoginReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под именем \"login\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n\r\nВ компонент \"LoginForm\" внедряются некие дополнительные \"props\" (например, тот же \"handleSubmit\") ХОКом, который\r\nобразуется при помощи компонента \"LoginReduxForm\". Эти \"props\" содержатся под именем \"InjectedFormProps\". Эти\r\n\"InjectedFormProps\" также содержат добавленные нами \"props\". Поэтому мы импортировали \"InjectedFormProps\" из библиотеки\r\n\"reduxForm\", чтобы типизировать такие \"props\" в компоненте \"LoginForm\".\r\n*/\r\nimport {maxLengthCreator, required} from '../../utils/validators/validators'; /*Подключаем валидаторы для полей форм.*/\r\nimport {createField, Input} from '../common/FormsControls/FormsControls'; /*Подключаем созданный нами компонент \"Input\"\r\nдля создания элемента \"input\" с возможностью указывать валидацию. Также импортируем функцию \"createField\", которая\r\nпринимает параметры и создает элементы формы. Мы ее используем для создания формы в компоненте \"LoginForm\".*/\r\n\r\nimport {login} from '../../redux/auth-reducer'; /*Подключаем TC \"login\" из \"auth-reducer\".*/\r\n\r\nimport styles from './Login.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport style from '../common/FormsControls/FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {AppStateType} from '../../redux/redux-store'; /*Импортируем типы.*/\r\n\r\n\r\n/*Создаем тип для \"MapStateToProps\" для компонента \"Login\". \"MapStateToProps\" в этом компоненте должен обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype MapStateToPropsType = {\r\n    isAuth: boolean /*Информация о том, что являемся ли мы залогинены в приложение или нет, должна быть булева типа.*/\r\n    captchaURL: string | null /*URL капчи при логинизации должен быть строкой.*/\r\n};\r\n\r\n/*Создаем тип для \"MapDispatchToProps\" для компонента \"Login\". \"MapDispatchToProps\" в этом компоненте должен обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype MapDispatchToPropsType = {\r\n    login: (email: string, password: string, rememberMe: boolean, captcha: string) => void /*TC для осуществления\r\n    логинизации должен быть функцией, которая принимает следующие параметры:\r\n    - \"email\" пользователя, который должен быть строкой;\r\n    - пароль пользователя, который должен быть строкой;\r\n    - информация запомнить ли пользователя, которая должна быть булева типа;\r\n    - путь к капче, который должен быть строкой.*/\r\n};\r\n\r\n/*Создаем общий тип для всех \"props\" компонента \"Login\" путем комбинации двух созданных выше типов \"MapStateToPropsType\"\r\nи \"MapDispatchToPropsType\". Все это нужно для указания типа \"props\" в функциональном компоненте \"Login\".*/\r\ntype LoginPropsType = MapStateToPropsType & MapDispatchToPropsType;\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"LoginForm\". \"Собственные props\" в этом компоненте должны обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype LoginFormOwnPropsType = {\r\n    captchaURL: string | null /*Путь к капче, который должен быть строкой или \"null\", то есть быть пустым.*/\r\n};\r\n\r\n/*Создаем тип для \"props\" компонента \"LoginForm\", которые будут использоваться в \"formData\" для компонента \"Login\". Эти\r\n\"props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.*/\r\ntype LoginFormValuesType = {\r\n    email: string /*\"Email\" пользователя, который должен быть строкой.*/\r\n    password: string /*Пароль пользователя, который должен быть строкой.*/\r\n    rememberMe: boolean /*Информация запомнить ли пользователя, которая должна быть булева типа.*/\r\n    captcha: string /*Путь к капче, который должен быть строкой.*/\r\n};\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства \"name\" в \"createField\".\r\nЭто свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы строим свой \"generic\",\r\nчтобы можно было уточнить \"createField\". Нужные нам имена свойств уже перечислены в типе \"LoginFormValuesType\", поэтому\r\nмы при помощи \"keyof\" получаем ключи из \"LoginFormValuesType\". Далее при помощи \"Extract\" (из библиотеки \"TypeScript\")\r\nберем из этих ключей, только те, которые могут быть назначены как строка. И на основе этого создаем тип. Для больших\r\nдеталей смотри реализацию \"createField\" в \"FormsControls.tsx\".*/\r\ntype LoginFormValuesTypeKeys = Extract<keyof LoginFormValuesType, string>;\r\n\r\nconst maxLength30 = maxLengthCreator(30); /*Создали валидатор, который проверяет не введено ли больше\r\n30 символов в поле.*/\r\n\r\n/*\r\n\"LoginForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function LoginForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"LoginForm\" является компонентом, который представляет из себя форму логинизации в виде заготовки для обворачивания ее\r\nв HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"LoginReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым получая\r\ncallback \"handleSubmit\".\r\n*/\r\nconst LoginForm: React.FC<InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType> =\r\n    ({handleSubmit, error, captchaURL}) => {\r\n    /*При помощии деструктуризации \"props\" указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n    \"props.handleSubmit\", \"props.error\" и так далее:\r\n    - callback \"handleSubmit\";\r\n    \"error\" - текст ошибки, которая может появиться при использовании формы, формируется при помощи библиотеки\r\n    \"redux-form\";\r\n    \"captchaURL\" - URL капчи при логинизации.\r\n    Такое мы делаем только в функциональных компонентах.\r\n    Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип\r\n    \"InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType\". Такая комбинация получилась\r\n    следующим образом:\r\n    - \"InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType>\" - здесь мы уточнили внедренные ХОКом, который\r\n    образуется при помощи компонента \"LoginReduxForm\", \"InjectedFormProps\". \"LoginFormValuesType\" указывает, что\r\n    приходит из этого ХОКа, а \"LoginFormOwnPropsType\" указывает, что приходит со стороны - \"captchaURL\".\r\n    - \"& LoginFormOwnPropsType\" - также этот компонент содержит некие свои собственные \"props\", которые не приходят от\r\n    ХОКа выше - тот же \"captchaURL\".\r\n    Это мы сделали на основании файла декларации \"InjectedFormProps\" (\"Ctrl+click\" в \"WebStorm\"). Там указано, что\r\n    первым параметром принимаются \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого\r\n    обворачиваем \"reduxForm\" (то есть компонент \"LoginForm\"), и собственные \"props\" этого компонента \"LoginForm\",\r\n    которые не приходят от ХОКа выше (так нужно для внутренней работы \"InjectedFormProps\"); а вторым параметром\r\n    принимаются еще раз некие свои собственные \"props\", которые не приходят от ХОКа выше (так уже надо для работы самого\r\n    этого компонента \"LoginForm\"). Третьим параметром принимается вид ошибки формы типа строка, но данном случае мы\r\n    этого не указываем. Только все эти три параметра указываются как бы вместе как единый параметр, а не через запятую\r\n    как три разных параметра. ВОЗМОЖНО, это потому, что \"InjectedFormProps\" это объект (как единое целое состоит из\r\n    разных свойств, которые можно типизировать суммой разных типов), а тот же \"reduxForm\" это функция (принимает\r\n    последовательность параметров, где каждый параметр нужно отдельно типизировать).\r\n    */\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указывает\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            {createField<LoginFormValuesTypeKeys>(\"Email\", \"email\", Input, [required, maxLength30])}\r\n            {/*Создали поле для ввода почты на основе импортированной функции \"createField\". Уточняем здесь функцию\r\n            \"createField\", что она имеет тип \"LoginFormValuesTypeKeys\", созданный нами выше.*/}\r\n            {createField<LoginFormValuesTypeKeys>(\"Password\", \"password\", Input, [required, maxLength30], {type: \"password\"})}\r\n            {/*Создали поле для ввода пароля на основе импортированной функции \"createField\". Уточняем здесь функцию\r\n            \"createField\", что она имеет тип \"LoginFormValuesTypeKeys\", созданный нами выше.*/}\r\n            {createField<LoginFormValuesTypeKeys>(undefined, \"rememberMe\", Input, [], {type: \"checkbox\"}, \"Remember me?\")}\r\n            {/*Добавили чек-бокс \"Запомнить меня?\" на основе импортированной функции \"createField\". \"undefined\" означает\r\n            отсутствие свойства.  Уточняем здесь функцию \"createField\", что она имеет тип \"LoginFormValuesTypeKeys\",\r\n            созданный нами выше.*/}\r\n\r\n            {captchaURL && <img src={captchaURL} alt=\"\"/>} {/*Если есть капча, то отрисуем элемент \"img\"\r\n            с изображением капчи.*/}\r\n            {captchaURL && createField(\"Enter the captcha\", \"captcha\", Input, [required])}\r\n            {/*Если есть капча, то отрисуем поле для ввода текства с капчи. Это поле создается на основе импортированной\r\n            функции \"createField\". Уточняем здесь функцию \"createField\", что она имеет тип \"LoginFormValuesTypeKeys\",\r\n            созданный нами выше.*/}\r\n\r\n            {error && <div className={style.formSummaryError}>{error}</div>} {/*Если произошла какая-то ошибка, то\r\n            выведем ее в отдельном элементе \"div\". Свойство \"error\" будет в объекте \"props\" благодаря\r\n            библиотеке \"redux-form\", в него подцепится значение из TC \"login\" из \"auth-reducer.ts\".*/}\r\n\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>Log in</button>\r\n            </div>\r\n        </form>\r\n    );\r\n};\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"LoginForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"LoginReduxForm\" будет заниматься общением\r\nс глобальным \"state\".*/\r\nconst LoginReduxForm = reduxForm<LoginFormValuesType, LoginFormOwnPropsType>({ /*\"reduxForm\" является \"generic\",\r\nпоэтому мы его уточнили. В файле декларации \"reduxForm\" (\"Ctrl+click\" в \"WebStorm\") указано, что он принимает следующие\r\nданные:\r\n- \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого обворачиваем \"reduxForm\" (то\r\nесть компонент \"LoginForm\");\r\n- \"собственные props\" компонента, вокруг которого обворачиваем \"reduxForm\" (то есть компонент \"LoginForm\");\r\n- вид ошибки формы типа строка, но данном случае мы этого не указываем.*/\r\n    form: 'login' /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный \"state\".*/\r\n})(LoginForm);\r\n\r\n/*\r\n\"Login\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Login(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Login\" является компонентом, который представляет из себя финальную страницу с формой логинизации.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВнутри компонента \"Login\" подключается компонент \"LoginReduxForm\", в котором обворачиваем компонент \"LoginForm\"\r\nHOC-ом \"reduxForm\", тем самым предоставляя callback \"handleSubmit\" для компонента \"LoginForm\".\r\n*/\r\nconst Login: React.FC<LoginPropsType> = (props) => {\r\n    /*Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"LoginPropsType\",\r\n    созданный нами выше.*/\r\n    const onSubmitForm = (formData: LoginFormValuesType) => { /*Создали специальный callback \"onSubmitForm\", который будет вызываться\r\n    при срабатывании события \"onSubmit\" в форме. Этот callback будет собирать все данные формы (email пользователя,\r\n    пароль пользователя, указание запомнить ли данные входа, и капча, если присуствует) в одном месте. Эти данные\r\n    будут отдаваться TC \"login\" для осуществления логинизации. Этот callback получает указанные данные на входе в\r\n    объекте \"formData\" с типом \"LoginFormValuesType\".*/\r\n        props.login(formData.email, formData.password, formData.rememberMe, formData.captcha);\r\n    };\r\n\r\n    if (props.isAuth) { /*Если пользователь залогинен, то его должно перенаправить на страницу профиля, вместо показа\r\n    формы для логинизации.*/\r\n        return <Redirect to={'/profile/'}/>\r\n    }\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <h1>Log in</h1> {/*Отрисовываем элемент \"h1\" c текстом \"Log in\".*/}\r\n            <LoginReduxForm onSubmit={onSubmitForm} captchaURL={props.captchaURL}/> {/*Здесь в событии \"onSubmit\" будет\r\n            приходить объект с данными из callback \"handleSubmit\" из компонента \"LoginForm\", который обвернут\r\n            компонентом \"LoginReduxForm\". Далее будет вызываться при этом событии нами созданный\r\n            callback \"onSubmitForm\", в который будет передаваться этот объект с данными. После этого эти данные будут\r\n            отправлятся в часть глобального \"state\", которую обрабатывает библиотека \"redux-form\", с целью\r\n            осуществления работы нашей формы логина. Поскольку мы вызываем функцию \"onSubmitForm\" как callback,\r\n            поэтому не ставим \"()\" после имени функции.*/}\r\n        </div>\r\n    );\r\n};\r\n\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => ({ /*Здесь указываются данные из \"state\", которые\r\nнеобходимо передать в компонент \"Login\". Эта функция возвращает указанные данные в виде объекта. На входе\r\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\r\nданные с типом \"MapStateToPropsType\".*/\r\n    isAuth: state.auth.isAuth, /*Информация о том, что являемся ли мы залогинены в приложение или нет.*/\r\n    captchaURL: state.auth.captchaURL /*URL капчи при логинизации.*/\r\n});\r\n\r\nexport default connect(mapStateToProps, {login})(Login);\r\n/*\r\nПри помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\r\nв другой контейнерный компонент \"Login\" из этого файла. \"login\" - это TC для осуществления логинизации.\r\nПолучившийся в итоге компонент экспортируем, который будет использоваться под именем \"LoginPage\", по default, экспорт\r\nнеобходим для импорта.\r\n*/","/*\r\nЭто файл \"reducer\", отвечающего за сайдбар. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport avatarSource from '../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialStateType = typeof initialState;\r\n\r\n/*Создаем тип для объектов с данными по друзьям, которые в онлайне и отображаются в сайдбаре. Объект, содержащий\r\nинформацию с данными по друзьям, которые в онлайне и отображаются в сайдбаре, должен обязательно содержать следующие\r\nполя с указанными типами.*/\r\ntype FriendType = {\r\n    id: number /*\"ID\" друга в онлайне должно быть числом.*/\r\n    name: string /*Имя друга в онлайне должно быть числом.*/\r\n    avatar: typeof avatarSource /*Аватар друга в онлайне получаем на основе самого изображения аватара при помощи\r\n    \"typeof\".*/\r\n};\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    friendsData: [ /*Создаем массив объектов, которые хранят информацию о друзьях пользователя в онлайне, которые\r\n    отображаются в сайдбаре.*/\r\n        {id: 1, name: 'Abba', avatar: avatarSource},\r\n        {id: 2, name: 'Bret', avatar: avatarSource},\r\n        {id: 3, name: 'Carry', avatar: avatarSource}\r\n    ] as Array<FriendType> /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"FriendType\".\r\n    Тип \"FriendType\" был создан нами выше.*/\r\n};\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst sidebarReducer = (state = initialState, action: any): InitialStateType => { /*Указываем, что\r\nтип \"state\" на выходе имеет тот же тип \"InitialStateType\", что и \"state\" на входе.*/\r\n    return state; /*Этот \"reducer\" просто возвращает \"state\".*/\r\n};\r\n\r\nexport default sidebarReducer; /*Экспортируем \"sidebarReducer\" по default, экспорт необходим для импорта.*/","/*\r\nНам нужен этот \"reducer\", чтобы избежать моргания страницы (кроме страницы профиля) после \"F5\", так как после каждого\r\nобновления страницы отправляется запрос на логинизацию, и пока осуществляется этот запрос мы будем считаться\r\nнезалогиненными, соотвественно будем видеть страницу логинизации, а когда запрос на логинизацию завершится мы увидим\r\nстраницу профиля вместо нужной нам страницы. И чтобы этого не допустить мы не будем ничего показывать, пока не убедимся\r\nчто мы залогинены.\r\n*/\r\n\r\nimport {getAuthUserData} from './auth-reducer'; /*Подключаем TC \"getAuthUserData\"  для запроса и установки данных\r\nзалогиненного пользователя в \"state\" из \"auth-reducer.ts\".*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Импортируем типы.*/\r\nimport {Dispatch} from 'redux'; /*Импортировали из библиотеки \"redux\", чтобы создать тип для \"dispatch\", который\r\nпередается в \"thunks\" и TC.*/\r\nimport {ThunkAction} from 'redux-thunk'; /*Импортировали из библиотеки \"redux-thunk\", чтобы создать тип для \"thunks\".*/\r\n\r\n\r\n/*\r\nЭто константы для указания значения свойства \"type\" в объекте \"action\".\r\nЭто сделано специально, что не использовать захардкоденные значения в \"AC\" и \"reducers\", а также для того,\r\nчтобы избежать случаев одиноковых значений из-за чего один и тот же объект \"action\" может сработать в нескольких\r\n\"reducers\".\r\n*/\r\nconst INITIALIZATION_SUCCESSFUL = 'react-samurai-01/app-reducer/INITIALIZATION-SUCCESSFUL'; /*Объект \"action\" для\r\nинициализации приложения.*/\r\n\r\n/*Создаем тип \"state\". \"state\" обязательно должен содержать следующие поля указанного типа.*/\r\ntype InitialStateType = {\r\n    initialized: boolean /*Информация о том инициализировано ли наше приложение должна быть булева типа.*/\r\n};\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState: InitialStateType = { /*Указываем, что \"initialState\" имеет тип \"InitialStateType\", созданный нами\r\nвыше.*/\r\n    initialized: false /*Свойство, которое показывает инициализировано ли приложение.*/\r\n};\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst appReducer = (state = initialState, action: ActionsType): InitialStateType => { /*Указываем, что тип\r\n\"state\" на выходе имеет тот же тип \"InitialStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case INITIALIZATION_SUCCESSFUL:\r\n            return { /*Указываем, что приложение успешно инициализировано.*/\r\n                ...state, /*Делаем поверхностную копию \"state\". На данный момент этого не требуется, так как далее\r\n                мы меняем примитив.*/\r\n                initialized: true /*Меняем свойство, показывающее инициализировано ли приложение.*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InitializingAppActionType; /*Здесь мы все созданные раннее типы для объектов \"action\" объеденили в\r\n    один тип.*/\r\n\r\ntype InitializingAppActionType = { /*Создали тип для объекта \"action\" \"INITIALIZATION_SUCCESSFUL\" на основе самого\r\n\"INITIALIZATION_SUCCESSFUL\" при помощи \"typeof\".*/\r\n    type: typeof INITIALIZATION_SUCCESSFUL\r\n};\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const initializingApp = (): InitializingAppActionType => ({ /*AC для инициализации приложения.\r\nОбъект \"action\" на выходе имеет тип \"InitializingAppActionType\".*/\r\n    type: INITIALIZATION_SUCCESSFUL /*Обязательно свойство \"type\" для AC.*/\r\n});\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype GetStateType = () => AppStateType; /*Создали тип для \"getState()\", который получает \"thunks\" и TC. \"getState()\"\r\nдолжен быть функцией, которая не получает ничего на входе и возвращает объект с типом \"AppStateType\", созданным нами и\r\nимпортированным сюда. Мы это здесь не используем, так как типизация \"thunks\" перекрывает эту типизацию, поскольку\r\nтипизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше,\r\nто есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n\r\ntype DispatchType = Dispatch<ActionsType>; /*Создали тип для \"dispatch\", передается в \"thunks\" и TC. \"dispatch\" должен\r\nбыть \"Dispatch\" из библиотеки \"redux\", работающий с объектами \"action\" тип \"ActionsType\", который мы создали выше.*/\r\n\r\ntype ThunkType = ThunkAction<void, AppStateType, unknown, ActionsType> /*Создали тип для \"thunks\". \"thunks\"\r\nдолжны быть объектами \"action\" для \"thunks\" из библиотеки \"redux-thunk\", работающими с:\r\n1) здесь указан \"void\", так как в данном случае (TC \"initializeApp\") \"thunks\" ничего не возвращают;\r\n2) \"state\" с типом \"AppStateType\", созданным нами и импортированным сюда;\r\n3) какими-то неизвестными дополнительными аргументами;\r\n4) объектами \"action\" тип \"ActionsType\", который мы создали выше.\r\nЭти уточнения мы нашли в файле декларации \"ThunkAction\", \"Ctrl+click\" в \"WebStorm\".\r\n*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const initializeApp = (): ThunkType => (dispatch) => {\r\n/*TC для инициализации приложения. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами\r\nвыше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что\r\nвозвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    let promise = dispatch(getAuthUserData()); /*Здесь \"dispatch\" возвращает то, что вернет \"getAuthUserData\" (TC\r\n    отвечающий за запрос и установку данных залогиненного пользователя в \"state\"), и поместит это в массив \"promise\"\r\n    (потому, что вернется массив). В этом массиве будет разная информация, в том числе и разные \"promise\".*/\r\n\r\n    Promise.all([promise]) /*Здесь мы будем ждать выполнения всех \"promise\" в массиве \"[promise]\" (причем не\r\n    важно успешно они завершатся или нет). После этого сработает блок \"then\".*/\r\n        .then(() => {\r\n            dispatch(initializingApp()); /*вызываем TC \"initializingApp\" для указания, что инициализации приложения\r\n            завершена.*/\r\n        });\r\n};\r\n/*\r\nЭтот TC работает примерно так:\r\n- сначала срабатывает TC \"getAuthUserData\".\r\n- ожидаем выполнения 1-го шага.\r\n- после завершения 1-го шага указываем, что приложение инициализировано.\r\n*/\r\n\r\nexport default appReducer; /*Экспортируем \"appReducer\" по default, экспорт необходим для импорта.*/","/*\r\nЭтот файл содержит наш \"store\", созданный при помощи библиотеки \"redux\".\r\n\"React Developer Tools\" - это плагин для браузеров, который позволяет отслеживать какой компонент\r\nсколько рендериться, увидеть дерево компонентов (props, hooks) и прочее.\r\n\"Redux DevTools\" - это плагин для браузеров, который показывает, что находится в \"state\" и все объекты \"action\",\r\nкоторые диспатчатся в \"state\".\r\n*/\r\n\r\nimport {applyMiddleware, combineReducers, compose, createStore} from 'redux';\r\n/*\r\nБиблиотека \"redux\" помогает организовать FLUX-круговорот и \"state management\".\r\nВ \"redux\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\n\"Store\" в \"redux\" при уведомлении подписчиков не передает им \"state\".\r\nМетод \"createStore\" позволяет создать \"store\".\r\nДля работы этого \"store\" нужно создавать отдельные \"reducers\".\r\nМетод \"combineReducers\" позволяет объеденить все \"reducers\".\r\nМетоде \"applyMiddleware\" добавляет возможность указывать и подключать в \"store\" промежуточный слой между\r\n\"store.dispatch\" и \"reducers\".\r\nНам нужен будет слой \"thunk middleware\" для работы с \"thunks\".\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и ХОКи.\r\nОбвертки и ХОКи указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\n*/\r\nimport thunkMiddleWare from 'redux-thunk';\r\n/*\r\nДля установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\".\r\n\"thunk middleware\" это промежуточный слой между \"store.dispatch\" и \"reducers\" для работы с \"thunks\".\r\nДля добавления в наш проект этого слоя мы импортируем \"thunkMiddleWare\".\r\n*/\r\nimport {reducer as formReducer} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\n*/\r\n\r\nimport profileReducer from './profile-reducer'; /*Импортируем \"reducer\", отвечающий за страницу профиля.*/\r\nimport dialogsReducer from './dialogs-reducer'; /*Импортируем \"reducer\", отвечающий за страницу диалогов.*/\r\nimport sidebarReducer from './sidebar-reducer'; /*Импортируем \"reducer\", отвечающий за сайдбар.*/\r\nimport usersReducer from './users-reducer'; /*Импортируем \"reducer\", отвечающий за страницу пользователей.*/\r\nimport authReducer from './auth-reducer'; /*Импортируем \"reducer\", отвечающий за аутентификацию пользователей.*/\r\nimport appReducer from './app-reducer'; /*Импортируем \"reducer\", отвечающий за инициализацию приложеня.*/\r\n\r\n\r\n/*Делаем на основе нашего корневого \"reducer\" \"rootReducer\" тип при помощи \"typeof\". В итоге там получится что-то вроде\r\nфункции \"(globalState: AppStateType) => AppStateType\", то есть получает на входе \"state\" типа \"AppStateType\" (имя\r\nвыдумано нами) и на выходе возвращает \"state\" того же типа. То есть мы получили тип для нашего \"rootReducer\".*/\r\ntype RootReducerType = typeof rootReducer;\r\n/*Сохраняем тип нашего \"state\" в переменную \"AppStateType\", чтобы можно было указывать тип \"state\" в компонентах, при\r\nпомощи \"ReturnType\" (скорее всего получает тип того, что возвращается, а \"reducer\" возвращает \"state\") из типа\r\n\"rootReducer\".*/\r\nexport type AppStateType = ReturnType<RootReducerType>;\r\n\r\n/*Это список наших \"reducers\" в нашем \"store\".*/\r\nlet rootReducer = combineReducers({ /*При помощи метода \"combineReducers\" объеденяем все наши \"reducers\"\r\nв \"rootReducer\". Иногда можно дробить \"reducers\" на \"под-reducers\", которые вызываются внутри \"reducers\". Наш\r\n\"rootReducer\" сначала берет весь начальный \"state\", раздает его по кускам в \"reducers\", они в свою очередь возвращают\r\nобратно измененные куски \"state\", которые \"rootReducer\" собирает в новый \"state\" и возвращает его.*/\r\n    profilePage: profileReducer,\r\n    dialogsPage: dialogsReducer,\r\n    sidebar: sidebarReducer,\r\n    usersPage: usersReducer,\r\n    auth: authReducer,\r\n    form: formReducer, /*Здесь важно, чтобы часть \"state\", которая создается библиотекой \"redux-form\", называлась\r\n    именно \"form\", иначе придется многое переписывать дополнительно.*/\r\n    app: appReducer\r\n});\r\n\r\n/*Здесь идет создание \"store\" и установка плагина \"Redux DevTools\".*/\r\n/*Также далее идет комментарий, который говорит \"TypeScript\", чтобы он игнорировал следующий\r\nза этим комментарием код.*/\r\n// @ts-ignore\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\n/*\"window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\" - это какой-то глобальный объект из плагина \"Redux DevTools\".\r\nЭта строчка является необходимой для того, чтобы плагин \"Redux DevTools\" работал.\r\nЭтим \"composeEnhancers\" мы ниже обварачиваем создание промежуточного слоя \"thunkMiddleWare\" в \"store\",\r\nчто также необходимо, чтобы плагин \"Redux DevTools\" работал.*/\r\nconst store = createStore(rootReducer, composeEnhancers(applyMiddleware(thunkMiddleWare)));\r\n/*\r\nПри помощи метода \"createStore\"\r\nсоздаем \"store\", передавая ему наш \"rootReducer\". При помощи метода \"applyMiddleware\" указываем, что подключаем в\r\n\"store\" промежуточный слой \"thunkMiddleWare\".\r\n*/\r\n\r\n/*Далее идет комментарий, который говорит \"TypeScript\", чтобы он игнорировал следующий\r\nза этим комментарием код. Если же все-таки нужно будет типизировать объект \"window\", то вроде можно написать такое:\r\n\r\ndeclare global {\r\n    interface Window {\r\n        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__: any,\r\n        store: any\r\n    }\r\n};\r\n\r\n*/\r\n// @ts-ignore\r\nwindow.__store__ = store; /*На случай если нам нужно будет глобально обратиться к \"store\".*/\r\n\r\nexport default store; /*Экспортируем весь \"store\" по default, экспорт необходим для импорта.*/","/*\n\"GitHub\" имеет примитивный хостинг для статических страниц.\nМы создали отдельный репозиторий на GitHub (\"demo-spa\") для хостинга нашего приложения.\nЖелательно настраивать \"SSH\" вместо \"HTTPS\" в \"GitHub\".\nВ \"GitHub\" в настройках репозитория есть \"GitHub Pages\", там в \"source\" нужно выбрать \"master\" ветку.\nЧтобы сайт отобразился нужно там же в настройках выбрать тему сайта.\nЧтобы на \"GitHub\" открывалось наше приложения нужно сначала собрать его \"build\". Для этого в \"npm\" нужно выбрать \"build\"\nили ввести \"npm run build\". После этого появится папка \"build\", в которой будет лежать наше билд нашего приложения.\nНо если загрузить этот билд на \"GitHub\", то будут проблемы с URL, так как \"GitHub\" не является полноценным хостингом\nи наше приложения будет находится относительно другого URL - \"myname.github.io/repo-name/\".\nДля того, чтобы развернуть приложение на \"ReactJS\" нужно установить пакет \"gh-pages\":\n\"npm install gh-pages --save -dev\".\nДалее нужно внести изменения в файл \"package.json\", чтобы указать домашнюю страницу. Нужно в верхний уровень (например,\nперед \"dependencies\") ввести:\n\"homepage\": \"сайт-репозитория\".\nТакже здесь нужно добавить пару скриптов в раздел \"scripts\":\n\"predeploy\": \"npm run build\",\n\"deploy\": \"gh-pages -d build\".\nКоманда \"deploy\" автоматически создает ветку \"gh-pages\" на \"GitHub\" куда разместит билд нашего приложение.\nНо с \"GitHub\" запрещено делать запросы к нашему API сервера, поэтому на сайте \"API\" в настройках нужно указать домен:\n\"https://имя-аккаунта.github.io\".\nВ итоге на ветке \"master\" должен быть исходный код нашего приложения, а на ветке \"gh-pages\" билд нашего приложения.\nМы должны быть подключены к нашему удаленному репозиторию для осуществления этих действий:\n\"git remote add origin url-адресс-github-репозитория.git\". После этого уже можно делать \"deploy\".\n\nПосле этого сайт уже должен отрисовываться, но все еще могут быть некоторые проблемы.\nИзначально приложение отрисовывается по такому пути: \"имя-аккаунта-на-github/имя-репозитория/\", но при переходе\nпо компонентам, имя репозитория затирается путем для компонента (например, \"/profile\"). И если мы нажимаем \"F5\", то\n\"GitHub\" не поймет нашего адреса и не найдет наше приложение, так как будет считать, что \"/profile\" - это один из\nнаших репозиториев. Чтобы решить эту проблему нужно настроить \"BrowseRouter\" в \"App.js\". Там, где мы используем\nтег \"BrowserRouter\", мы должны добавить:\n\"<BrowserRouter basename={process.env.PUBLIC_URL}>\".\nЭто будет говорить, что надо автоматически брать URL из окружения. \"process\" - это глобальный объект из \"Node.JS\",\n\"env\" - это окружения, тоже из \"Node.JS\", \"PUBLIC_URL\" - если \"localhost\", то тут будет пустота, если \"GitHub\", то\n\"gh-pages\" укажет ссылку на репозиторий. Но мы это не используем в проекте, так как это все равно не решает проблему,\nпоскольку \"GitHub\" пытается после нажатия \"F5\" найти \"index.html\", например, в папке \"/profile\", про которую он\nне знает.\n\nИ для решения этой проблемы мы используем \"HashRouter\" вместо \"BrowseRouter\". \"HashRouter\" использует якори \"#\". Якори\nизначально использовались для перемещения по странице, но в дальнейшем стали использоваться для переключения страниц\nбез изменения URL. Так делали до появления \"HistoryAPI\" в \"HTML5\", поэтому \"HashRouter\" не особо используется сегодня.\nНо в нашем случае он поможет, поскольку \"#\" и все, что идет после, не будут считаться частью названия сайта и \"GitHub\"\nбудет искать \"index.html\" там, где надо. \"#\" - это браузерная фишка.\n\nТо есть перед каждым \"deploy\" нужно сделать две вещи:\n1. \"BrowseRouter\" заменить на \"HashRouter\".\n2. В файл \"package.json\" в верхний уровень (например, перед \"dependencies\") ввести:\n\"homepage\": \"сайт-репозитория\".\nА после можно вернуть все обратно.\n\nПосле каждого \"deploy\" нужно немного подождать, чтобы наше приложение обновилось на \"GitHub\".\nЧтобы в ветку \"master\" добавить исходный код нужно ввести:\n\"git push origin master\".\n*/\n\nimport React, {Suspense} from 'react';\n/*\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\n\"WebPack\" уже встроен в \"ReactJS\".\nИмпортируем \"Suspense\" для реализации \"lazy loading\" (больше об этом в HOC \"WithSuspense.js\").\n*/\nimport {Route, BrowserRouter, HashRouter, withRouter, Redirect, Switch} from 'react-router-dom';\n/*\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\nПодключаем \"Route\" для создания маршрутов.\nВ каждом \"Route\" указывается путь \"path\", которые прослушивается.\nТакже в каждом \"Route\" указывается компонент в \"render\", который отображается если активируется прослушиваемый путь.\nЧтобы маршруты \"Route\" работали их нужно всех обвернуть в корневой тег \"BrowserRouter\".\nДля перемещения по \"Route\" маршрутам используетс \"NavLink\" (в этом компоненте этого нет, но есть в других).\nФункция \"withRouter\" это HOC.\nHOC (ХОК) - high order component (компонента высшего порядка).\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\nна выходе возвращает другой компонент.\nHOC позволяет создавать однообразные контейнерные компоненты.\nПоскольку URL тоже является источником данных, то компоненту иногда могут понадобиться эти данные.\nЧтобы их получить, можно воспользоваться \"withRouter\".\nHOC \"withRouter\" принимает в качестве параметра компонент и передает ему через \"props\" данные из URL, чтобы компонент\nзнал где он находиться - т.е. какой у него маршрут.\nЕсли подключить на самом высоком уровне дерева компонентов этот HOC, например, в \"App.js\", то данные URL будут доступны\nи в дочерних компонентах.\nПри использовании \"connect\" роутинг сбивается. Чтобы решить эту проблемы мы обварачиваем \"connect\" при помощи\n\"withRouter\". Но сейчас вроде и без этого все работает.\n\"Redirect\" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется\nатрибут \"to\".\nМаршрут для пути редиректа уже должен быть создан.\n\"Switch\" - это аналог для реализации \"exact\" (смотри в коде ниже). Работает по принципу \"switch/case\" - как только\nнашли \"Route\" с подходящим путем, то его сразу и отрисовываем.\n\"HashRouter\" - описание в самом верху, используем только для развертывания нашего приложения на \"GitHub\".\n*/\nimport {connect, Provider} from 'react-redux';\n/*\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\nHOC (ХОК) - high order component (компонента высшего порядка).\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\nна выходе возвращает другой компонент.\nHOC позволяет создавать однообразные контейнерные компоненты.\nМетод \"connect\" используется для создания компонентов и контейнеров.\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\nМетод \"connect\" упрощает перекидывание \"props\".\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\nBLL и DAL.\n\"Provider\" позволяет указать компонент, который будет поставщиком данных BLL и DAL для всего его дочерних компонентов.\nТак же использование \"Provider\" избавляет нас от обязанности прокидывать указанные данные через все дерево компонентов.\nВ нашем случае это компонент \"AppContainer\".\n*/\nimport {compose} from 'redux';\n/*\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\nнесколько обверток вокруг компонента и ХОКи.\nОбвертки и ХОКи указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\n\"connect\" из библиотеки \"react-redux\".\n*/\n\nimport logo from './logo.svg'; /*Подключаем svg-файл как лого, но он не используется в нашем проекте.*/\nimport './App.css'; /*Подключаем файл CSS.*/\n\nimport Preloader from './components/common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\nimport HeaderContainer from './components/Header/HeaderContainer'; /*Подключаем компонент \"HeaderContainer\".*/\nimport NavbarContainer from './components/Navbar/NavbarContainer'; /*Подключаем компонент \"NavbarContainer\".*/\nimport UsersContainer from './components/Users/UsersContainer'; /*Подключаем компонент \"UsersContainer\".*/\nimport Music from './components/Music/Music'; /*Подключаем компонент \"Music\".*/\nimport News from './components/News/News'; /*Подключаем компонент \"News\".*/\nimport Settings from './components/Settings/Settings'; /*Подключаем компонент \"Settings\".*/\nimport Friends from './components/Friends/Friends'; /*Подключаем компонент \"Friends\".*/\nimport LoginPage from './components/Login/Login'; /*Подключаем компонент \"LoginPage\".*/\n\nimport {withSuspense} from './hoc/WithSuspense'; /*Подключаем наш HOC \"WithSuspense.js\" для реализации \"lazy loading\"\nдля компонентов \"DialogContainer.jsx\" и \"ProfileContainer.jsx\".*/\n\nimport store from './redux/redux-store'; /*Подключаем наш \"store\" из \"redux\".*/\nimport {initializeApp} from './redux/app-reducer'; /*Подключаем TC \"initializeApp\" из \"app-reducer\".*/\n\nconst DialogsContainer = React.lazy(() => import('./components/Dialogs/DialogsContainer'));\nconst ProfileContainer = React.lazy(() => import('./components/Profile/ProfileContainer'));\n/*\nЗдесь вместо стандартного импорта компонентов \"DialogContainer.jsx\" и \"ProfileContainer.jsx\" (чтобы они не попали\nв бандлы) в целях реализации \"lazy loading\" мы используем \"React.lazy\". Ниже в роутах мы обварачиваем эти компоненты\nв \"Suspense\" или в наш ХОК \"WithSuspense.js\" для реализации \"lazy loading\".\n*/\n\n\n/*\n\"App\" это классовый компонент.\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\nконцепцию ООП.\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\nвзаимодействует.\nНапример, у него можно постоянно запрашивать JSX.\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\nКомпонент это функция, которая возвращает JSX.\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\nJSX совмещает в себе JS и HTML.\nКомпонент это функция, которая возвращает JSX.\nJSX совмещает в себе JS и HTML.\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\nКаждый компонент желательно помещать в отдельный файл.\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\nПринято объект с параметрами именовать как \"props\".\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\n\"App\" является главным корневым компонентом, к которой в дереве компонентов подключаются остальные компоненты.\n*/\nclass App extends React.Component {\n    /*Далее идет код, который отлавливает отклоненные промисы. \"promiseRejectionEvent\" - это перехватчик событий.\n    Желательно вместо \"alert\" сделать красивый вывод ошибки. Внизу в \"componentDidMount()\" совместно\n    с \"componentWillUnmount()\" есть еще одна реализация перехвата отклоненных промисов. В данный момент мы не используем\n    ни один из этих вариантов, так как используем для перехвата ошибок \"try/catch\" в TC \"updateUserStatus\" в файле\n    \"profile-reducer.ts\", что будет мешать работать прослушиванию событий (хотя возможно первая реализация будет\n    работать).*/\n    /*catchAllUnhandledErrors = (promiseRejectionEvent) => {\n        alert(\"some error occurred\");\n    };*/\n\n    componentDidMount() {/*Это метод жизненного цикла классового компонента. Он вызывается в момент первой отрисовки\n    (монтирования) компонента.*/\n        this.props.initializeApp(); /*При монтировании компонента вызывается TC \"initializeApp\" для инициализации\n        приложения. Поскольку мы это делаем в компоненте \"App\", который является точкой входа, то есть мы его всегда\n        видим, то это будет работать во всем приложении.*/\n\n        /*Еще одна реализация перехвата отклоненных промисов, продолжение ниже в \"componentWillUnmount()\".\n        \"window.addEventListener\" - это side effects, подписались на прослушивание событий по типу\n        \"unhandledrejection\". Когда происходит событие, то вызывается метод \"this.catchAllUnhandledErrors\".*/\n        /*window.addEventListener(\"unhandledrejection\", this.catchAllUnhandledErrors);*/\n    };\n\n    /*\"componentWillUnmount()\" - это метод жизненного цикла классового компонента. Он вызывается в момент, когда\n    компонент перестает быть отрисованным. Здесь при демонтирования компонента мы отписываемся от прослушивания\n    событий из \"componentDidMount()\".*/\n    /*componentWillUnmount() {\n        window.removeEventListener(\"unhandledrejection\", this.catchAllUnhandledErrors);\n    };*/\n\n    render() {\n        if (!this.props.initialized) { /*Пока мы не убедимся, что приложение инициализировано, мы будем показывать\n        компонент \"Preloader\", тем самым избежим мигания сайта из-за редиректов.*/\n            return <Preloader/>\n        }\n\n        /*\n        Здесь после return в компоненте начинается HTML разметка.\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\n        */\n        return (\n            <div className='app-wrapper'> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\n\n                <HeaderContainer/> {/*Отрисовываем компонет \"HeaderContainer\", указывая его тег в JSX.*/}\n\n                <NavbarContainer/> {/*Отрисовываем компонет \"NavbarContainer\", указывая его тег в JSX.*/}\n\n                <div className='app-wrapper-content'> {/*Этот элемент \"div\" содержит основной контент нашего приложения.\n                Контент будет меняться в зависимости от выбранного маршрута, которые здесь указаны в тегах \"Route\".*/}\n                    <Switch>\n                        <Route exact path='/' /*Создаем маршрут для пути '/'. \"exact\" говорит о том, что путь должен\n                        совпадать точь в точь, то есть если, например, будет какой-то подпуть, то такой путь\n                        не подойдет.*/\n                               render={() => <Redirect to='/profile'/>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.\n                               В данном случае произойдет редирект на путь '/profile'.*/}\n\n                        {/*Это еще одна версия вышеуказанного \"Route\" редиректом. Оба варианта рабочие, если они\n                        обвернуты в тег <Switch>.*/}\n                        {/*}\n                        <Route exact path='/'>\n                            <Redirect to='/profile'/>\n                        </Route>\n                        */}\n\n                        <Route path='/dialogs/' /*Создаем маршрут для пути '/dialogs/'.*/\n                               render={() => <Suspense fallback={<Preloader/>}><DialogsContainer/></Suspense>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.\n                               Здесь мы также использовали тег \"Suspense\", чтобы реализовать \"lazy loading\" без\n                               нашего ХОКа \"WithSuspense.js\". Также здесь указано, что пока будет идти загрузка\n                               компонента будет показываться компонент-заглушка \"Preloader\".*/}\n\n                        <Route path='/profile/:userID?' /*Создаем маршрут для пути '/profile/:userID?'. \":userID\"\n                        означает, что у пути может быть какое-то дополнение по типу \"ID\" пользователя, это не является\n                        параметром запроса. \"?\" в конце означает, что это дополнение является опциональным, если это\n                        не указать, то просто переход в \"/profile\" не отрисует компонент.*/\n                               render={withSuspense(ProfileContainer)}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.\n                               Здесь мы также используем наш ХОК \"WithSuspense.js\" для реализации \"lazy loading\".*/}\n\n                        {/*Далее представлен еще один способ реализации \"lazy loading\" для компонентов\n                        \"DialogContainer.jsx\" и \"ProfileContainer.jsx\" без использования нашего ХОКа \"WithSuspense.js\".\n                        Здесь мы сразу несколько тегов \"Route\" обварачиваем в один тег \"Suspense\". В данный момент\n                        этот вариант не используется в нашем проекте.*/}\n                        {/*\n                        <Suspense fallback={<Preloader/>}>\n                            <Route path='/dialogs/'\n                                   render={() => <DialogsContainer/>}/>\n                            <Route path='/profile/:userID?'\n                                   render={() => <ProfileContainer/>}/>\n                        </Suspense>\n                        */}\n\n                        <Route path='/users/' /*Создаем маршрут для пути '/users/'.*/\n                               render={() => <UsersContainer pageTitle={'KEK'}/>}/> {/*Для учебных целей в рамках\n                               изучения типов для \"props\" передаем свойство \"pageTitle\".*/}\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n\n                        <Route path='/news/' /*Создаем маршрут для пути '/news/'.*/\n                               render={() => <News/>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n\n                        <Route path='/music/' /*Создаем маршрут для пути '/music/'.*/\n                               render={() => <Music/>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n\n                        <Route path='/settings/' /*Создаем маршрут для пути '/settings/'.*/\n                               render={() => <Settings/>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n\n                        <Route path='/friends/' /*Создаем маршрут для пути '/friends/'.*/\n                               render={() => <Friends/>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n\n                        <Route path='/login/' /*Создаем маршрут для пути '/login/'. Если нужно, что в компонент\n                        \"Login\" можно было попасть только по одному адресу, то нужно использовать\n                        \"exact path='/login/'\". Тогда, например, если перейти по пути '/login/facebook', то мы не\n                        попадем в этот компонент. Аналогичный результат можно получить, если обвернуть все \"Route\" в\n                        тег <Switch>.*/\n                               render={() => <LoginPage/>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n\n                        <Route path='*' /*Создаем маршрут для пути '*'. Этот путь обозначает неверный URL, то есть\n                        любой отличающийся от любого пути в указанных нами маршрутах. Нужно для отображения \"404\"\n                        в таких случаях. Чтобы это работало нужно обвернуть все \"Route\" в тег <Switch>.*/\n                               render={() => <div>404 NOT FOUND</div>}/>\n                               {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\",\n                               которую вызовет \"Route\" при совпадении пути. \"render\" позволяет передавать параметры.*/}\n                    </Switch>\n                </div>\n            </div>\n        );\n    }\n};\n\nconst mapStateToProps = (state) => ({ /*Здесь указываются данные из \"state\", которые необходимо передать в\nкомпонент \"App\". Эта функция возвращает указанные данные в виде объекта.*/\n    initialized: state.app.initialized /*Свойство, которое показывает инициализировано ли приложение.*/\n});\n\n/*Поскольку мы не можем обворачивать компонент \"App\" в файле \"index.js\", мы это делаем здесь. Создали внутри этого\nфайла контейнерный компонент \"AppContainer\", который обварачивает наш компонент \"App\" при помощи метода \"compose\".*/\nlet AppContainer = compose( /*При помощи функции \"compose\" объеденяем ХОКи \"withRouter\" и \"connect\", возвращая итоговый\nкомпонент \"AppContainer\".*/\n    withRouter, /*При помощи метода \"withRouter\" передаем в этот контейнерный компонент данные из URL.*/\n    connect(mapStateToProps, {initializeApp}) /*При помощи метода \"connect\" создаем контейнерный\n    компонент, и тем самым передаем нужные данные BLL и DAL компоненту \"App\".*/\n)(App);\n\n/*Далее мы обварачиваем созданный выше контейнерный компонент \"AppContainer\" в \"Provider\" и в \"BrowserRouter\".\nПолучившийся в итоге компонент \"AppMain\" экспортируется, чтобы использоваться в файле \"index.js\".\nПри помощи этих двух компонентов \"AppContainer\" и \"AppMain\" мы избавились от обверток вокруг компонента \"App\"\nв файле \"index.js\"*/\nconst AppMain = (props) => {\n    return (\n        <HashRouter> {/*Обворачиваем компонент \"AppContainer\" в тег \"BrowserRouter\", чтобы работали маршруты \"Route\"\n        в компоненте \"App\".*/}\n            <Provider store={store}> {/*Обворачиваем компонент \"AppContainer\" в тег \"Provider\", чтобы указать,\n            что этот компонент будет поставщиком данных BLL и DAL для дочерних компонентов, то есть для создания\n            контекста, из которого контейнерные компоненты смогут брать указанные данные. Также здесь указываем\n            наш \"store\".*/}\n                <AppContainer/>\n            </Provider>\n        </HashRouter>\n    )\n};\n\nexport default AppMain; /*Экспортируем компонент \"AppMain\" по default, экспорт необходим для импорта.*/","/*\r\nПри отрисовке приложения в браузере файлы проекта собираются в отдельные группы файлов - бандлы (bundles). При помощи\r\nних HTTP быстрее загружает приложение. Можно сделать так, чтобы подгружалось только то, что необходимо для отображения,\r\nа не все бандлы. Все остальное будет загружаться по необходимости. Это называется \"lazy loading\". В зависимости от\r\nцелей можно использовать \"lazy loading\" или загружать бОльшее количество бандлов. Бандлы собираются путем пробега\r\n\"WebPack\" по импортам в проекте. Компоненты в \"lazy loading\" нужно обворачивать в \"Suspense\" из \"ReactJS\". Для этого\r\nобварачивания мы создали этот HOC \"WithSuspense.js\". Далее мы используем этот HOC в компоненте \"App.js\" для\r\nкомпонентов \"DialogContainer.jsx\" и \"ProfileContainer.jsx\".\r\n*/\r\n\r\nimport React, {Suspense} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nИмпортируем \"Suspense\" для реализации \"lazy loading\".\r\n*/\r\n\r\nimport Preloader from '../components/common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\r\n\r\n\r\nexport const withSuspense = (Component) => { /*Это и есть наш HOC, который в качестве параметра принимает\r\nкакой-либо компонент.*/\r\n    return (props) => {\r\n        return ( /*Этот ХОК обварачивает полученный компонент в тег \"Suspense\" для реализации \"lazy loading\". Также\r\n        в этот компонент передаются \"props\".*/\r\n            <Suspense fallback={<Preloader/>}> {/*Пока будет идти загрузка компонента будет показываться\r\n            компонент-заглушка \"Preloader\".*/}\r\n                <Component {...props}/>\r\n            </Suspense>\r\n        )\r\n    };\r\n};\r\n","/*\nВ \"index.js\" не должно быть обверток вокруг \"App\", поэтому мы их перенесли в \"App.js\".\n\"index.js\" - это точка входя для сборщика \"WebPack\".\n\"index.html\" - это точка входа нашего приложения.\n\"index.css\" содержит общие стили для всего приложения.\n*/\n\nimport * as serviceWorker from './serviceWorker'; /*Было уже изначально. Это из темы \"Progressive Web\nApplication (PWA)\".*/\nimport React from 'react';\n/*\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\n\"WebPack\" уже встроен в \"ReactJS\".\n*/\nimport ReactDOM from 'react-dom'; /*Подключаем ReactDOM для метода \"render\", который отрисовывает\nDOM-дерево из ReactJS.*/\n\nimport './index.css'; /*Подключаем файл CSS.*/\n\nimport AppMain from './App'; /*Импортируем компонент \"AppMain\", который будет отрисовываться.*/\n\n\n/*В index.js мы указываем главный компонент \"AppMain\" (компонент \"App\" обвернутый разными обвертками), который\nбудет отрисовываться.*/\nReactDOM.render(\n    <React.StrictMode> {/*\"StrictMode\" это специальный строгий режим из \"ReactJS\", для избежания некоторых ошибок.*/}\n        <AppMain /> {/*Будет отрисовываться компонент \"AppMain\".*/}\n    </React.StrictMode>,\n    document.getElementById('root') /*JS будет отрисовывать приложение\n    в элементе \"div\" с \"ID\" \"root\" в \"index.html\".*/\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport preloader from '../../../assets/images/preloader.gif'; /*Импортируем из ассетов анимированное изображение,\r\nизображающее загрузку.*/\r\n\r\n\r\n/*\r\n\"Preloader\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Preloader(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Preloader\" является компонентом-заглушкой, который используется, чтобы показать анимацию загрузки в других компонентах,\r\nкогда идет какой-то процесс в них (например, AJAX-запрос).\r\nЭтот компонент подключается в компонентах \"App\", \"ProfileInfo\", \"UsersContainer\", \"WithSuspense\".\r\n*/\r\nconst Preloader = () => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div /*style={{backgroundColor: 'white'}}*/> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <img alt='' src={preloader}/> {/*Отрисовываем элемент \"img\" с изображением анимации загрузки.*/}\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Preloader; /*Экспортируем компонент \"Preloader\" по default, экспорт необходим для импорта.*/","/*\r\nЭтот файл содержит валидаторы для полей и форм. Валидацию можно делать\r\nкак для отдельного поля, так и для всей формы.\r\nМета-данные это дополнительные данные о данных.\r\nБиблиотека redux-form позволяет нам использовать валидаторы, встроенные в нее.\r\nВ нашем проекте добавленя валидация на страница Профиля, Диалогов и Логина.\r\nПри срабатывании указанных здесь валидаторов, \"submit\" формы не сработает.\r\nТо, что возвращают валидаторы попадает в свойство \"error\", которое создается библиотекой \"redux-form\".\r\n*/\r\n\r\n/*Создаем тип для валидаторов.*/\r\nexport type FieldValidatorType = (value: string) => string | undefined; /*Валидатор должен быть функцией, которая\r\nпринимает строковой параметр и возвращает строковой параметр или \"undefined\", то есть ничего.*/\r\n\r\n/*Это валидатор, который проверяет обязательное заполнение поля.*/\r\nexport const required: FieldValidatorType = (value) => { /*При вызове этой функции в нее будет приходить то,\r\nчто находится в поле. Указали, что этот валидатор имеет тип \"FieldValidatorType\".*/\r\n    if (value) return undefined; /*Здесь проверяется имеется ли какое-либо введенное значение в поле, если есть,\r\n    то ничего не происходит.*/\r\n    return \"Field is required\"; /*Если никакого значение не указано в поле, то будет выводится соотвествующее\r\n    информационное сообщение.*/\r\n};\r\n\r\n/*Это валидатор, который проверяет не превышает ли введенный текст в поле максимального количества символов для этого\r\nполя.*/\r\nexport const maxLengthCreator = (maxLength: number): FieldValidatorType => (value) => { /*При вызове этой функции\r\nв нее будет приходить значение, которое обозначает максимальное количество символов для какого-то поля, и то, что\r\nвведено в поле. То здесь одна функция принимает числовой параметр и возвращает другую функцию, то есть наш валидатор,\r\nкоторая имеет тип \"FieldValidatorType\".*/\r\n    if (value.length > maxLength) return `max length is ${maxLength} symbols`; /*Если длина текста в поле больше\r\n    значения, которое обозначает максимальное количество символов для этого поля, то будет выводится соотвествующее\r\n    информационное сообщение.*/\r\n    return undefined; /*Если же длина текста в поле меньше и равна значению, которое обозначает максимальное количество\r\n    символов для этого поля, то ничего не происходит.*/\r\n};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"formControl\":\"FormsControls_formControl__3JtTI\",\"error\":\"FormsControls_error__TpkJB\",\"formSummaryError\":\"FormsControls_formSummaryError__3weeR\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"paginator\":\"Paginator_paginator__3AImP\",\"pageNumber\":\"Paginator_pageNumber__1nPWp\",\"selectedPage\":\"Paginator_selectedPage__5oGX9\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"Header_header__1Xr0A\",\"loginBlock\":\"Header_loginBlock__2NwGC\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sidebar\":\"Sidebar_sidebar__3uksv\",\"active\":\"Sidebar_active__1SmLF\"};","/*\r\nЭто файл \"reducer\", отвечающего за страницу профиля. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {profileAPI, usersAPI} from '../api/api'; /*Импортируем блоки запросов, связанных со страницей профиля\r\nпользователя и связанных со страницей с постраничным выводом пользователей из \"api.ts\".*/\r\nimport {stopSubmit} from 'redux-form'; /*Импортируем специальный AC \"stopSubmit\" из библиотеки \"redux-form\", который\r\nсообщает UI, что что-то пошло не так, и останавливает \"submit\" данных в форме.*/\r\n\r\nimport {PhotosType, PostType, ProfileType} from '../types/types'; /*Импортируем типы.*/\r\nimport {AppStateType} from './redux-store'; /*Импортируем типы.*/\r\nimport {Dispatch} from 'redux'; /*Импортировали из библиотеки \"redux\", чтобы создать тип для \"dispatch\", который\r\nпередается в \"thunks\" и TC.*/\r\nimport {ThunkAction} from 'redux-thunk'; /*Импортировали из библиотеки \"redux-thunk\", чтобы создать тип для \"thunks\".*/\r\n\r\nimport avatarSource from '../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\n\r\n/*\r\nЭто константы для указания значения свойства \"type\" в объекте \"action\".\r\nЭто сделано специально, что не использовать захардкоденные значения в \"AC\" и \"reducers\".\r\nСогласно модульному паттерну \"Redux Ducks\" чтобы избежать случаев одиноковых значений\r\nиз-за чего один и тот же объект \"action\" может сработать в нескольких \"reducers\", в значениях констант для\r\nсвойств \"type\" в объекте \"action\" \"указываются имя-проекта/имя-файла/имя-объекта-action\".\r\n*/\r\nconst ADD_POST = 'react-samurai-01/profile-reducer/ADD-POST'; /*Объект \"action\" для добавления поста на странице\r\nпрофиля.*/\r\nconst SET_USER_PROFILE = 'react-samurai-01/profile-reducer/SET-USER-PROFILE'; /*Объект \"action\" для установки данных\r\nпрофиля пользователя на странице его профиля.*/\r\nconst SET_USER_STATUS = 'react-samurai-01/profile-reducer/SET-USER-STATUS'; /*Объект \"action\" для установки данных\r\nстатуса пользователя на странице его профиля.*/\r\nconst DELETE_POST = 'react-samurai-01/profile-reducer/DELETE-POST'; /*Объект \"action\" для удаления поста на странице\r\nпрофиля. Этот функционал пока еще не реализован в приложении, мы это создали для целей тестирования.*/\r\nconst IS_SAVING_USER_PHOTO_SUCCESSFUL = 'react-samurai-01/profile-reducer/IS-SAVING-USER-PHOTO-SUCCESSFUL'; /*Объект\r\n\"action\" для для установки фото пользователя в приложении на странице его профиля.*/\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    postsData: [ /*Создаем массив объектов, которые хранят информацию о постах на странице профиля.*/\r\n        {id: 1, message: 'Hi, how are you?', likesCount: 2, avatar: avatarSource},\r\n        {id: 2, message: 'It\\'s my first post', likesCount: 3, avatar: avatarSource}\r\n    ] as Array<PostType>, /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"PostType\". Тип\r\n    \"PostType\" был создан нами и импортирован сюда.*/\r\n\r\n    profile: null as ProfileType | null, /*Создаем свойство, которое будет хранить информацию о профиле пользователя,\r\n    полученную с сервера. Имеет тип \"ProfileType\". Тип \"ProfileType\" был создан нами и импортирован сюда.*/\r\n\r\n    status: null as string | null /*Создаем свойство, которое будет хранить информацию о статусе пользователя,\r\n    полученную с сервера. Указываем, что изначально это свойство может иметь тип \"null\", то есть быть пустым, или\r\n    быть строкой. Можно вместо этого просто было указать ''.*/\r\n};\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst profileReducer = (state = initialState, action: ActionsType): InitialStateType => { /*Указываем, что тип\r\n\"state\" на выходе имеет тот же тип \"InitialStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case ADD_POST:\r\n            let newPost = { /*Создаем новый пост в виде объекта.*/\r\n                id: 5, /*Указываем \"ID\" поста.*/\r\n                message: action.newPostText, /*Указываем текст поста.*/\r\n                likesCount: 0, /*Указываем количество лайков у поста.*/\r\n                avatar: avatarSource /*Указываем аватар пользователя, которые будет отрисовываться рядом с постом.*/\r\n            };\r\n            return { /*Добавляем этот новый пост в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                postsData: [...state.postsData, newPost] /*Делаем глубокую копию \"state\". Добавляем данные для нового\r\n                поста в \"state\".*/\r\n            };\r\n\r\n        case SET_USER_PROFILE: /*Устанавливаем данные профиля пользователя на странице его профиля.*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                profile: action.profile /*Устанавливаем данные профиля пользователя в \"state\".*/\r\n            };\r\n\r\n        case SET_USER_STATUS: /*Устанавливаем данные статуса пользователя на странице его профиля.*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                status: action.status /*Устанавливаем данные статуса пользователя в \"state\".*/\r\n            };\r\n\r\n        case DELETE_POST: /*Удаляем пост по его \"ID\".*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                postsData: state.postsData.filter(p => p.id !== action.postID) /*Отфильтруем массив \"postsData\", оставив\r\n                только те элементы, которые не имеют \"ID\" равного \"ID\" из полученного объекта \"action\".*/\r\n            };\r\n\r\n        case IS_SAVING_USER_PHOTO_SUCCESSFUL: /*Устанавливаем ссылки на фото пользователя на странице профиля\r\n        в \"state\".*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                profile: {...state.profile, photos: action.photos} as ProfileType /*Делаем глубокую копию \"state\".\r\n                Добавляем объект со ссылками на фото пользователя на странице профиля в \"state\". Указываем, что объект\r\n                \"profile\" имеет тип \"ProfileType\", созданный нами раннее и импортированный сюда, но такого лучше здесь\r\n                не делать, а делать это в указании типа объектов \"action\", которые с принимает на входе \"reducer\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = AddPostActionCreatorActionType | SetUserProfileActionType | SetUserStatusActionType |\r\n    DeletePostActionCreatorActionType | IsSavingUserPhotoSuccessfulACActionType; /*Здесь мы все созданные раннее типы\r\nдля объектов \"action\" объеденили в один тип.*/\r\n\r\ntype AddPostActionCreatorActionType = { /*Создали тип для объекта \"action\" \"ADD_POST\" на основе самого \"ADD_POST\" при\r\nпомощи \"typeof\". А свойство \"newPostText\" в этом объекте \"action\" должно быть строкой.*/\r\n    type: typeof ADD_POST\r\n    newPostText: string\r\n};\r\n\r\ntype SetUserProfileActionType = { /*Создали тип для объекта \"action\" \"SET_USER_PROFILE\" на основе самого\r\n\"SET_USER_PROFILE\" при помощи \"typeof\". А свойство \"profile\" в этом объекте \"action\" должно быть типа \"ProfileType\",\r\nсозданного нами и импортированного сюда.*/\r\n    type: typeof SET_USER_PROFILE\r\n    profile: ProfileType\r\n};\r\n\r\ntype SetUserStatusActionType = { /*Создали тип для объекта \"action\" \"SET_USER_STATUS\" на основе самого \"SET_USER_STATUS\"\r\nпри помощи \"typeof\". А свойство \"status\" в этом объекте \"action\" должно быть строкой.*/\r\n    type: typeof SET_USER_STATUS\r\n    status: string\r\n};\r\n\r\ntype DeletePostActionCreatorActionType = { /*Создали тип для объекта \"action\" \"DELETE_POST\" на основе самого\r\n\"DELETE_POST\" при помощи \"typeof\". А свойство \"postID\" в этом объекте \"action\" должно быть числом.*/\r\n    type: typeof DELETE_POST\r\n    postID: number\r\n};\r\n\r\ntype IsSavingUserPhotoSuccessfulACActionType = { /*Создали тип для объекта \"action\" \"IS_SAVING_USER_PHOTO_SUCCESSFUL\" на\r\nоснове самого \"IS_SAVING_USER_PHOTO_SUCCESSFUL\" при помощи \"typeof\". А свойство \"photos\" в этом объекте \"action\" должно\r\nбыть типа \"PhotosType\", созданного нами и импортированного сюда.*/\r\n    type: typeof IS_SAVING_USER_PHOTO_SUCCESSFUL\r\n    photos: PhotosType\r\n};\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в \"reducer\".\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в \"reducer\".\r\n*/\r\nexport const addPostActionCreator = (newPostText: string): AddPostActionCreatorActionType => ({ /*AC для добавления\r\nнового поста. Объект \"action\" на выходе имеет тип \"AddPostActionCreatorActionType\". На входе получает \"newPostText\",\r\nкоторое дожно быть строкой.*/\r\n    type: ADD_POST, /*Обязательно свойство \"type\" для AC.*/\r\n    newPostText /*Это равносильно \"newPostText: newPostText\". Создаем свойство, которое содержит текст поста.*/\r\n});\r\n\r\nconst setUserProfile = (profile: ProfileType): SetUserProfileActionType => ({ /*AC для установки данных профиля\r\nпользователя на странице его профиля. Объект \"action\" на выходе имеет тип \"SetUserProfileActionType\". На входе получает\r\n\"profile\", которое дожно быть типа \"ProfileType\", созданного нами и импортированного сюда.*/\r\n    type: SET_USER_PROFILE, /*Обязательно свойство \"type\" для AC.*/\r\n    profile /*Это равносильно \"profile: profile\". Создаем свойство, которое содержит данные профиля пользователя.*/\r\n});\r\n\r\nconst setUserStatus = (status: string): SetUserStatusActionType => ({ /*AC для установки данных статуса пользователя на\r\nстранице его профиля. Объект \"action\" на выходе имеет тип \"SetUserStatusActionType\". На входе получает \"status\",\r\nкоторое дожно быть строкой.*/\r\n    type: SET_USER_STATUS, /*Обязательно свойство \"type\" для AC.*/\r\n    status /*Это равносильно \"status: status\". Создаем свойство, которое содержит данные статуса пользователя на\r\n    странице его профиля.*/\r\n});\r\n\r\nexport const deletePostActionCreator = (postID: number): DeletePostActionCreatorActionType => ({/*AC для добавления\r\nнового поста. Объект \"action\" на выходе имеет тип \"DeletePostActionCreatorActionType\". Этот AC создали специально для\r\nцелей тестирования в \"profile-reducer.test.js\", данный функционал в нашем приложении пока еще не реализован. На входе\r\nполучает \"postID\", которое дожно быть числом.*/\r\n    type: DELETE_POST, /*Обязательно свойство \"type\" для AC.*/\r\n    postID /*Это равносильно \"postID: postID\". Создаем свойство, которое содержит \"ID\" поста для удаления.*/\r\n});\r\n\r\nconst isSavingUserPhotoSuccessfulAC = (photos: PhotosType): IsSavingUserPhotoSuccessfulACActionType => ({ /*AC для\r\nустановки фото пользователя в приложении на странице его профиля. Объект \"action\" на выходе имеет\r\nтип \"IsSavingUserPhotoSuccessfulACActionType\". На входе получает \"photos\", которое дожно быть типа \"PhotosType\",\r\nсозданного нами и импортированного сюда.*/\r\n    type: IS_SAVING_USER_PHOTO_SUCCESSFUL, /*Обязательно свойство \"type\" для AC.*/\r\n    photos /*Это равносильно \"photos: photos\". Создаем свойство, которое содержит объект с ссылками на фото\r\n    пользователя с сервера.*/\r\n});\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype GetStateType = () => AppStateType; /*Создали тип для \"getState()\", который получает \"thunks\" и TC. \"getState()\"\r\nдолжен быть функцией, которая не получает ничего на входе и возвращает объект с типом \"AppStateType\", созданным нами и\r\nимпортированным сюда. Мы это здесь не используем, так как типизация \"thunks\" перекрывает эту типизацию, поскольку\r\nтипизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше,\r\nто есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n\r\ntype DispatchType = Dispatch<ActionsType>; /*Создали тип для \"dispatch\", передается в \"thunks\" и TC. \"dispatch\" должен\r\nбыть \"Dispatch\" из библиотеки \"redux\", работающий с объектами \"action\" тип \"ActionsType\", который мы создали выше.*/\r\n\r\ntype ThunkType = ThunkAction<Promise<void>, AppStateType, unknown, ActionsType> /*Создали тип для \"thunks\". \"thunks\"\r\nдолжны быть объектами \"action\" для \"thunks\" из библиотеки \"redux-thunk\", работающими с:\r\n1) промисами, которые ничего не возвращают (промисы потому, что у нас асинхронные \"thunks\" из-за использования\r\n\"async/await\", хотя обычно \"thunks\" ничего не возвращают);\r\n2) \"state\" с типом \"AppStateType\", созданным нами и импортированным сюда;\r\n3) какими-то неизвестными дополнительными аргументами;\r\n4) объектами \"action\" тип \"ActionsType\", который мы создали выше.\r\nЭти уточнения мы нашли в файле декларации \"ThunkAction\", \"Ctrl+click\" в \"WebStorm\".\r\n*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const getUserProfile = (userID: number): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных по профилю пользователя на странице профиля. Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает \"ID\"\r\nпользователя, которое должно быть числом. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await usersAPI.getUserProfile(userID); /*Делаем запрос на сервер для получения данных по профилю\r\n    пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в\r\n    \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу\r\n    писать логику по работе с ответом от сервера.*/\r\n\r\n    dispatch(setUserProfile(response.data)); /*Получив ответ от сервера, при помощи AC \"setUserProfile\" устанавливаем\r\n    данные по профилю пользователя в \"state\".*/\r\n};\r\n\r\nexport const getUserStatus = (userID: number): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных по статусу пользователя на странице профиля. Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает \"ID\"\r\nпользователя, которое должно быть числом. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await profileAPI.getUserStatus(userID); /*Делаем запрос на сервер для получения данных по статусу\r\n    пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в\r\n    \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу\r\n    писать логику по работе с ответом от сервера.*/\r\n\r\n    dispatch(setUserStatus(response.data)); /*Получив ответ от сервера, при помощи AC \"setUserStatus\" устанавливаем\r\n    данные по статусу пользователя в \"state\".*/\r\n};\r\n\r\nexport const updateUserStatus = (status: string): ThunkType => async (dispatch) => {\r\n/*Это TC для изменения данных по статусу пользователя на странице профиля. Здесь вместо использования \".then\" мы\r\nиспользуем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает статус\r\nпользователя, который должно быть строкой. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    try { /*Используем \"try-catch\".*/\r\n        const response = await profileAPI.updateUserStatus(status); /*Делаем запрос на сервер для изменения данных по\r\n        статусу пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он\r\n        сохраниться в \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис,\r\n        то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n        if (response.data.resultCode === 0) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\" (т.е.\r\n        операция прошла успешно), то диспатчим AC \"setUserStatus\" для установки нового статуса пользователя\r\n        в приложении, передав в этот AC данные по статусу пользователя с сервера.*/\r\n            dispatch(setUserStatus(status));\r\n        }\r\n    } catch (error) { /*Если во время выполнения блока \"try\" произошла ошибка, вместо краша приложения будет выведено\r\n    сообщение, что была какая-то ошибка.*/\r\n        alert(error);\r\n    }\r\n};\r\n\r\nexport const saveUserPhoto = (photoFile: any): ThunkType => async (dispatch) => {\r\n/*Это TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении. Здесь\r\nвместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC\r\nасинхронным. На входе принимает объект с фото пользователя, которое типа \"any\", так как пока мы конкретно не знаем\r\nкакого он будет типа. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы\r\nмогли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC,\r\nто есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\",\r\n\"getState()\" и дополнительные аргументы.*/\r\n    const response = await profileAPI.saveUserPhoto(photoFile); /*Делаем запрос на сервер для загрузки фото пользователя\r\n    и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь\r\n    \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу писать логику\r\n    по работе с ответом от сервера.*/\r\n\r\n    if (response.data.resultCode === 0) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\" (т.е.\r\n    операция прошла успешно), то диспатчим AC \"isSavingUserPhotoSuccessfulAC\" для установки фото пользователя\r\n    в приложении, передав в этот AC объект с ссылками на фото пользователя с сервера.*/\r\n        dispatch(isSavingUserPhotoSuccessfulAC(response.data.data.photos));\r\n    }\r\n};\r\n\r\nexport const saveProfile = (profile: ProfileType) => async (dispatch: any, getState: any) => { /*Это TC для отправки\r\nновых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем приложении. В \"thunk\" тут\r\nтакже приходит функция \"getState()\" для получения \"state\". Здесь вместо использования \".then\" мы используем\r\n\"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает профиль пользователя,\r\nкоторый должно быть типа \"ProfileType\", созданного нами и импортированного сюда. Также на входе принимает \"dispatch\" и\r\n\"getState\" типа \"any\", так как пока мы конкретно не знаем какого они будут типа.*/\r\n    const userID = getState().auth.id; /*Получаем \"ID\" залогиненного пользователя при помощи функции \"getState()\".*/\r\n    const response = await profileAPI.saveProfile(profile); /*Делаем запрос на сервер отправки новых данных профиля\r\n    пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться\r\n    в \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно\r\n    сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.data.resultCode === 0) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\" (т.е.\r\n    операция прошла успешно), то диспатчим TC \"getUserProfile\" для запроса и установки данных по профилю пользователя\r\n    на странице профиля, передав в этот TC \"ID\" залогиненного пользователя.*/\r\n        dispatch(getUserProfile(userID));\r\n    } else { /*Иначе если в ответе от сервера в свойстве \"resultCode\" не указано \"0\" (т.е. операция не прошла успешно),\r\n    то*/\r\n        dispatch(stopSubmit('editProfile', {_error: response.data.messages[0]})); /*Задиспатчим специальный\r\n        AC \"stopSubmit()\" из библиотеки \"redux-form\", который сообщит UI, что что-то пошло не так, и остановит\r\n        \"submit\" данных. Первым параметром указывается какую форму необходимо остановить, а вторым параметром\r\n        указывается объект, в котором должно быть свойство \"_error\" (из библиотеки \"redux-form\", означает ошибку\r\n        для всей формы, но здесь можно использовать и имена других полей, которые мы создали), которому\r\n        присваивается значение с текстом ошибки (в ответе от сервера в данном случае).\r\n\r\n        Но сейчас со \"stopSubmit\" проблемы. При его использовании возникает проблема асинхроности, так как\r\n        библиотека \"redux-form\" вызывает \"setSubmitSuccessed()\" сразу после \"stopSubmit()\", не успев вернуть ошибку.\r\n        Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно использовать\r\n        такой костыль:\r\n        setTimeout(async () => await dispatch(stopSubmit('editProfile', {_error: response.data.messages[0]})))\r\n\r\n        Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки \"redux-form\" (8.3.6).*/\r\n        return Promise.reject(response.data.messages[0]); /*И поскольку будет какая-то ошибка на сервера, то промис\r\n        будет в состоянии ожидании, соотвественно мы его прерываем, указав текст ошибки. Это нужно, чтобы не произошло\r\n        деактивации режима редактирования профиля пользователя в callback \"onSubmit\", который создан нами в компоненте\r\n        \"ProfileInfo\" в файле \"ProfileInfo.jsx\".*/\r\n    }\r\n};\r\n\r\n\r\nexport default profileReducer; /*Экспортируем \"profileReducer\" по default, экспорт необходим для импорта.*/"],"sourceRoot":""}