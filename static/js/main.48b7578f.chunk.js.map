{"version":3,"sources":["components/common/Paginator/Paginator.module.css","components/Navbar/Sidebar/Sidebar.module.css","api/profile-api.ts","redux/profile-reducer.ts","api/api.ts","redux/dialogs-reducer.ts","api/chat-api.ts","redux/chat-reducer.ts","assets/images/user.png","components/common/Preloader/Preloader.module.css","components/Header/Header.module.css","components/Navbar/Navbar.module.css","components/Users/User.module.css","serviceWorker.js","api/auth-api.ts","api/security-api.ts","redux/auth-reducer.ts","redux/auth-selectors.ts","assets/images/headerlogo.png","components/Header/Header.tsx","redux/sidebar-selectors.ts","components/Navbar/Sidebar/Sidebar.tsx","components/Navbar/Navbar.tsx","api/users-api.ts","utils/helpers/object-helpers.ts","redux/users-reducer.ts","components/common/Paginator/Paginator.tsx","components/Users/User.tsx","redux/users-selectors.ts","components/Users/UsersSearchForm.tsx","components/Users/Users.tsx","components/Music/Music.tsx","components/News/News.tsx","components/Settings/Settings.tsx","components/Friends/Friends.tsx","components/Login/Login.tsx","hoc/WithSuspense.tsx","redux/sidebar-reducer.ts","redux/app-reducer.ts","redux/redux-store.ts","App.tsx","index.js","components/common/FormsControls/FormsControls.tsx","assets/images/preloader.gif","components/common/Preloader/Preloader.tsx","utils/validators/validators.ts","components/common/FormsControls/FormsControls.module.css"],"names":["module","exports","profileAPI","userID","instance","get","then","response","data","status","put","photoFile","formData","FormData","append","profile","initialState","postsData","id","message","likesCount","avatar","avatarSource","profileAC","addPost","newPostText","type","setUserProfile","setUserStatus","deletePostActionCreator","postID","isSavingUserPhotoSuccessfulAC","photos","getUserProfile","dispatch","a","getUserStatus","updateUserStatus","resultCode","ResultCodeEnum","Success","alert","saveUserPhoto","saveProfile","getState","auth","Error","stopSubmit","_error","messages","Promise","reject","profileReducer","state","action","newPost","filter","p","ResultCodeForCaptchaEnum","axios","create","withCredentials","baseURL","headers","dialogs","name","messagesData","incomingMessagesData","dialogsAC","addMessage","newMessageText","dialogsReducer","newMessage","ws","notifySubscribersAboutWSStatus","WSStatus","subscribers","forEach","s","closeEventHandler","setTimeout","createWSChannel","messageEventHandler","event","newChatMessages","JSON","parse","openEventHandler","errorEventHandler","removeEvents","removeEventListener","close","WebSocket","addEventListener","chatAPI","WSEvent","callback","push","chatMessage","send","chatMessages","chatAC","_newChatMessagesHandler","newChatMessagesHandlerCreator","_WSStatusChangingHandler","WSStatusChangingHandlerCreator","startGettingChatMessages","stopGettingChatMessages","sendChatMessage","chatReducer","map","m","v1","index","array","length","Boolean","window","location","hostname","match","authAPI","email","password","rememberMe","captcha","post","delete","securityAPI","login","isAuth","captchaURL","authAC","payload","getAuthUserData","getCaptchaURL","url","authReducer","getIsAuth","getLogin","Header","props","Layout","useSelector","useDispatch","className","styles","header","span","src","headerLogoSource","alt","preview","theme","mode","Item","to","icon","UserOutlined","href","onClick","offset","getSidebar","sidebar","SideBar","path","activeClassName","active","Navbar","sidebarElements","friendsData","f","SubMenu","Menu","Sider","subMenuKey","getSubMenuKey","key","pop","pathname","getSubMenuKeyCallback","menu","selectedKeys","openKeys","title","onTitleClick","ProfileOutlined","MessageOutlined","HeartOutlined","TeamOutlined","CommentOutlined","BuildOutlined","AlertOutlined","ThunderboltOutlined","ToolOutlined","usersAPI","getUsers","currentPage","pageSize","term","friend","unfollow","follow","updateObjectInArray","items","itemID","objPropName","newObjProps","u","users","totalUsersCount","isFetching","WhoIsInFollowingProgress","portionSize","usersAC","count","isFollowingInProgress","requestUsers","totalCount","_followUnfollowFlow","apiMethod","actionCreator","usersReducer","followed","Paginator","totalItemsCount","onPageChange","pagesCount","Math","ceil","pages","i","portionCount","useState","currentPortionNumber","setCurrentPortionNumber","lowerBoundOfCurrentPortion","upperBoundOfCurrentPortion","paginator","cn","selectedPage","pageNumber","e","User","user","small","userPhoto","disabled","some","createSelector","usersPage","getPageSize","getPortionSize","getTotalUsersCount","getCurrentPage","getIsFetching","getWhoIsInFollowingProgress","getUsersFilter","usersSearchFormValidate","values","UsersSearchForm","React","memo","onFilterChange","enableReinitialize","initialValues","String","validate","onSubmit","setSubmitting","isSubmitting","as","value","Users","isNotJustCreated","setIsNotJustCreated","isJustCreated","setIsJustCreated","useEffect","history","useHistory","search","substr","parsed","queryString","actualCurrentPage","actualFilter","page","Number","query","unfollowCallback","bind","followCallback","Preloader","Music","News","Settings","Friends","maxLength30","maxLengthCreator","LoginReduxForm","reduxForm","form","handleSubmit","error","createField","Input","required","undefined","style","formSummaryError","Login","CaptchaIsRequired","withSuspense","Component","fallback","sidebarReducer","initialized","appAC","appReducer","rootReducer","combineReducers","profilePage","dialogsPage","formReducer","app","chat","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","store","createStore","applyMiddleware","thunkMiddleWare","__store__","DialogsContainer","lazy","ProfileContainer","ChatPage","ProfileContainerWithSuspense","ChatPageWithSuspense","App","this","initializeApp","Content","Footer","exact","render","AppContainer","withRouter","connect","promise","all","AppMain","ReactDOM","StrictMode","document","getElementById","navigator","serviceWorker","ready","registration","unregister","catch","console","FormControl","meta","touched","children","hasError","formControl","Textarea","input","restProps","placeholder","component","validators","text","preloader","maxLength"],"mappings":"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","file":"static/js/main.48b7578f.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"paginator\":\"Paginator_paginator__3AImP\",\"pageNumber\":\"Paginator_pageNumber__1nPWp\",\"selectedPage\":\"Paginator_selectedPage__5oGX9\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"sidebar\":\"Sidebar_sidebar__3uksv\",\"active\":\"Sidebar_active__1SmLF\"};","/*\r\nЭтот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер, касающиеся страницы профиля, чтобы\r\nкомпоненты не создавали \"side effects\" такого типа. Этот файл отвечает за \"DAL\" - \"Data Access Layer\".\r\n*/\r\n\r\nimport {instance, ResponseWithDataType} from './api'; /*Импортируем \"instance\" для более быстрого создания запросов.\r\nТакже импортируем \"ResultCodeEnum\" - список кодов ответа от сервера, которые используются в TC \"getAuthUserData\" и в TC\r\n\"login\" в \"auth-reducer.ts\", для осуществления типизации. В добавок импортируем общий тип \"ResponseWithDataType\" для\r\nнекоторых ответов от сервера со схожей структурой ответа.*/\r\n\r\nimport {PhotosType, ProfileType} from '../types/types'; /*Подключаем типы.*/\r\n\r\n\r\ntype SaveUserPhotoResponseDataType = { /*Создали отдельный тип для \"data\" для запроса \"saveUserPhoto\" из \"profileAPI\".\r\nИспользуется для уточнения в типе \"ResponseType\". Этот объект \"data\" должен содержать информацию о фото пользователя.*/\r\n    photos: PhotosType /*Объект с фото пользователя должно быть типа \"PhotosType\", который мы создали ниже.*/\r\n    small: string | null /*Путь к уменьшенной версии фото пользователя должен быть строкой или \"null\" (то есть\r\n        быть пустым). Это свойство видимо добавлено на сервере ошибочно, так как дублирует часть объекта \"photos\".*/\r\n    large: string | null /*Путь к увеличенной версии фото пользователя должен быть строкой или \"null\" (то есть\r\n        быть пустым). Это свойство видимо добавлено на сервере ошибочно, так как дублирует часть объекта \"photos\".*/\r\n};\r\n\r\n\r\nexport const profileAPI = { /*\"usersAPI\" содержит запросы, связанные со страницей профиля пользователя.*/\r\n    getUserProfile(userID: number) { /*Эта функция является запросом на получение данных профиля пользователя для\r\n    страницы профиля. Данная функция принимает один параметр в виде \"ID\" пользователя, который должен быть числом.*/\r\n        return (\r\n            instance.get<ProfileType>(`profile/${userID}`) /*Указываем, что добавляем к базовому URL, указанному в\r\n            \"instance\", чтобы получить данные профиля пользователя. Указали, что этот запрос \"GET\" возвращает промис с\r\n            типом \"ProfileType\", который был создан нами и импортирован сюда.*/\r\n                .then(response => { /*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". Данные придут от сервера и будут находиться внутри \"response.data\". Эта\r\n                \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных в\r\n                \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    \"aboutMe\" - информация \"обо мне\" (на сайте API этого нет, но на самом деле на сервере это поле\r\n                    имеется).\r\n                    \"contacts\": - контакты.\r\n                        \"github\"\r\n                        \"vk\"\r\n                        \"facebook\"\r\n                        \"instagram\"\r\n                        \"twitter\"\r\n                        \"website\"\r\n                        \"youtube\"\r\n                        \"mainLink\".\r\n                    \"fullName\" - полное имя.\r\n                    \"lookingForAJob\" - ищет ли работу.\r\n                    \"lookingForAJobDescription\" - какую ищет работу.\r\n                    \"photos\": - фото.\r\n                        \"small\"\r\n                        \"large\".\r\n                    \"userId\" - \"ID\" пользователя.*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы установить их в наш \"state\" при помощи TC \"getUserProfile\" в \"profile-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    getUserStatus(userID: number) { /*Эта функция является запросом на получение данных статуса пользователя для\r\n    страницы профиля. Данная функция принимает один параметр в виде \"ID\" пользователя, который должен быть числом.*/\r\n        return (\r\n            instance.get<string>(`profile/status/${userID}`) /*Указываем, что добавляем к базовому URL, указанному\r\n            в \"instance\", чтобы получить данные статуса пользователя. Указали, что этот запрос \"GET\" возвращает промис\r\n            с типом строки.*/\r\n                .then(response => { /*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". Данные придут от сервера и будут находиться внутри \"response.data\". Эта\r\n                \"data\" создается самим запросом и туда помещается информация от сервера. Сама же структура данных в\r\n                \"data\" определяется сервером. Согласно API сервера там находится текст статуса пользователя (хотя было\r\n                бы лучше, чтобы данные приходили в формате JSON, то есть в данном случае не возвращается объект со\r\n                свойствами, как это происходит в других запросах).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы установить их в наш \"state\" при помощи TC \"getUserStatus\" в \"profile-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    updateUserStatus(status: string) { /*Эта функция является запросом на изменение данных статуса пользователя для\r\n    страницы профиля на сервере. Данная функция принимает один параметр в виде строки с информацией из статуса.\r\n    Согласно API сервера максимальная длинна статуса 300 символов в формате JSON.*/\r\n        return (\r\n            instance.put<ResponseWithDataType>(`profile/status`, {status: status}) /*Указываем, что добавляем\r\n            к базовому URL, указанному в \"instance\", чтобы отправить на сервер новые данные статуса пользователя.\r\n            А также указываем объект с этими данными. Указали, что этот запрос \"PUT\" возвращает промис с типом\r\n            \"ResponseType\".*/\r\n                .then(response => {/*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". В ответ на этот запрос к нам придут данные, которые будут находиться\r\n                внутри \"response.data\". Эта \"data\" создается самим запросом и туда помещается информация от сервера.\r\n                Сама же структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    - \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя, \"0\" - все хорошо,\r\n                    \"1\" - какая-то ошибка.\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время обновления статуса пользователя).\r\n                    - \"data\" - какие-то дополнительные данные (в данный момент не используется).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы установить их в наш \"state\" при помощи TC \"updateUserStatus\" в \"profile-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    saveUserPhoto(photoFile: File) { /*Эта функция является запросом на загрузку фото пользователя на сервер. Данная\r\n    функция принимает один параметр в виде файла. Тип этого файла указан как \"File\" из \"TypeScript\".*/\r\n        const formData = new FormData();\r\n        formData.append(\"image\", photoFile); /*Поскольку здесь мы передаем не просто JSON-данные, а изображение,\r\n        то поэтому формируем специальный объект при помощи \"FormData()\". При помощи метода \"append\" добавляем в этот\r\n        объект файл с фото. \"image\" - так указывается согласно API сервера. Третьим параметром отправляется объект\r\n        со специфическими заголовками, но в данном случае и без них все работает.*/\r\n        return (\r\n            instance.put<ResponseWithDataType<SaveUserPhotoResponseDataType>>\r\n            (`profile/photo`, formData/*, {headers: {'Content-Type': 'multipart/form-data'}}*/) /*Указываем, что\r\n            добавляем к базовому URL, указанному в \"instance\", чтобы отправить на сервер фото пользователя. А также\r\n            указываем объект с этим фото. Указали, что этот запрос \"PUT\" возвращает промис с типом\r\n            \"ResponseType<SaveUserPhotoResponseDataType>\".*/\r\n                .then(response => { /*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". В ответ на этот запрос к нам придут данные, которые будут находиться\r\n                внутри \"response.data\". Эта \"data\" создается самим запросом и туда помещается информация от сервера.\r\n                Сама же структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    - \"resultCode\" - код, означающий успешно ли прошла загрузка фото пользователя, \"0\" - все хорошо,\r\n                    другие числа - какая-то ошибка.\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время загрузки фото).\r\n                    - \"data\" - дополнительные данные, в которых содержится еще один объект \"photos\", который в свою\r\n                    очередь имеет еще два свойства:\r\n                        1) \"small\" - URL фото в маленьком размере, если отсутствует, то будет \"NULL\".\r\n                        2) \"large\" - URL фото в большом размере, если отсутствует, то будет \"NULL\".\r\n                    Помимо наличия объекта \"photos\", \"data\" имеет также свои свойства \"small\" и \"large\", копирующие\r\n                    аналогичные свойства у объекта \"photos\". Предположительно это ошибочно добавили на сервере.*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы установить их в наш \"state\" при помощи TC \"saveUserPhoto\" в \"profile-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    saveProfile(profile: ProfileType) { /*Эта функция является запросом на отправку новых данных профиля пользователя\r\n    на сервер. Данная функция принимает один параметр в виде объекта с данными типа \"ProfileType\", который создан был\r\n    нами и импортирован сюда. Согласно API сервера в этом объекте должно находится следующее:\r\n            \"aboutMe\" - информация \"обо мне\" (на сайте API этого нет, но на самом деле на сервере это поле имеется).\r\n            \"contacts\": - контакты.\r\n                \"github\"\r\n                \"vk\"\r\n                \"facebook\"\r\n                \"instagram\"\r\n                \"twitter\"\r\n                \"website\"\r\n                \"youtube\"\r\n                \"mainLink\".\r\n            \"fullName\" - полное имя.\r\n            \"lookingForAJob\" - ищет ли работу.\r\n            \"lookingForAJobDescription\" - какую ищет работу.\r\n            \"photos\": - фото.\r\n                \"small\"\r\n                \"large\".\r\n            \"userId\" - \"ID\" пользователя.*/\r\n        return (\r\n            instance.put<ResponseWithDataType>(`profile`, profile) /*Указываем, что добавляем к базовому URL,\r\n            указанному в \"instance\", чтобы отправить на сервер новые данные профиля пользователя. А также указываем\r\n            объект с этими данными. Указали, что этот запрос \"PUT\" возвращает промис с типом \"ResponseType\".*/\r\n                .then(response => {/*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". В ответ на этот запрос к нам придут данные, которые будут находиться\r\n                внутри \"response.data\". Эта \"data\" создается самим запросом и туда помещается информация от сервера.\r\n                Сама же структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    - \"resultCode\" - код, означающий успешно ли прошла отправка новых данных профиля пользователя, \"0\" -\r\n                    все хорошо, другие числа - какая-то ошибка.\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время отправки новых данных профиля пользователя).\r\n                    - \"data\" - какие-то дополнительные данные (в данный момент не используется).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы установить их в наш \"state\" при помощи TC \"saveProfile\" в \"profile-reducer.ts\".*/\r\n                })\r\n        );\r\n    }\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за страницу профиля. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {profileAPI} from '../api/profile-api'; /*Импортируем блоки запросов, связанных со страницей профиля\r\nпользователя.*/\r\n\r\nimport {FormAction, stopSubmit} from 'redux-form'; /*Импортируем специальный AC \"stopSubmit\" из библиотеки \"redux-form\",\r\nкоторый сообщает UI, что что-то пошло не так, и останавливает \"submit\" данных в форме. Импортировали \"FormAction\", чтобы\r\nсоздать тип для объектов \"action\", который передается в \"thunks\" и TC.*/\r\n\r\nimport {ResultCodeEnum} from '../api/api'; /*Импортируем списки кодов ответов от сервера.*/\r\n\r\nimport {PhotosType, PostType, ProfileType} from '../types/types'; /*Подключаем типы.*/\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store'; /*Подключаем типы.*/\r\n\r\nimport avatarSource from '../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialProfileStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    postsData: [ /*Создаем массив объектов, которые хранят информацию о постах на странице профиля.*/\r\n        {id: 1, message: 'Hi, how are you?', likesCount: 2, avatar: avatarSource},\r\n        {id: 2, message: 'It\\'s my first post', likesCount: 3, avatar: avatarSource}\r\n    ] as Array<PostType>, /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"PostType\". Тип\r\n    \"PostType\" был создан нами и импортирован сюда.*/\r\n\r\n    profile: null as ProfileType | null, /*Создаем свойство, которое будет хранить информацию о профиле пользователя,\r\n    полученную с сервера. Имеет тип \"ProfileType\" или может иметь тип \"null\", то есть быть пустым. Тип \"ProfileType\" был\r\n    создан нами и импортирован сюда.*/\r\n\r\n    status: null as string | null /*Создаем свойство, которое будет хранить информацию о статусе пользователя,\r\n    полученную с сервера. Указываем, что изначально это свойство может иметь тип \"null\", то есть быть пустым, или\r\n    быть строкой. Можно вместо этого просто было указать ''.*/\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst profileReducer = (state = initialState, action: ActionsType): InitialProfileStateType => { /*Указываем, что\r\nтип \"state\" на выходе имеет тот же тип \"InitialProfileStateType\", что и \"state\" на входе. На входе объекты \"action\"\r\nимеют тип \"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case 'demo-spa/profile-reducer/ADD-POST': /*Добавляем новый пост на страницу профиля пользователя.*/\r\n            let newPost = { /*Создаем новый пост в виде объекта.*/\r\n                id: 5, /*Указываем \"ID\" поста.*/\r\n                message: action.newPostText, /*Указываем текст поста.*/\r\n                likesCount: 0, /*Указываем количество лайков у поста.*/\r\n                avatar: avatarSource /*Указываем аватар пользователя, которые будет отрисовываться рядом с постом.*/\r\n            };\r\n            return { /*Добавляем этот новый пост в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                postsData: [...state.postsData, newPost] /*Делаем глубокую копию \"state\". Добавляем данные для нового\r\n                поста в \"state\".*/\r\n            };\r\n\r\n        case 'demo-spa/profile-reducer/SET-USER-PROFILE': /*Устанавливаем данные профиля пользователя на странице его\r\n        профиля.*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                profile: action.profile /*Устанавливаем данные профиля пользователя в \"state\".*/\r\n            };\r\n\r\n        case 'demo-spa/profile-reducer/SET-USER-STATUS': /*Устанавливаем данные статуса пользователя на странице его\r\n        профиля.*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                status: action.status /*Устанавливаем данные статуса пользователя в \"state\".*/\r\n            };\r\n\r\n        case 'demo-spa/profile-reducer/DELETE-POST': /*Удаляем пост по его \"ID\".*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                postsData: state.postsData.filter(p => p.id !== action.postID) /*Отфильтруем массив \"postsData\", оставив\r\n                только те элементы, которые не имеют \"ID\" равного \"ID\" из полученного объекта \"action\".*/\r\n            };\r\n\r\n        case 'demo-spa/profile-reducer/IS-SAVING-USER-PHOTO-SUCCESSFUL': /*Устанавливаем ссылки на фото пользователя на\r\n        странице профиля в \"state\".*/\r\n            return {\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                profile: {...state.profile, photos: action.photos} as ProfileType /*Делаем глубокую копию \"state\".\r\n                Добавляем объект со ссылками на фото пользователя на странице профиля в \"state\". Указываем, что объект\r\n                \"profile\" имеет тип \"ProfileType\", созданный нами раннее и импортированный сюда, но такого лучше здесь\r\n                не делать, а делать это в указании типа объектов \"action\", которые с принимает на входе \"reducer\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InferActionsTypes<typeof profileAC>; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип \"InferActionsTypes\" для\r\nопределения типов всех объектов \"action\" у упакованных в единый объект \"profileAC\" AC.*/\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в \"reducer\".\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в \"reducer\".\r\n*/\r\nexport const profileAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные\r\nраннее на основе каждого AC. Также вверху удалили все константы со значениями для \"type\" и указывываем их сразу в AC,\r\nтак как \"TypeScript\" не даст нам допустить ошибку при указании этих \"types\" в \"reducer\". Согласно модульному паттерну\r\n\"Redux Ducks\", чтобы избежать случаев одиноковых значений свойств \"type\" из-за чего один и тот же объект \"action\" может\r\nсработать в нескольких \"reducers\", в значениях свойств \"type\" в объекте \"action\" указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\". Также в конце везде добавили \"as const\", чтобы \"reducer\" адекватно\r\nвоспринимал объекты \"action\". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных\r\nтипов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/\r\n    addPost: (newPostText: string) => ({ /*AC для добавления нового поста. На входе получает \"newPostText\",\r\n    которое дожно быть строкой.*/\r\n        type: 'demo-spa/profile-reducer/ADD-POST', /*Обязательно свойство \"type\" для AC.*/\r\n        newPostText /*Это равносильно \"newPostText: newPostText\". Создаем свойство, которое содержит текст поста.*/\r\n    } as const),\r\n\r\n    setUserProfile: (profile: ProfileType) => ({ /*AC для установки данных профиля пользователя на странице его профиля.\r\n    На входе получает \"profile\", которое дожно быть типа \"ProfileType\", созданного нами и импортированного сюда.*/\r\n        type: 'demo-spa/profile-reducer/SET-USER-PROFILE', /*Обязательно свойство \"type\" для AC.*/\r\n        profile /*Это равносильно \"profile: profile\". Создаем свойство, которое содержит данные профиля пользователя.*/\r\n    } as const),\r\n\r\n    setUserStatus: (status: string) => ({ /*AC для установки данных статуса пользователя на странице его профиля. На\r\n    входе получает \"status\", которое дожно быть строкой.*/\r\n        type: 'demo-spa/profile-reducer/SET-USER-STATUS', /*Обязательно свойство \"type\" для AC.*/\r\n        status /*Это равносильно \"status: status\". Создаем свойство, которое содержит данные статуса пользователя на\r\n        странице его профиля.*/\r\n    } as const),\r\n\r\n    deletePostActionCreator: (postID: number) => ({/*AC для добавления нового поста. Этот AC создали специально для\r\n    целей тестирования в \"profile-reducer.test.ts\", данный функционал в нашем приложении пока еще не реализован. На\r\n    входе получает \"postID\", которое дожно быть числом.*/\r\n        type: 'demo-spa/profile-reducer/DELETE-POST', /*Обязательно свойство \"type\" для AC.*/\r\n        postID /*Это равносильно \"postID: postID\". Создаем свойство, которое содержит \"ID\" поста для удаления.*/\r\n    } as const),\r\n\r\n    isSavingUserPhotoSuccessfulAC: (photos: PhotosType) => ({ /*AC для установки фото пользователя в приложении на\r\n    странице его профиля. На входе получает \"photos\", которое дожно быть типа \"PhotosType\", созданного нами и\r\n    импортированного сюда.*/\r\n        type: 'demo-spa/profile-reducer/IS-SAVING-USER-PHOTO-SUCCESSFUL', /*Обязательно свойство \"type\" для AC.*/\r\n        photos /*Это равносильно \"photos: photos\". Создаем свойство, которое содержит объект с ссылками на фото\r\n        пользователя с сервера.*/\r\n    } as const)\r\n};\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype ThunkType = BaseThunkType<ActionsType | FormAction>; /*Создали тип для \"thunks\". Поскольку в TC\r\n\"login\" мы диспатчим \"stopSubmit\" из библиотеки \"redux-form\", поэтому здесь мы указали еще \"FormAction\" из библиотеки\r\n\"redux-form\", так как в файле декларации \"stopSubmit\" указано, что он \"extends\" от \"FormAction\". Но из-за этого теперь\r\nмы можем диспатчить любой объект \"action\", что естественно нежелательно для нас.*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const getUserProfile = (userID: number): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных по профилю пользователя на странице профиля. Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает \"ID\"\r\nпользователя, которое должно быть числом. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await profileAPI.getUserProfile(userID); /*Делаем запрос на сервер для получения данных по профилю\r\n    пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в\r\n    \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу\r\n    писать логику по работе с ответом от сервера.*/\r\n\r\n    dispatch(profileAC.setUserProfile(response)); /*Получив ответ от сервера, при помощи AC \"setUserProfile\"\r\n    устанавливаем данные по профилю пользователя в \"state\".*/\r\n};\r\n\r\nexport const getUserStatus = (userID: number): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных по статусу пользователя на странице профиля. Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает \"ID\"\r\nпользователя, которое должно быть числом. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await profileAPI.getUserStatus(userID); /*Делаем запрос на сервер для получения данных по статусу\r\n    пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в\r\n    \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу\r\n    писать логику по работе с ответом от сервера.*/\r\n\r\n    dispatch(profileAC.setUserStatus(response)); /*Получив ответ от сервера, при помощи AC \"setUserStatus\" устанавливаем\r\n    данные по статусу пользователя в \"state\".*/\r\n};\r\n\r\nexport const updateUserStatus = (status: string): ThunkType => async (dispatch) => {\r\n/*Это TC для изменения данных по статусу пользователя на странице профиля. Здесь вместо использования \".then\" мы\r\nиспользуем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает статус\r\nпользователя, который должно быть строкой. Также этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    try { /*Используем \"try-catch\".*/\r\n        const response = await profileAPI.updateUserStatus(status); /*Делаем запрос на сервер для изменения данных по\r\n        статусу пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он\r\n        сохраниться в \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис,\r\n        то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n        if (response.resultCode === ResultCodeEnum.Success) { /*Если в ответе от сервера в свойстве \"resultCode\" указано\r\n        \"0\" (т.е. операция прошла успешно), то диспатчим AC \"setUserStatus\" для установки нового статуса пользователя в\r\n        приложении, передав в этот AC данные по статусу пользователя с сервера.*/\r\n            dispatch(profileAC.setUserStatus(status));\r\n        }\r\n    } catch (error) { /*Если во время выполнения блока \"try\" произошла ошибка, вместо краша приложения будет выведено\r\n    сообщение, что была какая-то ошибка.*/\r\n        alert(error);\r\n    }\r\n};\r\n\r\nexport const saveUserPhoto = (photoFile: File): ThunkType => async (dispatch) => {\r\n/*Это TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем приложении. Здесь\r\nвместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC\r\nасинхронным. На входе принимает объект с фото пользователя, которое типа \"File\" из \"TypeScript\". Также этот TC на выходе\r\nвозвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\",\r\n\"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали,\r\nчто в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await profileAPI.saveUserPhoto(photoFile); /*Делаем запрос на сервер для загрузки фото пользователя\r\n    и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь\r\n    \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу писать логику\r\n    по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === ResultCodeEnum.Success) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\"\r\n    (т.е. операция прошла успешно), то диспатчим AC \"isSavingUserPhotoSuccessfulAC\" для установки фото пользователя в\r\n    приложении, передав в этот AC объект с ссылками на фото пользователя с сервера.*/\r\n        dispatch(profileAC.isSavingUserPhotoSuccessfulAC(response.data.photos));\r\n    }\r\n};\r\n\r\nexport const saveProfile = (profile: ProfileType): ThunkType =>\r\n    async (dispatch, getState) => {\r\n/*Это TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их отображения в нашем\r\nприложении. В \"thunk\" тут также приходит функция \"getState()\" для получения \"state\". Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. На входе принимает профиль\r\nпользователя, который должно быть типа \"ProfileType\", созданного нами и импортированного сюда. Также этот TC на выходе\r\nвозвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\",\r\n\"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали,\r\nчто в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const userID = getState().auth.id; /*Получаем \"ID\" залогиненного пользователя при помощи функции \"getState()\".*/\r\n    const response = await profileAPI.saveProfile(profile); /*Делаем запрос на сервер отправки новых данных профиля\r\n    пользователя и ждем ответа от сервера. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться\r\n    в \"response\". Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно\r\n    сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === ResultCodeEnum.Success) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\"\r\n    (т.е. операция прошла успешно), то диспатчим TC \"getUserProfile\" для запроса и установки данных по профилю\r\n    пользователя на странице профиля, передав в этот TC \"ID\" залогиненного пользователя.*/\r\n        if (userID !== null) { /*Внутри здесь делаем проверку, чтобы \"userID\" не был \"null\", так как \"TypeScript\" пишет\r\n        ошибку.*/\r\n            dispatch(getUserProfile(userID));\r\n        } else { /*Если же окажется, что \"userID\" все-таки равен \"null\", то будет выведена ошибка, что \"userID\" не может\r\n        быть \"null\".*/\r\n            throw new Error('userID cannot be null');\r\n        }\r\n    } else { /*Иначе если в ответе от сервера в свойстве \"resultCode\" не указано \"0\" (т.е. операция не прошла успешно),\r\n    то*/\r\n        dispatch(stopSubmit('editProfile', {_error: response.messages[0]})); /*Задиспатчим специальный\r\n        AC \"stopSubmit()\" из библиотеки \"redux-form\", который сообщит UI, что что-то пошло не так, и остановит\r\n        \"submit\" данных. Первым параметром указывается какую форму необходимо остановить, а вторым параметром\r\n        указывается объект, в котором должно быть свойство \"_error\" (из библиотеки \"redux-form\", означает ошибку\r\n        для всей формы, но здесь можно использовать и имена других полей, которые мы создали), которому\r\n        присваивается значение с текстом ошибки (в ответе от сервера в данном случае).\r\n\r\n        Но сейчас со \"stopSubmit\" проблемы. При его использовании возникает проблема асинхроности, так как\r\n        библиотека \"redux-form\" вызывает \"setSubmitSucceed()\" сразу после \"stopSubmit()\", не успев вернуть ошибку.\r\n        Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно использовать\r\n        такой костыль:\r\n        setTimeout(async () => await dispatch(stopSubmit('editProfile', {_error: response.messages[0]})))\r\n\r\n        Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки \"redux-form\" (8.3.6).*/\r\n        return Promise.reject(response.messages[0]); /*И поскольку будет какая-то ошибка на сервера, то промис\r\n        будет в состоянии ожидании, соотвественно мы его прерываем, указав текст ошибки. Это нужно, чтобы не произошло\r\n        деактивации режима редактирования профиля пользователя в callback \"onSubmit\", который создан нами в компоненте\r\n        \"ProfileInfo\" в файле \"ProfileInfo.tsx\".*/\r\n    }\r\n};\r\n\r\n\r\nexport default profileReducer; /*Экспортируем \"profileReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"profileReducer\", экспорт необходим для импорта.*/","/*\r\nЭтот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер,\r\nчтобы компоненты не создавали \"side effects\" такого типа. Этот файл отвечает за \"DAL\" - \"Data Access Layer\". Правда\r\nв дальнейшем сами запросы мы перенесли в отдельные файлы по категориям.\r\n\"Cookie\" - это файл, который цепляется ко всем запросам на сервер.\r\n\"Cookie\" связаны с идентификацией пользователя.\r\nСервер при подтверждении пользователя записывает идентификатор пользователя в \"Cookie\" и\r\nотправляетв закодированном виде (в нашем случае - нет) пользователю.\r\nДалее эти \"Cookie\" записываются браузером до тех пор, пока не истечет срок их жизни, который\r\nв них установлен. Галочка \"Запомнить меня?\" - это про срок жизни \"Cookie\".\r\nВ дальнейшем при общении с сервером в \"Cookie\" будет использоваться идентификатор пользователя.\r\nТаким образом, сервер может определять пользователя. Кодировать или декодировать идентификатор может только сервер.\r\nДля каждого домена создаются отдельные \"Cookie\".\r\nЗапрещено делать кросс-доменные запросы, за исключением если домен дал на это разрешение.\r\nЭто важно поскольку наше приложение находится на локальном хосте и мы делаем запросы на другой домен из нашего\r\nприложения.\r\nЧтобы залогиниться в нашем приложении нужно сначала залогиниться на API сайта.\r\nНастройки в POST-запросе передаются третьим параметром.\r\nНастройки в DELETE-запросе и GET-запросе передаются вторым параметром.\r\nВсе запросы, кроме GET-запросов, требуют обязательно ключа доступа, который генерируется на сайте API в нашем случае.\r\nТакие коды указываются в параметрах запросов в свойстве \"headers\".\r\nПри осуществлении запросов в нашем приложении можно получить ошибку \"429\", которая означает, что превышен лимит\r\nзапросов.\r\nДля снятия этого ограничения нужно купить Premium-аккаунт на сайте API.\r\nПри кроссдоменных запросах, перед основным запросом, браузер отправляет OPTIONS-запрос для получения разрешения от\r\nсервера на осуществление кроссдоменных запросов. Это часть \"CORS\" - политики безопасности браузера.\r\nGET-запросы и DELETE-запросы ничего не могут передать на сервер, кроме адресной строки самого URL-адреса.\r\nPOST-запросы и PUT-запросы могут отправлять на сервер разные данные, некий \"payload\" (например, фото или текст).\r\n*/\r\n\r\nimport axios from 'axios';\r\n/*\r\nБиблиотека axios нужна для работы с запросами на сервер.\r\nЗапросы осуществляются на \"endpoints\", которые представляют из себя URL.\r\nНаш API сервера находится здесь: \"https://social-network.samuraijs.com/docs\".\r\nУ каждого API сервера есть базовый URL, в нашем случае это \"https://social-network.samuraijs.com/api/1.0\".\r\nК базовому URL дописываются определенные элементы (например, \"/users\"), чтобы получить какую-то категорию данных.\r\nВ запросе \"GET\" мы не можем передавать какую-либо информацию, кроме URL.\r\nВ нашем случае мы получаем ответы в формате JSON.\r\nСуществует подход \"API first\": сначала создается API, а потом уже front-end и back-end.\r\nВ библиотеке \"axios\" любой запрос \"GET\", \"POST\" или \"PUT\" являются \"generic\" и возвращают промис, который можно уточнить\r\nпри помощи \"TypeScript\".\r\n*/\r\n\r\n\r\nexport const instance = axios.create({ /*Создаем \"instance\". \"axios.create\" позволяет создавать экземпляры \"axios\". Этот\r\nэкземпляр будет содержать необходимые параметры для наших запросов.*/\r\n    withCredentials: true, /*Указываем, чтобы к запросам были прикреплены \"Cookie\".*/\r\n    baseURL: `https://social-network.samuraijs.com/api/1.0/`, /*Указываем базовый URL. Используем обратные\r\n    кавычки \"``\", чтобы можно было использовать спецсимволы.*/\r\n    headers: { /*Указываем обязательный ключ доступа, который сгенерирован на сайте API.*/\r\n        'API-KEY': 'd418a1c2-23eb-4c24-817d-5fabace62f03'\r\n    }\r\n});\r\n\r\n\r\n/*\"enum\" в JS перечисляют строки или числа. При помощи \"enum\" создали список кодов ответа от сервера, которые\r\nиспользуются в TC \"getAuthUserData\" и в TC \"login\" в \"auth-reducer.ts\".*/\r\nexport enum ResultCodeEnum {\r\n    Success = 0,\r\n    Error = 1\r\n};\r\n\r\n/*\"enum\" в JS перечисляют строки или числа. При помощи \"enum\" создали список кодов ответа от сервера, которые\r\nиспользуются в TC \"login\" в \"auth-reducer.ts\".*/\r\nexport enum ResultCodeForCaptchaEnum {\r\n    CaptchaIsRequired = 10\r\n};\r\n\r\n\r\nexport type ResponseWithItemsType<T> = { /*Сделали общий тип для ответов от сервера, где ответ имеет следующую\r\nструктуру:\r\n- items: массив каких-то элементов;\r\n- totalCount: количество этих элементов;\r\n- error: какое-то информационное сообщение об ошибке.\r\nЭтот тип используется в типе \"GetUsersType\" в \"users-api.ts\".*/\r\n    items: Array<T>\r\n    totalCount: number\r\n    error: string | null\r\n};\r\n\r\nexport type ResponseWithDataType<D = {}, RC = ResultCodeEnum> = { /*Сделали общий тип для ответов от сервера, где ответ\r\nимеет следующую структуру:\r\n- data: объект, содержащий какие-то данные;\r\n- resultCode: код какой-то ошибки;\r\n- messages: массив с какими-то информационными сообщениями об ошибке, например:\r\n    1. при какой-либо ошибке во время залогинивания в запросах \"me\" и \"login\" из \"auth-api.ts\";\r\n    2. при какой-либо ошибке во время разлогинивания в запросе \"logout\" из \"auth-api.ts\";\r\n    3. при какой-либо ошибке во время фолловинга/анфолловинга пользователя в запросах \"follow\" и \"unfollow\" из\r\n    \"users-api.ts\";\r\n    4. при какой-либо ошибке во время обновления статуса пользователя в запросе \"updateUserStatus\" из \"profile-api.ts\";\r\n    5. при какой-либо ошибке во время сохранения фото пользователя в запросе \"saveUserPhoto\" из \"profile-api.ts\";\r\n    6. при какой-либо ошибке во время сохранения данных профиля в запросе \"saveProfile\" из \"profile-api.ts\".\r\nДанный тип является \"generic\", в котором мы уточняем \"D\" - наша \"data\" (по умолчанию это пустой объект) и \"RC\" - наш\r\n\"resultCode\" (по умолчанию список \"ResultCodeEnum\").\r\nЭтот тип используется в запросах:\r\n- \"GET\" в \"me\" из \"auth-api.ts\";\r\n- \"POST\" в \"login\" из \"auth-api.ts\";\r\n- \"DELETE\" в \"logout\" из \"auth-api.ts\";\r\n- \"POST\" в \"follow\" из \"users-api.ts\";\r\n- \"DELETE\" в \"unfollow\" из \"users-api.ts\";\r\n- \"PUT\" в \"updateUserStatus\" из \"profile-api.ts\";\r\n- \"PUT\" в \"saveUserPhoto\" из \"profile-api.ts\";\r\n- \"PUT\" в \"saveProfile\" из \"profile-api.ts\".\r\n*/\r\n    data: D\r\n    resultCode: RC\r\n    messages: Array<string>\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за страницу диалогов. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {InferActionsTypes} from './redux-store'; /*Подключаем типы.*/\r\n\r\nimport avatarSource from '../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\nexport type InitialDialogsStateType = typeof initialState;\r\n\r\n/*Создаем тип для объектов с данными для диалога. Объект, содержащий информацию с данными для диалога должен обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype DialogType = {\r\n    id: number /*\"ID\" диалога должно быть числом.*/\r\n    name: string /*Имя, с кем ведется диалог, должно быть строкой.*/\r\n    avatar: typeof avatarSource /*Аватар того, с кем ведется диалог, получаем на основе самого изображения аватара при\r\n    помощи \"typeof\".*/\r\n};\r\n\r\n/*Создаем тип для объектов с данными для исходящих сообщений в диалогах. Объект, содержащий информацию с данными для\r\nисходящих сообщений в диалогах должен обязательно содержать следующие поля с указанными типами.*/\r\ntype MessageType = {\r\n    id: number /*\"ID\" исходящего сообщения должно быть числом.*/\r\n    message: string /*Текст исходящего сообщения должно быть строкой.*/\r\n    avatar: typeof avatarSource /*Аватар того, от кого отправлено исходящее сообщение, получаем на основе самого\r\n    изображения аватара при помощи \"typeof\".*/\r\n};\r\n\r\n/*Создаем тип для объектов с данными для входящих сообщений в диалогах. Объект, содержащий информацию с данными для\r\nвходящих сообщений в диалогах должен обязательно содержать следующие поля с указанными типами.*/\r\ntype IncomingMessageType = {\r\n    id: number /*\"ID\" входящего сообщения должно быть числом.*/\r\n    message: string /*Текст входящего сообщения должно быть строкой.*/\r\n    avatar: typeof avatarSource /*Аватар того, от кого отправлено входящее сообщение, получаем на основе самого\r\n    изображения аватара при помощи \"typeof\".*/\r\n};\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    dialogs: [ /*Создаем массив объектов, которые хранят информацию о диалогах на странице диалогов.*/\r\n        {id: 1, name: 'Abba', avatar: avatarSource},\r\n        {id: 2, name: 'Bret', avatar: avatarSource},\r\n        {id: 3, name: 'Carry', avatar: avatarSource},\r\n        {id: 4, name: 'Daemon', avatar: avatarSource},\r\n        {id: 5, name: 'Eric', avatar: avatarSource},\r\n        {id: 6, name: 'Frye', avatar: avatarSource}\r\n    ] as Array<DialogType>, /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"DialogType\".*/\r\n\r\n    messagesData: [ /*Создаем массив объектов, которые хранят информацию о исходящих сообщениях в диалогах на странице\r\n    диалогов.*/\r\n        {id: 1, message: 'Hi', avatar: avatarSource},\r\n        {id: 2, message: '..', avatar: ''},\r\n        {id: 3, message: 'Fine', avatar: avatarSource},\r\n        {id: 4, message: 'You?', avatar: avatarSource}\r\n    ] as Array<MessageType>, /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"MessageType\".*/\r\n\r\n    incomingMessagesData: [ /*Создаем массив объектов, которые хранят информацию о входящих сообщениях в диалогах на\r\n    странице диалогов.*/\r\n        {id: 1, message: '..', avatar: ''},\r\n        {id: 2, message: 'How are you?', avatar: avatarSource},\r\n        {id: 3, message: '..', avatar: ''},\r\n        {id: 4, message: '..', avatar: ''},\r\n        {id: 5, message: 'OK', avatar: avatarSource}\r\n    ] as Array<IncomingMessageType> /*Указываем, что этот массив объектов имеет тип массива элементов с\r\n    типом \"IncomingMessageType\".*/\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst dialogsReducer = (state = initialState, action: ActionsType): InitialDialogsStateType => { /*Указываем, что\r\nтип \"state\" на выходе имеет тот же тип \"InitialDialogsStateType\", что и \"state\" на входе. На входе объекты \"action\"\r\nимеют тип \"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case 'demo-spa/dialogs-reducer/ADD-MESSAGE':\r\n            let newMessage = { /*Создаем новое исходящее сообщение в виде объекта.*/\r\n                id: 6, /*Указываем \"ID\" исходящего сообщения.*/\r\n                message: action.newMessageText, /*Указываем текст исходящего сообщения.*/\r\n                avatar: avatarSource /*Указываем аватар пользователя, которые будет отрисовываться рядом с исходящим\r\n                сообщением.*/\r\n            };\r\n            return { /*Добавляем это новое исходящее сообщение в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                messagesData: [...state.messagesData, newMessage] /*Делаем глубокую копию \"state\". Добавляем данные для\r\n                нового исходящего сообщения в диалогах в \"state\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InferActionsTypes<typeof dialogsAC>; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип \"InferActionsTypes\" для\r\nопределения типов всех объектов \"action\" у упакованных в единый объект \"dialogsAC\" AC.*/\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const dialogsAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные\r\nраннее на основе каждого AC. Также вверху удалили все константы со значениями для \"type\" и указывываем их сразу в AC,\r\nтак как \"TypeScript\" не даст нам допустить ошибку при указании этих \"types\" в \"reducer\". Согласно модульному паттерну\r\n\"Redux Ducks\", чтобы избежать случаев одиноковых значений свойств \"type\" из-за чего один и тот же объект \"action\" может\r\nсработать в нескольких \"reducers\", в значениях свойств \"type\" в объекте \"action\" указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\". Также в конце везде добавили \"as const\", чтобы \"reducer\" адекватно\r\nвоспринимал объекты \"action\". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных\r\nтипов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/\r\n    addMessage: (newMessageText: string) => ({ /*AC для добавления нового исходящего сообщения. На входе получает\r\n    \"newMessageText\", которое дожно быть строкой.*/\r\n        type: 'demo-spa/dialogs-reducer/ADD-MESSAGE', /*Обязательно свойство \"type\" для AC.*/\r\n        newMessageText /*Это равносильно \"newMessageText: newMessageText\". Создаем свойство, которое содержит текст\r\n        исходящего сообщения.*/\r\n    } as const)\r\n};\r\n\r\n\r\nexport default dialogsReducer; /*Экспортируем \"dialogsReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"dialogsReducer\", экспорт необходим для импорта.*/","/*\r\nЭто файл, содержащий API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем приложении.\r\nВыносим этот API в отдельный файл для реализации уровня DAL.\r\n*/\r\n\r\n\r\n/*Создаем тип для объектов, которые будут приходить от сервера и содержать информацию о сообщении из чата.*/\r\nexport type ChatMessageAPIType = {\r\n    message: string /*Сообщение пользователя, которое было отправлено в чат, должно быть строкой.*/\r\n    photo: string /*Фото пользователя, который отправил сообщение в чат, должно быть строкой.*/\r\n    userId: number /*\"ID\" пользователя, который отправил сообщение в чат, должно быть числом.*/\r\n    userName: string /*Имя пользователя, который отправил сообщение в чат, должно быть строкой.*/\r\n};\r\n\r\nexport type WSStatusType = 'pending' | 'ready' | 'error'; /*Создаем тип для статуса готовности WebSocket-канала для\r\nотправки информации по нему.*/\r\n\r\nexport type ChatMessagesReceivingSubscriberType = (chatMessages: ChatMessageAPIType[]) => void; /*Создали тип для\r\ncallback-функции, которая передается в методы \"subscribe\" и \"unsubscribe\" в объекте \"chatAPI\" ниже. Функции с таким\r\nтипом обозначают подписчиков на получение новых сообщения чата. Эта callback-функция ничего не возвращает, но на входе\r\nпринимает массив элементов с созданным нами выше типом \"ChatMessageAPIType\", то есть массив с сообщениями из чата.*/\r\n\r\nexport type WSStatusChangingSubscriberType = (status: WSStatusType) => void; /*Создали тип для callback-функции, которая\r\nпередается в методы \"subscribe\" и \"unsubscribe\" в объекте \"chatAPI\" ниже. Функции с таким типом обозначают подписчиков\r\nна изменение статуса готовности WebSocket-канала для отправки информации по нему. Эта callback-функция ничего не\r\nвозвращает, но на входе принимает указанный статус WebSocket-канала созданного нами выше типа \"WSStatusType\".*/\r\n\r\nexport type WSEventType = 'chat-messages-receiving' | 'ws-status-changing'; /*Создаем специальный тип для ключей в виде\r\nстроковых значений в объекте \"subscribers\", где каждый ключ обозначает вид подписчиков на разные события.\r\n\"chat-messages-receiving\" обозначает подписчиков на получение новых сообщений в чате, а \"ws-status-changing\" обозначает\r\nподписчиков на изменение статуса готовности WebSocket-канала для отправки информации по нему.*/\r\n\r\n\r\nlet ws: WebSocket | null = null; /*Объявляем переменную \"ws\", которая может быть типа \"WebSocket\" или \"null\" (то есть\r\nотсутствовать), и которая в дальнейшем будет использоваться для хранения WebSocket-канала.*/\r\n\r\nconst notifySubscribersAboutWSStatus = (WSStatus: WSStatusType) => { /*Создаем вспомогательную функцию\r\n\"notifySubscribersAboutWSStatus\", которая при вызове будет уведомлять подписчиков на изменение статуса готовности\r\nWebSocket-канала для отправки информации по нему в объекте \"subscribers\" при изменении этого статуса. То есть здесь мы\r\nпробегаемся по каждому подписчику на изменение статуса готовности WebSocket-канала для отправки информации по нему, то\r\nесть по каждой callback-функции в массиве под ключем \"ws-status-changing\" объекта \"subscribers\", вызываем каждого такого\r\nподписчика и передаем каждому из них информацию о статусе готовности WebSocket-канала для отправки информации по нему,\r\nчтобы в дальнейшем они установили эту информацию в наш \"store\".*/\r\n    subscribers['ws-status-changing'].forEach(s => s(WSStatus));\r\n};\r\n\r\nconst closeEventHandler = () => { /*Объявляем функцию \"closeEventHandler\", которая будет вызываться при подписке на\r\nсобытие \"close\" в WebSocket-канале и вызывать функцию \"createWSChannel\" каждые 3 секунды с целью пересоздания\r\nWebSocket-канала.*/\r\n    setTimeout(createWSChannel, 3000);\r\n};\r\n\r\nconst messageEventHandler = (event: MessageEvent) => { /*Объявляем функцию \"messageEventHandler\", которая будет\r\nвызываться при подписке на событие \"message\" в WebSocket-канале, на входе получать информацию из WebSocket-канала,\r\nкоторая внутри себя содержит информацию о сообщениях из чата, парсить ее в формат \"JSON\" при помощи \"JSON.parse()\",\r\nчтобы в дальнейшем можно было сохранить эту информацию в массиве \"newChatMessages\" под элементами в виде объектов, после\r\nэтого сохранять эту информацию о сообщениях из чата в массиве \"newChatMessages\". Далее мы пробегаемся по каждому\r\nподписчику на получение новых сообщений в чате, то есть по каждой callback-функции в массиве под ключем\r\n\"chat-messages-receiving\" объекта \"subscribers\", вызываем каждого такого подписчика и передаем каждому из них информацию\r\nо сообщениях из чата, чтобы в дальнейшем они установили эту информацию в наш \"store\".*/\r\n    const newChatMessages = JSON.parse(event.data);\r\n\r\n    subscribers['chat-messages-receiving'].forEach(s => s(newChatMessages));\r\n};\r\n\r\nconst openEventHandler = () => { /*Объявляем функцию \"openEventHandler\", которая будет вызываться при подписке на\r\nсобытие \"open\" в WebSocket-канале, уведомлять подписчиков на изменение статуса готовности WebSocket-канала для отправки\r\nинформации по нему об изменении этого статуса.*/\r\n    notifySubscribersAboutWSStatus('ready');\r\n};\r\n\r\nconst errorEventHandler = () => { /*Объявляем функцию \"errorEventHandler\", которая будет вызываться при подписке на\r\nсобытие \"error\" в WebSocket-канале, уведомлять подписчиков на изменение статуса готовности WebSocket-канала для отправки\r\nинформации по нему об изменении этого статуса.*/\r\n    notifySubscribersAboutWSStatus('error');\r\n};\r\n\r\nconst removeEvents = () => { /*Создаем функцию \"removeEvents\", которая при вызове отписывает от всех событий в\r\nWebSocket-канале с целью очистки памяти.*/\r\n    ws?.removeEventListener('close', closeEventHandler); /*Если имеется WebSocket-канал, то с целью очистки памяти мы\r\n    отписываемся в нем от события \"close\". Для отписки должны указать ту же функцию, что и указывали при подписке на\r\n    это событие (подписка ниже).*/\r\n\r\n    ws?.removeEventListener('message', messageEventHandler); /*Если имеется WebSocket-канал, то с целью очистки памяти\r\n    мы отписываемся в нем от события \"message\". Для отписки должны указать ту же функцию, что и указывали при подписке\r\n    на это событие (подписка ниже).*/\r\n\r\n    ws?.removeEventListener('open', openEventHandler); /*Если имеется WebSocket-канал, то с целью очистки памяти мы\r\n    отписываемся в нем от события \"open\". Для отписки должны указать ту же функцию, что и указывали при подписке на это\r\n    событие (подписка ниже).*/\r\n\r\n    ws?.removeEventListener('error', errorEventHandler); /*Если имеется WebSocket-канал, то с целью очистки памяти мы\r\n    отписываемся в нем от события \"error\". Для отписки должны указать ту же функцию, что и указывали при подписке на это\r\n    событие (подписка ниже).*/\r\n};\r\n\r\nfunction createWSChannel() { /*Объявляем функцию \"createWSChannel\".*/\r\n    removeEvents(); /*Если имеется WebSocket-канал, то с целью очистки памяти мы отписываемся в нем от событий \"close\",\r\n    \"message\", \"open\" и \"error\".*/\r\n\r\n    ws?.close(); /*Далее мы вызываем функцию \"close()\" у WebSocket-канала (если таковой имеется) с целью полного\r\n    закрытия этого WebSocket-канала.*/\r\n\r\n    ws = new WebSocket('wss://social-network.samuraijs.com/handlers/ChatHandler.ashx'); /*Далее таким образом\r\n    создаем WebSocket-канал, указав адрес согласно API сервера. Согласно API сервера в ответ мы будем получать объекты,\r\n    которые содержат следующие свойства:\r\n    - \"userId\" - \"ID\" пользователя, который отправил сообщение в чат;\r\n    - \"userName\" - имя пользователя, который отправил сообщение в чат;\r\n    - \"photo\" - фото пользователя, который отправил сообщение в чат;\r\n    - \"message\" - сообщение пользователя, которое было отправлено в чат.\r\n    По стандартному HTTP-протоколу клиент делает запросы на сервер, а сервер отправляет ответы клиенту. Чтобы делать\r\n    наоборот нужно применять дополнительные механизмы, например, такие как \"SSE\" или \"WebSocket\". \"WebSocket\" - это в\r\n    каком-то смысле альтернатива протокола \"HTTP\" (прикладной уровень). \"WSS\" - это безопасная версия протокола\r\n    \"WebSocket\", по аналогии с \"HTTPS\". По протоколу \"WebSocket\" можно передавать два типа данных: текстовой и бинарный.\r\n    Также нужно помнить, что в браузерах в средствах разработчика нельзя замедлить скорость WebSocket-каналов.*/\r\n\r\n    ws.addEventListener('close', closeEventHandler); /*Далее подписываемся на событие \"close\", при срабатывании\r\n    которого будет вызываться функция \"closeEventHandler\".*/\r\n\r\n    ws.addEventListener('message', messageEventHandler); /*Далее подписываемся на событие \"message\", при\r\n    срабатывании которого будет вызываться функция \"messageEventHandler\".*/\r\n\r\n    ws.addEventListener('open', openEventHandler); /*Далее подписываемся на событие \"open\", при срабатывании\r\n    которого будет вызываться функция \"openEventHandler\".*/\r\n\r\n    ws.addEventListener('error', errorEventHandler); /*Далее подписываемся на событие \"error\", при срабатывании\r\n    которого будет вызываться функция \"errorEventHandler\".*/\r\n};\r\n\r\n\r\nconst subscribers = { /*Создаем специальный объект \"subscribers\", который будет содержать ключи в виде строковых\r\nзначений. Каждый ключ будет хранить свой массив каких-то элементов в виде функций, то есть функций, которые как бы будут\r\nподписываться на какие-то изменения и что-то получать при каждом таком изменении.\r\n\r\nВ случае ключа \"chat-messages-receiving\" там будут callback-функции типа \"ChatMessagesReceivingSubscriberType\", которые\r\nбудут подписываться на получение новых сообщений для чата из WebSocket-канала. Соотвественно после подписки при каждом\r\nновом сообщении для чата эти callback-функции будут вызываться и получать эти новые сообщения, что в дальнейшем мы можем\r\nиспользовать для сохранения этих сообщений на уровне BLL, то есть в нашем \"store\".\r\n\r\nВ случае ключа \"ws-status-changing\" там будут callback-функции типа \"WSStatusChangingSubscriberType\", которые будут\r\nподписываться на изменение статуса готовности WebSocket-канала для отправки информации по нему. Соотвественно после\r\nподписки при каждом изменении этого статуса WebSocket-канала эти callback-функции будут вызываться и получать этот новый\r\nстатус WebSocket-канала, что в дальнейшем мы можем использовать для сохранения этого статуса WebSocket-канала на уровне\r\nBLL, то есть в нашем \"store\".\r\n\r\nТаким образом реализуется работа между уровнями DAL (WebSocket-канал) и BLL (наш \"store\").*/\r\n    'chat-messages-receiving': [] as ChatMessagesReceivingSubscriberType[],\r\n    'ws-status-changing': [] as WSStatusChangingSubscriberType[]\r\n};\r\n\r\n\r\nexport const chatAPI = { /*Создаем API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем\r\nприложении.*/\r\n    startWSChannel() { /*Создаем метод \"startWSChannel\", который будет вызывать функцию \"createWSChannel\", объявленную\r\n    выше. Этот метод будет использоваться для инициализации WebSocket-канала.*/\r\n        createWSChannel();\r\n    },\r\n\r\n    stopWSChannel() { /*Создаем метод \"stopWSChannel\" для отключения WebSocket-канала (если таковой имеется). При вызове\r\n    этого метода мы очищаем все наши массивы подписчиков, то есть массивы в объекте \"subscribers\". Также с целью\r\n    очистки памяти мы отписываемся от событий \"close\", \"message\", \"open\" и \"error\" в WebSocket-канале. И в конце мы\r\n    вызываем функцию \"close()\" у WebSocket-канала (если таковой имеется) с целью полного закрытия этого\r\n    WebSocket-канала.*/\r\n        subscribers['chat-messages-receiving'] = [];\r\n        subscribers['ws-status-changing'] = [];\r\n        removeEvents();\r\n        ws?.close();\r\n    },\r\n\r\n    subscribe(WSEvent: WSEventType, callback: ChatMessagesReceivingSubscriberType | WSStatusChangingSubscriberType) {\r\n    /*При получении сообщения для чата по WebSocket-каналу или при изменении статуса готовности WebSocket-канала для\r\n    отправки информации по нему нам необходимо уведомлять об этом уровень BLL, то есть наш \"store\", чтобы мы могли\r\n    сохранять эти новые сообщения в нашем \"store\" или этот новый статус WebSocket-канала. Для этого здесь мы создаем\r\n    метод \"subscribe\", который при вызове будет получать callback-функции типа \"ChatMessagesReceivingSubscriberType\" или\r\n    типа \"WSStatusChangingSubscriberType\". Эти callback-функции должны будут вызываться каждый раз, когда мы получаем\r\n    новое сообщение для чата или при каждом изменении статуса готовности WebSocket-канала для отправки информации по\r\n    нему соотвественно, и устанавливать эту информацию в наш \"store\". При получении таких callback-функций мы добавляем\r\n    их в объект \"subscribers\", таким образом как бы подписывая их на получение новых сообщений для чата из\r\n    WebSocket-канала или на изменение статуса готовности WebSocket-канала для отправки информации по нему\r\n    соотвественно. Для указания типа подписчика первым параметром здесь мы передаем строковое значение одного из ключей\r\n    объекта \"subscribers\".*/\r\n        // @ts-ignore\r\n        subscribers[WSEvent].push(callback); /*Пока игнорируем здесь \"TypeScript\", так как еще не разобрались с\r\n        типизацией.*/\r\n\r\n        return () => { /*Также метод \"subscribe\" возвращает функцию, которую если вызвать снаружи произойдет отписка\r\n        всех подписчиков, то есть в объекте \"subscribers\" останутся только те элементы, которые не равны подписанной\r\n        callback-функции. В итоге эта callback-функция перестанет реагировать на получения сообщений для чата или на\r\n        изменение статуса готовности WebSocket-канала для отправки информации по нему соотвественно. Это одна из\r\n        реализаций способа отписки. Но ниже мы создали для этого отдельный метод \"unsubscribe\".*/\r\n             // @ts-ignore\r\n             subscribers[WSEvent] = subscribers[WSEvent].filter(s => s !== callback); /*Пока игнорируем здесь\r\n             \"TypeScript\", так как еще не разобрались с типизацией.*/\r\n        };\r\n    },\r\n\r\n    unsubscribe(WSEvent: WSEventType, callback: ChatMessagesReceivingSubscriberType | WSStatusChangingSubscriberType) {\r\n    /*Создаем метод \"unsubscribe\" для отписки подписчиков, то есть callback-функций в объекте \"subscribers\". При вызове\r\n    этого метода в объекте \"subscribers\" остануться только те элементы, которые не равны подписанной callback-функции.\r\n    В итоге эта callback-функция перестанет реагировать на получения сообщений для чата или на изменение статуса\r\n    готовности WebSocket-канала для отправки информации по нему соотвественно. Для указания типа подписчика первым\r\n    параметром здесь мы передаем строковое значение одного из ключей объекта \"subscribers\".*/\r\n        // @ts-ignore\r\n        subscribers[WSEvent] = subscribers[WSEvent].filter(s => s !== callback); /*Пока игнорируем здесь \"TypeScript\",\r\n        так как еще не разобрались с типизацией.*/\r\n    },\r\n\r\n    sendChatMessage(chatMessage: string) { /*Создаем метод \"sendChatMessage\", при вызове который получает введенное нами\r\n    сообщения для чата, вызывает функцию \"send()\" у WebSocket-канала (если таковой имеется) и передает в нее наше\r\n    сообщение для отправки этого сообщения по WebSocket-каналу.*/\r\n        ws?.send(chatMessage);\r\n    }\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за чат в нашем приложении. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {v1} from 'uuid'; /*Библиотека \"uuid\" помогает организовать идентификацию при помощи создания универсального\r\nуникального идентификатора (\"UUID\"). Импортируем функцию \"v1\" для создания \"UUID\" варианта 1.*/\r\n\r\nimport {\r\n    chatAPI,\r\n    ChatMessageAPIType,\r\n    WSStatusType,\r\n    ChatMessagesReceivingSubscriberType,\r\n    WSStatusChangingSubscriberType\r\n} from '../api/chat-api' /*Импортируем API для работы с WebSocket-каналом нашего сервера с целью реализации чата в нашем\r\nприложении. Также подключаем типы оттуда.*/\r\n\r\nimport {FormAction} from 'redux-form'; /*Импортируем специальный AC \"stopSubmit\" из библиотеки \"redux-form\", который\r\nсообщает UI, что что-то пошло не так, и останавливает \"submit\" данных в форме. Импортировали \"FormAction\", чтобы создать\r\nтип для объектов \"action\", который передается в \"thunks\" и TC.*/\r\n\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store'; /*Подключаем типы.*/\r\nimport {Dispatch} from 'redux'; /*Импортировали \"Dispatch\" из библиотеки \"redux\", чтобы создать тип для \"dispatch\",\r\nкоторый передается в \"thunks\" и TC.*/\r\n\r\n\r\n/*Создаем тип для объектов, которые будут приходить от сервера и содержать информацию о сообщении из чата, а также в\r\n\"reducer\" получать новое строковое свойство \"id\" при помощи функции \"v1\" из библиотеки \"uuid\".*/\r\ntype ChatMessageType = ChatMessageAPIType & {id: string};\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialChatStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    chatMessages: [] as ChatMessageType[], /*Свойство для хранения сообщений из чата для вывода их в нашем приложении.\r\n    Должно быть массивом элементов с типом \"ChatMessageType\", который был создан нами и импортирован сюда.*/\r\n\r\n    WSStatus: 'pending' as WSStatusType  /*Это статус готовности WebSocket-канала для отправки информации по нему\r\n    (изначально \"pending\"). Должен быть типа \"WSStatusType\", который был создан нами и импортирован сюда.*/\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst chatReducer = (state = initialState, action: ActionsType)\r\n    : InitialChatStateType => {\r\n/*Указываем, что тип \"state\" на выходе имеет тот же тип \"InitialChatStateType\", что и \"state\" на входе. На входе объекты\r\n\"action\" имеют тип \"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case 'demo-spa/chat-reducer/SET-CHAT-MESSAGES': /*Устанавливаем информацию о сообщениях из чата.*/\r\n            return { /*Устанавливаем информацию о сообщениях из чата в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                chatMessages: [...state.chatMessages, ...action.chatMessages.map(m => ({...m, id: v1()}))]\r\n                    .filter((m, index, array) => index >= array.length - 100)\r\n                /*Делаем глубокую копию \"state\". Дописываем информацию о новых сообщениях из чата в \"state\" (то есть не\r\n                затираем старую информацию).\r\n\r\n                Сначала мапим массив сообщений для чата, которые хотим добавить в \"state\", и добавляем к каждому\r\n                элементу массива (а это у нас объекты) свойство \"id\", которое формируется при помощи функции \"v1()\" из\r\n                библиотеки \"uuid\" для создания универсальных уникальных идентификаторов. В итоге каждое сообщение для\r\n                чата будет иметь свой уникальный индекс под свойством \"id\". Нам это необходимо, чтобы избежать лишних\r\n                перерисовок, так как без уникальных идентификаторов при удалении одного сообщения из чата менялись бы\r\n                индексы у всех остальных сообщений в чате (уменьшались бы на 1), что вызывало бы многократные\r\n                перерисовки.\r\n\r\n                Далее при помощи метода \"filter()\" (первым параметром приходят элементы массива, вторым параметром\r\n                приходят их индексы, а третьим параметром приходит сам массив) оставляем только те сообщения, индекс\r\n                которых больше или равен значению, которое получается из разности длины массива (то есть сколько всего\r\n                сообщений для чата у нас есть в \"state\") и числа \"100\". Чем большее число мы вычтем, тем меньшее число\r\n                мы получим, значит тем большее количество индексов будет, соотвественно тем больше выведется сообщений в\r\n                чате. Но сервер хранит не больше 100 сообщений, поэтому больше 100 сообщений мы вывести не сможем. Все\r\n                это мы делаем для регулировки максимального количества выведенных сообщений в чате.*/\r\n            };\r\n\r\n        case 'demo-spa/chat-reducer/CLEAR-CHAT-MESSAGES': /*Обнуляем информацию о сообщениях из чата.*/\r\n            return { /*Обнуляем информацию о сообщениях из чата в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                chatMessages: [] /*Обнуляем информацию о сообщениях из чата в \"state\".*/\r\n            };\r\n\r\n        case 'demo-spa/chat-reducer/SET-WS-STATUS': /*Указываем статус готовности WebSocket-канала для отправки\r\n        информации по нему.*/\r\n            return { /*Указываем статус готовности WebSocket-канала для отправки информации по нему в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                WSStatus: action.WSStatus /*Указываем статус готовности WebSocket-канала для отправки информации по нему\r\n                в \"state\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InferActionsTypes<typeof chatAC>; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип \"InferActionsTypes\" для\r\nопределения типов всех объектов \"action\" у упакованных в единый объект \"chatAC\" AC.*/\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const chatAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные\r\nраннее на основе каждого AC. Также вверху удалили все константы со значениями для \"type\" и указывываем их сразу в AC,\r\nтак как \"TypeScript\" не даст нам допустить ошибку при указании этих \"types\" в \"reducer\". Согласно модульному паттерну\r\n\"Redux Ducks\", чтобы избежать случаев одиноковых значений свойств \"type\" из-за чего один и тот же объект \"action\" может\r\nсработать в нескольких \"reducers\", в значениях свойств \"type\" в объекте \"action\" указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\". Также в конце везде добавили \"as const\", чтобы \"reducer\" адекватно\r\nвоспринимал объекты \"action\". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных\r\nтипов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/\r\n    setChatMessages: (chatMessages: ChatMessageAPIType[]) => ({ /*AC для установки сообщений для чата в \"state\". На\r\n    входе получает информацию о сообщениях для чата как массив элементов с типом \"ChatMessageAPIType\", который был\r\n    создан нами и импортирован сюда.*/\r\n        type: 'demo-spa/chat-reducer/SET-CHAT-MESSAGES', /*Обязательно свойство \"type\" для AC.*/\r\n        chatMessages /*Это равносильно \"chatMessages: chatMessages\". Создаем свойство, которое содержит информацию о\r\n        сообщениях для чата.*/\r\n    } as const),\r\n\r\n    clearChatMessages: () => ({ /*AC для обнуления сообщений для чата в \"state\".*/\r\n        type: 'demo-spa/chat-reducer/CLEAR-CHAT-MESSAGES' /*Обязательно свойство \"type\" для AC.*/\r\n    } as const),\r\n\r\n    setWSStatus: (WSStatus: WSStatusType) => ({ /*AC для указания статуса готовности WebSocket-канала для\r\n    отправки информации по нему в \"state\". На входе получает такой статус типа \"WSStatusType\", который мы создали\r\n    выше.*/\r\n        type: 'demo-spa/chat-reducer/SET-WS-STATUS', /*Обязательно свойство \"type\" для AC.*/\r\n        WSStatus /*Это равносильно \"WSStatus: WSStatus\". Создаем свойство, которое содержит статус готовности\r\n        WebSocket-канала для отправки информации по нему.*/\r\n    } as const)\r\n};\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype ThunkType = BaseThunkType<ActionsType | FormAction>; /*Создали тип для \"thunks\". Поскольку в TC\r\n\"login\" мы диспатчим \"stopSubmit\" из библиотеки \"redux-form\", поэтому здесь мы указали еще \"FormAction\" из библиотеки\r\n\"redux-form\", так как в файле декларации \"stopSubmit\" указано, что он \"extends\" от \"FormAction\". Но из-за этого теперь\r\nмы можем диспатчить любой объект \"action\", что естественно нежелательно для нас.*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nlet _newChatMessagesHandler: ChatMessagesReceivingSubscriberType | null = null; /*Создаем вспомогательную функцию\r\n\"_newChatMessagesHandler\", которая будет хранить в себе функцию перехватчика сообщений для чата по WebSocket-каналу.\r\nТакая функция должна быть типа \"ChatMessagesReceivingSubscriberType\", который был создан нами и импортирован сюда, или\r\n\"null\", то есть отсутствовать.*/\r\n\r\nconst newChatMessagesHandlerCreator = (dispatch: Dispatch) => { /*Создаем вспомогательную функцию (высшего порядка)\r\n\"newChatMessagesHandlerCreator\", которая будет проверять есть ли у нас уже перехватчик сообщений для чата, и если нет,\r\nто будет присваивать и возвращать такой перехватчик, который будет получать сообщения для чата и устанавливать их в\r\n\"state\" при помощи AC \"setChatMessages\". Здесь нам нужна указанная проверка, так как мы вызываем эту функцию в\r\nнескольких местах (при подписке и отписке), поэтому получаем одну и туже функцию несколько раз, соотвественно если уже\r\nесть перехватчик сообщений для чата, то для исключения упомянутых повторов в таком случае просто возвращаем уже\r\nсуществующий перехватчик сообщений для чата (типо мемоизация).\r\n*/\r\n    if (_newChatMessagesHandler === null) {\r\n        _newChatMessagesHandler = (chatMessages) => {\r\n            dispatch(chatAC.setChatMessages(chatMessages));\r\n        };\r\n    };\r\n\r\n    return _newChatMessagesHandler;\r\n};\r\n\r\nlet _WSStatusChangingHandler: WSStatusChangingSubscriberType | null = null; /*Создаем вспомогательную функцию\r\n\"_WSStatusChangingHandler\", которая будет хранить в себе функцию перехватчика изменений статуса готовности\r\nWebSocket-канала для отправки информации по нему. Такая функция должна быть типа \"WSStatusChangingSubscriberType\",\r\nкоторый был создан нами и импортирован сюда, или \"null\", то есть отсутствовать.*/\r\n\r\nconst WSStatusChangingHandlerCreator = (dispatch: Dispatch) => { /*Создаем вспомогательную функцию (высшего порядка)\r\n\"WSStatusChangingHandlerCreator\", которая будет проверять есть ли у нас уже перехватчик изменений статуса готовности\r\nWebSocket-канала для отправки информации по нему, и если нет, то будет присваивать и возвращать такой перехватчик,\r\nкоторый будет получать указанный статус и устанавливать его в \"state\" при помощи AC \"setWSStatus\". Здесь нам нужна\r\nуказанная проверка, так как мы вызываем эту функцию в нескольких местах (при подписке и отписке), поэтому получаем одну\r\nи туже функцию несколько раз, соотвественно если уже есть перехватчик сообщений для чата, то для исключения упомянутых\r\nповторов в таком случае просто возвращаем уже существующий перехватчик сообщений для чата (типо мемоизация).\r\n*/\r\n    if (_WSStatusChangingHandler === null) {\r\n        _WSStatusChangingHandler = (WSStatus) => {\r\n            dispatch(chatAC.setWSStatus(WSStatus));\r\n        };\r\n    };\r\n\r\n    return _WSStatusChangingHandler;\r\n};\r\n\r\nexport const startGettingChatMessages = (): ThunkType => async (dispatch) => {\r\n/*Это TC для инициализации WebSocket-канала, установки информации по сообщениям для чата в \"state\", которые будут\r\nполучаться через этот WebSocket-канал, и установки статуса готовности WebSocket-канала для отправки информации по нему в\r\n\"state\". Здесь вместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает\r\nTC асинхронным. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь\r\nтакже указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть\r\n\"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и\r\nдополнительные аргументы.*/\r\n    chatAPI.startWSChannel(); /*Инициализируем WebSocket-канал для получения сообщений для чата.*/\r\n\r\n    chatAPI.subscribe('chat-messages-receiving', newChatMessagesHandlerCreator(dispatch)); /*Подписываем функцию\r\n    \"newChatMessagesHandlerCreator\" на получение новых сообщений для чата, передав в нее функцию \"dispatch\",\r\n    необходимую ей для ее внутренней работы.*/\r\n\r\n    chatAPI.subscribe('ws-status-changing', WSStatusChangingHandlerCreator(dispatch)); /*Подписываем функцию\r\n    \"WSStatusChangingHandlerCreator\" на изменение статуса готовности WebSocket-канала для отправки информации по нему,\r\n    передав в нее функцию \"dispatch\", необходимую ей для ее внутренней работы.*/\r\n};\r\n\r\n/*const unsubscribe = chatAPI.subscribe(newChatMessagesHandlerCreator);*/ /*Это еще одна реализации отписки, продолжение\r\nниже в TC \"stopGettingChatMessages\".*/\r\n\r\nexport const stopGettingChatMessages = (): ThunkType => async (dispatch) => {\r\n/*Это TC для закрытия WebSocket-канала, остановки получения информации по сообщениям для чата, которые получались через\r\nэтот WebSocket-канал, остановки получения статуса готовности WebSocket-канала для отправки информации по нему. Здесь\r\nвместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC\r\nасинхронным. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь\r\nтакже указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть\r\n\"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и\r\nдополнительные аргументы.*/\r\n    chatAPI.unsubscribe('chat-messages-receiving', newChatMessagesHandlerCreator(dispatch)); /*Отписываем\r\n    функцию \"newChatMessagesHandlerCreator\" от получения новых сообщений для чата, передав в нее функцию \"dispatch\",\r\n    необходимую ей для ее внутренней работы.*/\r\n\r\n    chatAPI.unsubscribe('ws-status-changing', WSStatusChangingHandlerCreator(dispatch)); /*Отписываем функцию\r\n    \"WSStatusChangingHandlerCreator\" от получения статуса готовности WebSocket-канала для отправки информации по нему,\r\n    передав в нее функцию \"dispatch\", необходимую ей для ее внутренней работы.*/\r\n\r\n    chatAPI.stopWSChannel(); /*Закрываем WebSocket-канал, чтобы прекратить получение сообщений для чата.*/\r\n\r\n    dispatch(chatAC.clearChatMessages()); /*Обнуляем информацию о сообщениях из чата в \"state\" при помощи AC\r\n    \"clearChatMessages\", чтобы не получить несколько копий сообщений в чате на случай если мы потом переподключимся к\r\n    WebSocket-каналу.*/\r\n\r\n    /*unsubscribe();*/ /*Продолжение еще одной реализации отписки.*/\r\n};\r\n\r\nexport const sendChatMessage = (chatMessage: string): ThunkType => async (dispatch) => {\r\n/*Это TC для отправки сообщений в чат по WebSocket-каналу. На входе получает сообщение для чата, которое должно быть\r\nстрокой. Здесь вместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\"\r\nделает TC асинхронным. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы\r\nмогли здесь также указать тип \"dispatch\", \"getState()\" и  дополнительных аргументов, но типизируя то, что возвращает TC,\r\nто есть \"thunk\", мы также типизировали, что в  \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\",\r\n\"getState()\" и дополнительные аргументы.*/\r\n    chatAPI.sendChatMessage(chatMessage); /*Отправляем наше сообщение в чат.*/\r\n};\r\n\r\n\r\nexport default chatReducer; /*Экспортируем \"chatReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"authReducer\", экспорт необходим для импорта.*/","export default __webpack_public_path__ + \"static/media/user.ad89b36a.png\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"preloader\":\"Preloader_preloader__Li63D\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"header\":\"Header_header__1Xr0A\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"menu\":\"Navbar_menu__JmfWD\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"userPhoto\":\"User_userPhoto__2T2y8\"};","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","/*\r\nЭтот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер, касающиеся аутентификации и\r\nсвязанных с ней процессов, чтобы компоненты не создавали \"side effects\" такого типа. Этот файл отвечает за\r\n\"DAL\" - \"Data Access Layer\".\r\n*/\r\n\r\nimport {instance, ResultCodeEnum, ResultCodeForCaptchaEnum, ResponseWithDataType} from './api'; /*Импортируем \"instance\"\r\nдля более быстрого создания запросов. Также импортируем \"ResultCodeEnum\" -  список кодов ответа от сервера, которые\r\nиспользуются в TC \"getAuthUserData\" и в TC \"login\" в \"auth-reducer.ts\", для осуществления типизации. Так же для\r\nтипизации импортируем \"ResultCodeForCaptchaEnum\" - список кодов ответа от сервера, которые используются в TC \"login\"\r\nв \"auth-reducer.ts\". В добавок импортируем общий тип \"ResponseWithDataType\" для некоторых ответов от сервера со схожей\r\nструктурой ответа.*/\r\n\r\n\r\ntype MeResponseDataType = { /*Создали отдельный тип для \"data\" для запроса \"me\" из \"authAPI\". Используется для\r\nуточнения в типе \"ResponseType\". Этот объект \"data\" должен содержать информацию о залогиненном пользователе.*/\r\n        id: number /*\"ID\" залогиненного пользователя, которое должно быть числом.*/\r\n        email: string /*\"Email\" залогиненного пользователя, который должен быть строкой.*/\r\n        login: string /*\"Login\" залогиненного пользователя, который должен быть строкой.*/\r\n};\r\n\r\ntype LoginResponseDataType = { /*Создали отдельный тип для \"data\" для запроса \"login\" из \"authAPI\". Используется для\r\nуточнения в типе \"ResponseType\".Этот объект \"data\" должен содержать следующие свойства с указанными типами.*/\r\n    userId: number /*\"ID\" залогиненного пользователя, которое должно быть числом.*/\r\n};\r\n\r\ntype LogoutResponseDataType = { /*Создали отдельный тип для \"data\" для запроса \"logout\" из \"authAPI\". Используется для\r\nуточнения в типе \"ResponseType\".Этот объект \"data\" должен содержать следующие свойства с указанными типами.*/\r\n    [key: string]: any /*Таким образом мы указали, что здесь могут быть любые свойства объекта.*/\r\n};\r\n\r\n\r\nexport const authAPI = { /*\"usersAPI\" содержит запросы, связанные с аутентификацией.*/\r\n    me() { /*Эта функция является запросом на запрос информации для залогинивания через наше приложение.\r\n    Перед этим необходимо либо залогиниться на API сайта, чтобы создались \"Cookie\", чтобы при запросе сервер мог нас\r\n    идентифицировать, или же ввести данные для залогинивания в нашем приложении.*/\r\n        return (\r\n            instance.get<ResponseWithDataType<MeResponseDataType>>(`auth/me`) /*Делаем GET-запрос для залогинивания\r\n            в нашем приложении на адрес как указано в API сайта. Указали, что этот запрос \"GET\" возвращает промис с\r\n            типом \"ResponseType<MeResponseDataType>\".*/\r\n                .then(response => response.data) /*\"then\" создает \"promise\". Какие-то данные придут от сервера и\r\n                выполниться стрелочная функция \"response\". Данные, которые конкретно будут нужны нам, будут находиться\r\n                внутри \"response.data\". Это \"data\" создается самим запросом и туда помещается информация от сервера.\r\n                Сама же структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    - еще один объект \"data\", который в свою очередь содержит \"id\" (\"ID\" залогиненного пользователя),\r\n                    \"email\" (\"email\" залогиненного пользователя) и\"login\" (\"login\" залогиненного пользователя).\r\n                    - \"resultCode\" - код ответа сервера (\"0\" - все хорошо, \"1\" - какая-то ошибка).\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время залогинивания).\r\n                Затем получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш\r\n                \"state\" при помощи TC \"getAuthUserData\" в \"auth-reducer.ts\".*/\r\n        );\r\n    },\r\n\r\n    login(email: string, password: string, rememberMe = false, captcha: null | string = null) { /*Эта функция\r\n    является запросом на залогинивание через наше приложение. Перед этим не нужно залогиниваться на API сайта, чтобы\r\n    создались \"Cookie\". Нужно просто ввести свои данные для залогинивания в нашем приложении. На сервер отправится\r\n    запрос вместе с объектом данных, которые включают в себя почту (должна быть строкой), пароль (должен быть строкой),\r\n    флаг \"Запомнить?\" (должен быть булева типа) и введенная капча (должна быть строкой или \"null\", то есть\r\n    быть пустым), если таковая была.*/\r\n        return (\r\n            instance.post<ResponseWithDataType<LoginResponseDataType, ResultCodeEnum | ResultCodeForCaptchaEnum>>\r\n            (`auth/login`, {email, password, rememberMe, captcha})\r\n            /*Делаем POST-запрос для залогинивания в нашем приложении на адрес как указано в API сайта. В результате\r\n            сервер создаст куки. Указали, что этот запрос \"POST\" возвращает промис с типом\r\n            \"ResponseType<LoginResponseDataType, ResultCodeEnum | ResultCodeForCaptchaEnum>\".*/\r\n                .then(response => response.data) /*\"then\" создает \"promise\". Какие-то данные придут от сервера и\r\n                выполниться стрелочная функция \"response\". Данные, которые конкретно будут нужны нам, будут находиться\r\n                внутри \"response.data\". Эта \"data\" создается самим запросом и туда помещается информация от сервера.\r\n                Сама же структура данных в \"data\" определяется сервером. Согласно API сервера там находятся\r\n                    - \"resultCode\" - код, означающий успешно ли мы залогинились или нет (\"0\" - все хорошо,\r\n                    \"10\" - нужно ввести капчу).\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время залогинивания).\r\n                    - \"data\" - объект, содержащий свойство \"userId\" с \"ID\" залогиненного пользователя.\r\n                Получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                чтобы осуществить логинизацию пользователя при помощи TC \"login\" в \"auth-reducer.ts\".*/\r\n        );\r\n    },\r\n\r\n    logout() { /*Эта функция является запросом на разлогинивание через наше приложение. Перед этим нужно быть уже\r\n    залогинен, чтобы создались \"Cookie\".*/\r\n        return (\r\n            instance.delete<ResponseWithDataType<LogoutResponseDataType>>(`auth/login`) /*Делаем DELETE-запрос для\r\n            разлогинивания в нашем приложении на адрес как указано в API сайта. В результате сервер удалит куки.\r\n            Указали, что этот запрос \"DELETE\" возвращает промис с типом \"ResponseType<LogoutResponseDataType>\".*/\r\n                .then(response => response.data)/*\"then\" создает \"promise\". Какие-то данные придут от сервера, которые\r\n                будут находиться внутри \"response\". Внутри \"response\" будет \"data\". Эта \"data\" создается самим запросом\r\n                и туда помещается информация от сервера. Сама же структура данных в \"data\" определяется сервером.\r\n                Согласно API сервера там находятся:\r\n                    - \"resultCode\" - код, означающий успешно ли мы залогинились или нет (\"0\" - все хорошо,\r\n                    другие номера - какая-то ошибка).\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время разлогинивания).\r\n                    - \"data\" - пустой объект, потенциально может содержать какую-то дополнительную информацию.\r\n                    Получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы осуществить разлогинивание\r\n                    пользователя при помощи TC \"logout\" в \"auth-reducer.ts\".*/\r\n        );\r\n    }\r\n};","/*\r\nЭтот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер, касающиеся защиты нашего приложения\r\n(например, капчи), чтобы компоненты не создавали \"side effects\" такого типа. Этот файл отвечает за \"DAL\" -\r\n\"Data Access Layer\".\r\n*/\r\n\r\nimport {instance} from './api'; /*Импортируем \"instance\" для более быстрого создания запросов.*/\r\n\r\n\r\n/*Создаем тип для промиса, который будет возвращаться из запроса \"GET\" в \"getCaptchaURL\" из \"securityAPI\".*/\r\ntype getCaptchaURLResponseType = { /*Промис должен содержать объект, который состоит из следующих свойств с указанными\r\nтипами.*/\r\n    url: string /*Информация о пути к изображению с капчей должна быть строкой.*/\r\n};\r\n\r\n\r\nexport const securityAPI = { /*\"usersAPI\" содержит запросы, связанные с безопасностью.*/\r\n    getCaptchaURL() { /*Если нашему серверу необходимо, чтобы мы ввели капчу после нескольких неудачных попыток\r\n    залогиниться, то он сообщит браузеру, что тот должен сделать запрос на специальный \"endpoint\" и в ответ получить\r\n    картинку с капчей (в виде объекта, содержащего URL). Эта функция является запросом на получение капчи.*/\r\n        return (\r\n            instance.get<getCaptchaURLResponseType>(`security/get-captcha-url`) /*Указываем, что добавляем к\r\n            базовому URL, указанному в \"instance\", чтобы отправить запрос на сервер для получения капчи. Указали, что\r\n            этот запрос \"GET\" возвращает промис с типом \"getCaptchaURLResponseType\".*/\r\n                .then(response => response.data)/*\"then\" создает \"promise\". Какие-то данные придут от сервера и\r\n                выполниться стрелочная функция \"response\". Данные, которые конкретно будут нужны нам, будут находиться\r\n                внутри \"response.data\". Это \"data\" создается самим запросом и туда помещается информация от сервера.\r\n                Сама же структура данных в \"data\" определяется сервером. Согласно API сервера там находится строковой\r\n                элемент \"url\", в котором указан URL капчи.\r\n                Затем получив ответ от сервера в виде нужных данных, возвращаем их далее, чтобы установить их в наш\r\n                \"state\" при помощи TC \"getCaptchaURL\" в \"auth-reducer.ts\".*/\r\n        );\r\n    }\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за аутентификацию и связанные с ней процессы. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {authAPI} from '../api/auth-api'; /*Импортируем блоки запросов, связанных с аутентификацией.*/\r\nimport {securityAPI} from '../api/security-api'; /*Импортируем блоки запросов, связанных с капчей.*/\r\nimport {ResultCodeEnum, ResultCodeForCaptchaEnum} from '../api/api'; /*Импортируем списки кодов ответов от сервера.*/\r\n\r\nimport {FormAction, stopSubmit} from 'redux-form'; /*Импортируем специальный AC \"stopSubmit\" из библиотеки \"redux-form\",\r\nкоторый сообщает UI, что что-то пошло не так, и останавливает \"submit\" данных в форме. Импортировали \"FormAction\", чтобы\r\nсоздать тип для объектов \"action\", который передается в \"thunks\" и TC.*/\r\n\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialAuthStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    id: null as number | null, /*Свойство, которое хранит \"ID\" залогиненного пользователя. Указываем, что изначально\r\n    это свойство может иметь тип \"null\", то есть быть пустым, или быть числом.*/\r\n    email: null as string | null, /*Свойство, которое хранит \"email\" залогиненного пользователя. Указываем, что\r\n    изначально это свойство может иметь тип \"null\", то есть быть пустым, или быть строкой.*/\r\n    login: null as string | null, /*Свойство, которое хранит \"login\" залогиненного пользователя. Указываем, что\r\n    изначально это свойство может иметь тип \"null\", то есть быть пустым, или быть строкой.*/\r\n    isAuth: false, /*Свойство, которое указывает залогинен ли пользователь.*/\r\n    captchaURL: null as string | null /*Свойство, которое хранит URL изображения с капчей. Указываем, что изначально\r\n    это свойство может иметь тип \"null\", то есть быть пустым, или быть строкой.*/\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst authReducer = (state = initialState, action: ActionsType): InitialAuthStateType => { /*Указываем, что тип\r\n\"state\" на выходе имеет тот же тип \"InitialAuthStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case 'demo-spa/auth-reducer/SET-USER-DATA':\r\n        case 'demo-spa/auth-reducer/SET-CAPTCHA-URL': /*Здесь для обоих случаев один и тот же код потому, что в обоих\r\n        соотвествующих AC используется \"payload\". Благодаря деструктуризации мы сможем передать нужные значения свойств\r\n        из \"payload\" в нужные свойства \"state\" при совпадении имен свойств.*/\r\n            return { /*Устанавливаем данные по залогиненному пользователю в \"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                ...action.payload, /*Объект \"action\" будет иметь объект \"payload\", который содержит \"id\", \"email\",\r\n                \"login\" и \"isAuth\". Аналогично может прийти такой же объект \"payload\", но он может содержать только\r\n                \"captchaURL\" - URL изображения с капчей. Делаем глубокую копию, чтобы установить эти данные в \"state\",\r\n                деструктурируя этот объект \"payload\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InferActionsTypes<typeof authAC>; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип \"InferActionsTypes\" для\r\nопределения типов всех объектов \"action\" у упакованных в единый объект \"authAC\" AC.*/\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const authAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные\r\nраннее на основе каждого AC. Также вверху удалили все константы со значениями для \"type\" и указывываем их сразу в AC,\r\nтак как \"TypeScript\" не даст нам допустить ошибку при указании этих \"types\" в \"reducer\". Согласно модульному паттерну\r\n\"Redux Ducks\", чтобы избежать случаев одиноковых значений свойств \"type\" из-за чего один и тот же объект \"action\" может\r\nсработать в нескольких \"reducers\", в значениях свойств \"type\" в объекте \"action\" указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\". Также в конце везде добавили \"as const\", чтобы \"reducer\" адекватно\r\nвоспринимал объекты \"action\". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных\r\nтипов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/\r\n    setAuthUserData: (id: number | null, /*На входе получает \"ID\" пользователя, который должен быть числом или \"null\",\r\n                      то есть быть пустым.*/\r\n                      email: string | null, /*На входе получает \"email\" пользователя, который должен быть строкой или\r\n                      \"null\", то есть быть пустым.*/\r\n                      login: string | null, /*На входе получает \"login\" пользователя, который должен быть строкой или\r\n                      \"null\", то есть быть пустым.*/\r\n                      isAuth: boolean /*На входе получает информацию залогинен ли пользователь, которая должна быть\r\n                      булева типа.*/\r\n    ) => ({/*AC для установки данных залогиненного пользователя в \"state\".*/\r\n        type: 'demo-spa/auth-reducer/SET-USER-DATA', /*Обязательно свойство \"type\" для AC.*/\r\n        payload: { /*Объект с данными по залогиненному пользователю. Далее мы его деструктурируем в \"authReducer\".*/\r\n            id, /*Свойство, которое хранит \"ID\" залогиненного пользователя.*/\r\n            email, /*Свойство, которое хранит \"email\" залогиненного пользователя.*/\r\n            login, /*Свойство, которое хранит \"login\" залогиненного пользователя.*/\r\n            isAuth /*Свойство, которое указывает залогинен ли пользователь.*/\r\n        }\r\n    } as const),\r\n\r\n    setCaptchaURL: (captchaURL: string) => ({ /*AC для установки URL изображения с капчей в \"state\". На входе получает\r\n    \"captchaURL\", которое дожно быть строкой.*/\r\n        type: 'demo-spa/auth-reducer/SET-CAPTCHA-URL', /*Обязательно свойство \"type\" для AC.*/\r\n        payload: { /*Объект с URL изображения с капчей. Далее мы его деструктурируем в \"authReducer\".*/\r\n            captchaURL /*Свойство, которое хранит URL изображения с капчей.*/\r\n        }\r\n    } as const)\r\n};\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype ThunkType = BaseThunkType<ActionsType | FormAction>; /*Создали тип для \"thunks\". Поскольку в TC\r\n\"login\" мы диспатчим \"stopSubmit\" из библиотеки \"redux-form\", поэтому здесь мы указали еще \"FormAction\" из библиотеки\r\n\"redux-form\", так как в файле декларации \"stopSubmit\" указано, что он \"extends\" от \"FormAction\". Но из-за этого теперь\r\nмы можем диспатчить любой объект \"action\", что естественно нежелательно для нас.*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const getAuthUserData = (): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных залогиненного пользователя в \"state\". Здесь вместо использования \".then\" мы\r\nиспользуем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе возвращает\r\n\"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\"\r\nи дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\"\r\nбудет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await authAPI.me(); /*Делаем запрос на сервер для получения данных залогиненного пользователя.\r\n    Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как\r\n    асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === ResultCodeEnum.Success) { /*Если свойство \"resultCode\", которое пришло в ответе от\r\n    сервера, содержит код \"0\", то есть ошибки при залогинивании не было, то*/\r\n        let {id, email, login} = response.data; /*деструктурируем объект \"data\", который пришел в ответе от сервера,\r\n        и получаем \"ID\", \"email\" и \"login\" залогиненного пользователя*/\r\n        dispatch(authAC.setAuthUserData(id, email, login, true)); /*и устанавливаем эти данные в \"state\" при\r\n        помощи AC \"setAuthUserData\", четвертый параметр это \"isAuth\", чтобы сообщить, что пользователь залогинился.*/\r\n    }\r\n};\r\n\r\nexport const login = (email: string, /*На входе получает \"email\" пользователя, который должен быть строкой.*/\r\n                      password: string, /*На входе получает пароль пользователя, который должен быть строкой.*/\r\n                      rememberMe: boolean, /*На входе получает информацию запомнить ли пользователя, которая должна быть\r\n                      булева типа.*/\r\n                      captcha: string /*На входе получает путь к капче, который должен быть строкой.*/\r\n): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления логинизации через наше приложение. Здесь вместо использования \".then\" мы используем\r\n\"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Также этот TC на выходе возвращает\r\n\"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и\r\nдополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\"\r\nбудет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await authAPI.login(email, password, rememberMe, captcha); /*Делаем запрос на сервер для\r\n    залогинивания пользователя. Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\".\r\n    Здесь \"return\" не нужен, так как асинхронная функция автоматически вернет промис, то есть можно сразу писать логику\r\n    по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === ResultCodeEnum.Success) { /*Если свойство \"resultCode\", которое пришло в ответе от\r\n    сервера, содержит код \"0\", то есть ошибки при залогинивании не было, то*/\r\n        dispatch(getAuthUserData()) /*вызываем TC \"getAuthUserData\" для запроса и установки данных залогиненного\r\n        пользователя в \"state\".*/\r\n    } else {\r\n        if (response.resultCode === ResultCodeForCaptchaEnum.CaptchaIsRequired) { /*Иначе если свойство \"resultCode\",\r\n        которое пришло в ответе от сервера, содержит код \"10\", то есть нужно ввести капчу, то*/\r\n            dispatch(getCaptchaURL()); /*вызываем TC \"getCaptchaURL\" для получения URL изображения с капчей с сервера\r\n            и установки его в \"state\".*/\r\n        } /*Также иначе если пришло какое-то информационное сообщение об ошибке при логинизации от сервера в\r\n        массиве \"messages\", то мы положим первый элемент этого массива в переменную \"message\", если длина этого массива\r\n        больше нуля, или же положим в переменную \"message\" текст \"unknown error\".*/\r\n        let message = response.messages.length > 0 ? response.messages[0] : 'unknown error'\r\n        dispatch(stopSubmit('login', {_error: message})); /*Затем задиспатчим специальный AC \"stopSubmit()\"\r\n        из библиотеки \"redux-form\", который сообщит UI, что что-то пошло не так, и остановит \"submit\" данных. Первым\r\n        параметром указывается какую форму необходимо остановить, а вторым параметром указывается объект, в котором\r\n        должно быть свойство \"_error\" (из библиотеки \"redux-form\", означает ошибку для всей формы, но здесь можно\r\n        использовать и имена других полей, которые мы создали), которому присваивается значение с текстом ошибки.\r\n\r\n        Но сейчас со \"stopSubmit\" проблемы. При его использовании возникает проблема асинхроности, так как\r\n        библиотека \"redux-form\" вызывает \"setSubmitSucceed()\" сразу после \"stopSubmit()\", не успев вернуть ошибку.\r\n        Как итог сообщение об ошибке исчезает мгновенно и его можно увидеть только при дебаге. Можно использовать\r\n        такой костыль:\r\n        setTimeout(async () => await dispatch(stopSubmit('login', {_error: message})))\r\n\r\n        Но у меня все работает, возможно потому, что у меня не самая последняя версия библиотеки \"redux-form\" (8.3.6).*/\r\n    }\r\n};\r\n\r\nconst getCaptchaURL = (): ThunkType => async (dispatch) => {\r\n/*Это TC для получения URL изображения с капчей с сервера и установки его в \"state\". Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе\r\nвозвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\",\r\n\"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали,\r\nчто в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await securityAPI.getCaptchaURL(); /*Делаем запрос на сервер для получения капчи. Здесь будет\r\n    ожидаться промис. Когда он зарезольвиться, он сохраниться в \"data\". Здесь \"return\" не нужен, так как асинхронная\r\n    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n    const captchaURL = response.url; /*Получив ответ от сервера, сохраняем из ответа сервера URL капчи.*/\r\n\r\n    dispatch(authAC.setCaptchaURL(captchaURL)); /*Затем устанавливаем этот URL капчи в \"state\" при помощи AC\r\n    \"setCaptchaURL\".*/\r\n};\r\n\r\nexport const logout = (): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления логаута. Здесь вместо использования \".then\" мы используем \"async/await\". Промис будет\r\nожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\",\r\nсозданный нами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя\r\nто, что возвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    const response = await authAPI.logout(); /*Делаем запрос на сервер для разлогинивания пользователя. Здесь будет\r\n    ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как асинхронная\r\n    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === 0) { /*Если свойство \"resultCode\", которое пришло в ответе от сервера, содержит\r\n    код \"0\", то есть ошибки при разлогинивании не было, то*/\r\n        dispatch(authAC.setAuthUserData(null, null, null, false)); /*обнуляем данные пользователя\r\n        в \"state\" при помощи AC \"setAuthUserData\", четвертый параметр это \"isAuth\", чтобы сообщить, что пользователь\r\n        разлогинился.*/\r\n    }\r\n};\r\n\r\n\r\nexport default authReducer; /*Экспортируем \"authReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"authReducer\", экспорт необходим для импорта.*/","/*\r\nСелектор - это функция, которая принимает \"state\", достает из него то, что ей нужно и возвращает это в BLL.\r\nСелекторы осуществляют определенную выборку данных из \"state\".\r\nЗдесь содержаться селекторы для данных из \"auth-reducer.ts\".\r\n*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\nexport const getIsAuth = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает информацию о том, что являемся ли мы залогинены в приложение или нет. На входе этот селектор принимает\r\n\"state\" с типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.auth.isAuth\r\n};\r\n\r\nexport const getCaptchaURL = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает URL капчи при логинизации. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы\r\nсоздали и импортировали сюда.*/\r\n    return state.auth.captchaURL\r\n};\r\n\r\nexport const getLogin = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает \"login\" залогиненного пользователя. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который\r\nмы создали и импортировали сюда.*/\r\n    return state.auth.login\r\n};","export default __webpack_public_path__ + \"static/media/headerlogo.790903fe.png\";","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Link, NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\nНо здесь мы используем \"Link\", который является аналогом \"NavLink\".\r\n*/\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI\r\nнежелательно общаться с BLL напрямую. Библиотека \"react-redux\" предоставляет продвинутые инструкции по созданию\r\nконтейнерных компонент и контекста.\r\n\"useSelector\" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.\r\n\"useDispatch\" - это hook, который принимает AC или TC и диспатчит их.\r\n*/\r\n\r\nimport {logout} from '../../redux/auth-reducer'; /*Подключаем TC \"logout\" из \"auth-reducer\".*/\r\n\r\nimport {\r\n    getLogin, /*Импортируем селектор, который возвращает \"login\" залогиненного пользователя.*/\r\n    getIsAuth /*Импортируем селектор, который возвращает информацию о том, что являемся ли мы залогинены в приложение\r\n    или нет.*/\r\n} from '../../redux/auth-selectors';\r\n\r\nimport styles from './Header.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport headerLogoSource from '../../assets/images/headerlogo.png'; /*Импортируем из ассетов проекта логотип сайта.*/\r\nimport {Layout, Menu, Avatar, Row, Col, Button, Image} from 'antd';\r\n/*\r\nИмпортируем из UI-фреймфорка \"Ant Design\" следующее:\r\n\"Layout\" - для получения из него объекта \"Header\" , чтобы использовать его как тег внутри для реализации хэдера нашего\r\nприложения;\r\n\"Menu\" - для реализации элементов меню;\r\n\"Avatar\" - для реализации заглушки для аватара пользователя;\r\n\"Row\" - для реализации строк;\r\n\"Col\" - для реализации столбцов, в одной строке может быть 24 единицы столбцов;\r\n\"Button\" - для реализации кнопок;\r\n\"Image\" - для реализации элементов, отображающих изображения.\r\n*/\r\nimport {UserOutlined} from '@ant-design/icons'; /*Импортируем иконки из UI-фреймфорка \"Ant Design\".*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n\r\n};\r\n\r\n\r\n/*\r\n\"Header\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Header(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Header\" является компонентом, который отрисовывает \"хэдер\" нашего сайта, который содержит логотип сайта и отдельный\r\nблок, отображающий ссылку на форму логина или имя залогиненного пользователя и кнопку логаута.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nexport const Header: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n    const {Header} = Layout; /*При помощи деструктуризации берем объект \"Header\" из объекта \"Layout\" из UI-фреймфорка\r\n    \"Ant Design\", чтобы использовать его как тег внутри для реализации хэдера нашего приложения.*/\r\n\r\n    const isAuth = useSelector(getIsAuth); /*При помощи хука \"useSelector\", передав в него селектор \"getIsAuth\",\r\n    получаем информацию о том, что являемся ли мы залогинены в приложение или нет.*/\r\n\r\n    const login = useSelector(getLogin); /*При помощи хука \"useSelector\", передав в него селектор \"getLogin\", получаем\r\n    \"login\" залогиненного пользователя.*/\r\n\r\n    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука \"useDispatch\".*/\r\n\r\n    const logoutCallback = () => { /*Таким образом используем TC \"logout\" для использования его ниже. Этот синтаксис\r\n    похож на тот, который мы использовали при создании \"mapDispatchToProps\" в самом начале (смотри компонент\r\n    \"DialogsContainer.tsx\").*/\r\n        dispatch(logout());\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <Header className={styles.header}> {/*Этот элемент \"Header\" и есть наш корневой\r\n        элемент. Внутри он содержит один элемент \"Row\", что означает, что внутри содержится только одна строка\r\n        элементов.*/}\r\n            <Row> {/*Внутри этого элемента \"Row\" используется несколько элементов \"Col\", обозначающих колонки в\r\n            строке.*/}\r\n                <Col span={2}> {/*Первый элемент \"Col\" занимает 2 единицы из 24-х. Внутри находится элемент \"Image\" c\r\n                изображением логотипа сайта \"headerLogoSource\". Этот элемент \"Image\" содержит атрибут \"preview\" со\r\n                значением \"false\", чтобы была отключена опция увеличения изображения для просмотра, которая\r\n                предоставляется UI-фреймворком \"Ant Design\".*/}\r\n                    <Image src={headerLogoSource} alt='' preview={false}/>\r\n                </Col>\r\n\r\n                <Col span={17}> {/*Второй элемент \"Col\" занимает 17 единиц из 24-х. Внутри находится элемент \"Menu\",\r\n                представляющий из себя меню с одним элементом, который в свою очередь содержит элемент \"Link\",\r\n                представляющий из себя ссылку для перехода на страницу пользователей. Элемент \"Menu\" благодаря атрибуту\r\n                \"theme\" со значением \"dark\" имеет темную тему, а благодаря атрибуту \"mode\" со значением \"horizontal\"\r\n                имеет горизонтальный тип расположения.*/}\r\n                    <Menu theme='dark' mode='horizontal'>\r\n                        <Menu.Item key='/users/'>\r\n                            <Link to='/users/'>Users</Link>\r\n                        </Menu.Item>\r\n                    </Menu>\r\n                </Col>\r\n\r\n                {isAuth /*Если свойство \"isAuth\", которое указывает залогинен ли пользователь, является \"TRUE\", то*/\r\n                    ? /*отрисуется пустой элемент \"<>\", содержащий три элемента \"Col\". Первый элемент \"Col\" содержит\r\n                    элемент \"Avatar\", представляющий из себя заглушку для аватара пользователя, и занимает 1 единицу.\r\n                    Этот элемент \"Avatar\" имеет атрибут \"style\" для стилизации цвета заднего фона этого элемента, и\r\n                    атрибут \"icon\" со значением \"UserOutlined\", чтобы подгрузить иконку из списка иконок, которые\r\n                    предоставляются UI-фреймворком \"Ant Design\". Второй элемент \"Col\" содержит элемент \"a\", содержащий\r\n                    внутри себя \"login\" залогиненного пользователя, и занимает 2 единицы. Третий элемент \"Col\" содержит\r\n                    элемент \"Button\", который является кнопкой логаута (сработает TC \"logout\"), и занимает 2 единицы.*/\r\n                    <>\r\n                        <Col span={1}>\r\n                            <Avatar icon={<UserOutlined/>}/>\r\n                        </Col>\r\n\r\n                        <Col span={2}>\r\n                            <a href=''>{login}</a>\r\n                        </Col>\r\n\r\n                        <Col span={2}>\r\n                            <Button onClick={logoutCallback}>Log out</Button>\r\n                        </Col>\r\n                    </>\r\n                    : /*Иначе отрисуется один элемент \"Col\", занимающий 2 единицу и содержащий элемент \"Button\", который\r\n                    в свою очередь содержит элемент \"Link\" для перехода на страницу логинизации. Этот элемент \"Col\"\r\n                    имеет атрибут \"offset\", благодаря которому этот элемент сдвигается вправо на 3 единицы.*/\r\n                    <Col span={2} offset={3}>\r\n                        <Button>\r\n                            <Link to={'/login/'}>Log in</Link>\r\n                        </Button>\r\n                    </Col>}\r\n            </Row>\r\n        </Header>\r\n    );\r\n};","/*\r\nСелектор - это функция, которая принимает \"state\", достает из него то, что ей нужно и возвращает это в BLL.\r\nСелекторы осуществляют определенную выборку данных из \"state\".\r\nЗдесь содержаться селекторы для данных из \"sidebar-reducer.ts\".\r\n*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\nexport const getSidebar = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает весь \"state\" из \"sidebar-reducer.ts\". На входе этот селектор принимает \"state\" с типом \"AppStateType\",\r\nкоторый мы создали и импортировали сюда.*/\r\n    return state.sidebar\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './Sidebar.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {AvatarSourceType} from '../../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    id: number /*\"ID\" друга в онлайне должно быть числом.*/\r\n    name: string /*Имя друга в онлайне должно быть числом.*/\r\n    avatar: AvatarSourceType /*Аватар друга в онлайне должен быть типа \"AvatarSourceType\".*/\r\n};\r\n\r\n\r\n/*\r\n\"Sidebar\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Sidebar(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"SideBar\" является компонентом, который описывает типовое отображение друзей в онлайне в навигационном меню сайта.\r\nЭтот компонент подключается в компоненте \"NavBar\".\r\n*/\r\nexport const SideBar: React.FC<PropsType> = ({id, name, avatar}) => { /*Указываем какие именно \"props\" мы\r\nполучаем, чтобы не писать далее \"props.id\", \"props.name\" и так далее:\r\n- \"id\" - \"ID\" друга в онлайне;\r\n- \"name\" - имя друга в онлайне;\r\n- \"avatar\" - аватар друга в онлайне.\r\nТакое мы делаем только в функциональных компонентах. Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном\r\nкомпоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n    let path = '/dialogs/' + id; /*Путь для \"NavLink\" формируется на основе \"ID\" пользователя, который берется из\r\n    параметров \"props\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <nav className={styles.sidebar}> {/*Этот элемент \"nav\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовой пункт меню навигации по друзьям в онлайне, который будет\r\n        отрисовываться в компоненте \"NavBar\" при помощи метода \"map\".*/}\r\n            <div>\r\n                <NavLink to={path} activeClassName={styles.active}> {/*Типовой пункт меню навигации по друзьям в онлайне\r\n                содержит элемент \"NavLink\".*/}\r\n                    <img src={avatar} alt=''/> {/*Этот элемент \"NavLink\" содержит аватар пользователя, ссылка\r\n                    на который берется из параметров \"props\".*/}\r\n\r\n                    <div>{name}</div> {/*Также этот элемент \"NavLink\" содержит имя пользователя, которое\r\n                    берется из параметров \"props\".*/}\r\n                </NavLink>\r\n            </div>\r\n        </nav>\r\n    );\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Link, NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\nНо здесь мы используем \"Link\", который является аналогом \"NavLink\".\r\n*/\r\nimport {useSelector} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI\r\nнежелательно общаться с BLL напрямую. Библиотека \"react-redux\" предоставляет продвинутые инструкции по созданию\r\nконтейнерных компонент и контекста.\r\n\"useSelector\" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.\r\n*/\r\n\r\nimport {getSidebar} from '../../redux/sidebar-selectors'; /*Импортируем селектор, который возвращает весь \"state\" из\r\n\"sidebar-reducer.ts\".*/\r\n\r\nimport {SideBar} from './Sidebar/Sidebar'; /*Подключаем компонент \"Sidebar\".*/\r\n\r\nimport styles from './Navbar.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport {Layout, Menu} from 'antd';\r\n/*\r\nИмпортируем из UI-фреймфорка \"Ant Design\" следующее:\r\n\"Layout\" - для получения из него объекта \"Sider\" , чтобы использовать его как тег внутри для реализации навигационного\r\nменю;\r\n\"Menu\" - для реализации элементов меню.\r\n*/\r\nimport {\r\n    UserOutlined,\r\n    ProfileOutlined,\r\n    BuildOutlined,\r\n    MessageOutlined,\r\n    TeamOutlined,\r\n    HeartOutlined,\r\n    AlertOutlined,\r\n    ThunderboltOutlined,\r\n    ToolOutlined,\r\n    CommentOutlined\r\n} from '@ant-design/icons'; /*Импортируем иконки из UI-фреймфорка \"Ant Design\".*/\r\n\r\n\r\n/*Создали отдельный тип для объекта \"location\" из функции \"withRouter\" из библиотеки \"react-router-dom\".*/\r\ntype PathnameType = {\r\n    location: {\r\n        pathname: string\r\n    }\r\n};\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = PathnameType;\r\n\r\n\r\n/*\r\n\"Navbar\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Navbar(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Navbar\" является компонентом, который отрисовывает меню навигации нашего сайта.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nexport const Navbar: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n    const sidebar = useSelector(getSidebar); /*При помощи хука \"useSelector\", передав в него селектор \"getSidebar\",\r\n    получаем весь \"state\" из \"sidebar-reducer.ts\".*/\r\n\r\n    /*\r\n    В JSX в массив можно вкладывать компоненты.\r\n    В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде строки.\r\n    \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования исходного массива.\r\n    Метод \"map\" принимает стрелочную функцию.\r\n    То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n    и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    Потом будет браться следующий объект из исходного массива объектов\r\n    и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n    То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов.\r\n    В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n    Массив \"sidebarElements\" содержит список друзей в онлайне.\r\n    При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n    */\r\n    let sidebarElements = sidebar.friendsData.map(f => <SideBar name={f.name}\r\n                                                                id={f.id}\r\n                                                                avatar={f.avatar}\r\n                                                                key={f.id}/>);\r\n\r\n    const {SubMenu} = Menu; /*При помощи деструктуризации берем объект \"SubMenu\" из объекта \"Menu\" из UI-фреймфорка \"Ant\r\n    Design\", чтобы использовать его как тег внутри для реализации подменю.*/\r\n    const {Sider} = Layout; /*При помощи деструктуризации берем объект \"Sider\" из объекта \"Layout\" из UI-фреймфорка\r\n    \"Ant Design\", чтобы использовать его как тег внутри для реализации навигационного меню.*/\r\n\r\n    let subMenuKey = ['']; /*Создали массив строк, который в дальнейшем будет хранить значение атрибута \"key\" элементов\r\n    \"SubMenu\" и \"Menu.Item\" в меню ниже, чтобы мы могли знать какое подменю необходимо раскрывать исходя из пути, на\r\n    котором мы находимся.*/\r\n\r\n    const getSubMenuKey = (key: string) => { /*Создали специальную функцию \"getSubMenuKey\", для получения атрибутов\r\n    \"key\" элементов \"SubMenu\" и \"Menu.Item\" и записи их в наш массив \"subMenuKey\". На входе получает строковой\r\n    параметр.*/\r\n        while (subMenuKey.length > 0) { /*Каждый раз очищаем наш массив \"subMenuKey\", чтобы там не копились\r\n            значения.*/\r\n            subMenuKey.pop();\r\n        };\r\n\r\n        if (subMenuKey.length === 0) { /*Если наш массив \"subMenuKey\" пустой, то записываем в него соответствующий\r\n            ключ пункта меню.*/\r\n            subMenuKey.push(key);\r\n        };\r\n    };\r\n\r\n    /*При помощи конструкции \"switch/case\" заполняем наш строковой массив \"subMenuKey\" в зависимости от пути, на\r\n    котором мы находимся. \"props.location.pathname\" здесь находится строковое значение пути благодаря HOC\r\n    \"withRouter\".*/\r\n    switch (props.location.pathname) {\r\n        case '/profile/':\r\n        case '/dialogs/':\r\n            getSubMenuKey('sub1');\r\n            break;\r\n\r\n        case '/friends/':\r\n        case '/users/':\r\n        case '/chat/':\r\n            getSubMenuKey('sub2');\r\n            break;\r\n\r\n        case '/news/':\r\n        case '/music/':\r\n        case '/settings/':\r\n            getSubMenuKey('sub3');\r\n            break;\r\n    };\r\n\r\n    const getSubMenuKeyCallback = (event: any) => { /*Создали специальную функцию \"getSubMenuKeyCallback\", которая будет\r\n    вызываться при нажатии на пункты меню, брать атрибут \"key\" из пункта меню и сохранять его в наш массив \"subMenuKey\".\r\n    Нам это нужно, так как конструкция \"switch/case\" выше после нажатия на один из пунктов меню не позволяла выбирать\r\n    другие пункты меню, так как не подхватывались атрибуты \"key\" других пунктов меню при нажатии на эти пункты. Для\r\n    события \"event\" указали тип \"any\", так как пока не знаем какого он именно типа.*/\r\n        getSubMenuKey(event.key);\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <> {/*Этот элемент \"<>\" и есть наш корневой элемент.*/}\r\n            <Sider> {/*Отрисовываем элемент \"Sider\" для создания навигационного меню.*/}\r\n                <Menu /*Отрисовываем элемеет \"Menu\" для создания самого меню. Внутри используются элементы \"Submenu\" для\r\n                создания подменю и элементы \"Menu.Item\" для создания пунктов меню и подменю.*/\r\n                    className={styles.menu}\r\n                    mode='inline'\r\n                    selectedKeys={[props.location.pathname]} /*Используем атрибут \"selectedKeys\" для выделения\r\n                    подпунктов меню при их выборе. Мы этого добились задав значения атрибутам \"key\" элементов\r\n                    \"Menu.Item\" как пути, на которые эти подпункты меню переводят нас. Таким образом, при выборе любого\r\n                    подпункта меню мы получаем путь, на который перешли, который по своему значению равен одному из\r\n                    значений атрибута \"key\" какого-то подпункта меню, что мы можем использовать для указания какой\r\n                    подпункт меню нам нужно подсветить.*/\r\n                    openKeys={subMenuKey} /*Используем атрибут \"openKeys\" для разворачивания только тех подпунктов меню,\r\n                    пункты которых мы выбрали.*/\r\n                >\r\n                    <SubMenu key='sub1' icon={<UserOutlined/>} title='My Page' onTitleClick={getSubMenuKeyCallback}>\r\n                        <Menu.Item key='/profile/' icon={<ProfileOutlined/>}>\r\n                            <Link to='/profile/'>Profile</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/dialogs/' icon={<MessageOutlined/>}>\r\n                            <Link to='/dialogs/'>Dialogs</Link>\r\n                        </Menu.Item>\r\n                    </SubMenu>\r\n\r\n                    <SubMenu key='sub2' icon={<UserOutlined/>} title='People' onTitleClick={getSubMenuKeyCallback}>\r\n                        <Menu.Item key='/friends/' icon={<HeartOutlined/>}>\r\n                            <Link to='/friends/'>Friends</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/users/' icon={<TeamOutlined/>}>\r\n                            <Link to='/users/'>Users</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/chat/' icon={<CommentOutlined/>}>\r\n                            <Link to='/chat/'>Chat</Link>\r\n                        </Menu.Item>\r\n                    </SubMenu>\r\n\r\n                    <SubMenu key='sub3' icon={<BuildOutlined/>} title='Other' onTitleClick={getSubMenuKeyCallback}>\r\n                        <Menu.Item key='/news/' icon={<AlertOutlined/>}>\r\n                            <Link to='/news/'>News</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/music/' icon={<ThunderboltOutlined/>}>\r\n                            <Link to='/music/'>Music</Link>\r\n                        </Menu.Item>\r\n\r\n                        <Menu.Item key='/settings/' icon={<ToolOutlined/>}>\r\n                            <Link to='/settings/'>Settings</Link>\r\n                        </Menu.Item>\r\n                    </SubMenu>\r\n\r\n                    {sidebarElements} {/*Отрисовываем элементы сайдбара, отображающие друзей в онлайне.*/}\r\n                </Menu>\r\n            </Sider>\r\n        </>\r\n    );\r\n};","/*\r\nЭтот файл специально создан, чтобы в одном месте описать все AJAX-запросы на сервер, касающиеся страницы постраничного\r\nвывода пользователей, чтобы компоненты не создавали \"side effects\" такого типа. Этот файл отвечает за \"DAL\" -\r\n\"Data Access Layer\".\r\n*/\r\n\r\nimport {instance, ResponseWithDataType, ResponseWithItemsType} from './api'; /*Импортируем \"instance\" для более быстрого\r\nсоздания запросов. В добавок импортируем два общих типа \"ResponseWithDataType\" и \"ResponseWithItemsType\" для некоторых\r\nответов от сервера со схожей структурой ответа.*/\r\n\r\nimport {UserType} from '../types/types'; /*Подключаем типы.*/\r\n\r\n\r\nexport const usersAPI = { /*\"usersAPI\" содержит запросы, связанные со страницей с постраничным выводом пользователей.*/\r\n    getUsers(currentPage: number, pageSize: number, term: string =  '', friend: null | boolean = null) { /*Эта функция\r\n    является запросом на получение данных пользователей в постраничном выводе. Эти данные на сервере структурированы по\r\n    страницам, поэтому данная функция принимает четыре параметра:\r\n    - \"currentPage\" - текущая страница для отображения (1 \"default\"), должно быть числом;\r\n    - \"pageSize\" - количество пользователей на этой странице (от 10 (\"default\") до 100), должно быть числом;\r\n    - \"term\" - фильтр в виде строкового значения, которое будет получать сервер и искать наличие этого значения в именах\r\n    всех пользователей, чтобы в итоге вывести только таких пользователей, по умолчанию указана пустая строка;\r\n    - \"friend\" - еще один фильтр булева типа или типа \"null\", если указать в нем \"true\", то сервер выберет только тех\r\n    пользователей, которых мы фолловим, если указать \"false\" - только тех, кого мы не фолловим, если указать \"null\" или\r\n    вообще не указывать, то выберет всех пользователей, по умолчанию указано \"null\".*/\r\n        return (\r\n            instance.get<ResponseWithItemsType<UserType>>\r\n            (`users?page=${currentPage}&count=${pageSize}&term=${term}` + (friend === null ? '' : `&friend=${friend}`))\r\n            /*Указываем, что добавляем к базовому URL, указанному в \"instance\", \"users\", чтобы получить данные\r\n            пользователей. Знак \"?\" означает, что дальше идут параметры GET-запроса, знак \"&\" используется для\r\n            перечисления таких параметров. Названия этих параметров и ограничения их значений описываются в API сервера.\r\n            \"+ (friend === null ? '' : `&friend=${friend}`\" - здесь мы склеиваем строку с пустой строкой, если параметр\r\n            \"friend\" равен \"null\", иначе склеиваем со строками `&friend=true` или `&friend=false`, если в параметре\r\n            \"friend\" указали \"true\" или \"false\" соответственно. Также указали, что этот запрос \"GET\" возвращает промис с\r\n            типом \"GetItemsType<UserType>\".*/\r\n                .then(response => { /*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри\r\n                \"response.data\". Это \"data\" создается самим запросом и туда помещается информация от сервера. Сама же\r\n                структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                - \"items\" - массив с объектами, которые содержат данные по пользователям.\r\n                Каждый такой объект содержит следуюющее:\r\n                    - \"name\" - имя пользователя.\r\n                    - \"id\" - \"ID\" пользователя.\r\n                    - \"photos\": - объект с путями к фото пользователя.\r\n                        - \"small\" - уменьшенное фото.\r\n                        - \"large\" - увеличенное фото.\r\n                    - \"status\" - статус пользователя.\r\n                    - \"followed\" - говорит фолловим ли мы пользователя или нет.\r\n                - \"totalCount\" - количество всех пользователей.\r\n                - \"error\" - содержит сообщение об ошибке, если была.*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы установить их в наш \"state\" при помощи TC \"requestUsers\" в \"users-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    unfollow(id: number) { /*Эта функция является запросом на анфолловинг какого-либо пользователя. Оба запроса на\r\n    анфолловинг и фолловинг идут на один и тот же \"endpoint\", только для анфолловинга нужно делать DELETE-запрос,\r\n    а для фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать \"ID\" пользователя, которого\r\n    анфолловим или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи \"Cookie\" сервер\r\n    будет определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/\r\n        return (\r\n            instance.delete<ResponseWithDataType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,\r\n            указанному в \"instance\", \"follow\" и \"ID\" пользователя, которого анфолловим, чтобы сформировать запрос на\r\n            анфолловинг. Указали, что этот запрос \"DELETE\" возвращает промис с типом \"ResponseType\".*/\r\n                .then(response => { /*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри\r\n                \"response.data\". Эта \"data\" создается самим запросом и туда помещается информация от сервера. Сама же\r\n                структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    - \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя, \"0\" - все хорошо,\r\n                    \"1\" - какая-то ошибка.\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время анфолловинга пользователя).\r\n                    - \"data\" - какие-то дополнительные данные (в данный момент не используется).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы осуществить анфолловинг пользователя при помощи TC \"unfollow\" в \"users-reducer.ts\".*/\r\n                })\r\n        );\r\n    },\r\n\r\n    follow(id: number) { /*Эта функция является запросом на фолловинг какого-либо пользователя. Оба запроса на\r\n    анфолловинг и фолловинг идут на один и тот же \"endpoint\", только для анфолловинга нужно делать DELETE-запрос, а для\r\n    фолловинга нужно делать POST-запрос. Также в обоих случаях нужно указывать \"ID\" пользователя, которого анфолловим\r\n    или фолловим. Это параметр должен быть числом. Все это указано в API сервера. При помощи \"Cookie\" сервер будет\r\n    определять нас и знать для какого пользователя сделать фолловинг или анфолловинг.*/\r\n        return (\r\n            instance.post<ResponseWithDataType>(`follow/${id}`) /*Указываем, что добавляем к базовому URL,\r\n            указанному в \"instance\", \"follow\" и \"ID\" пользователя, которого фолловим, чтобы сформировать запрос на\r\n            фолловинг. Указали, что этот запрос \"POST\" возвращает промис с типом \"ResponseType\".*/\r\n                .then(response => { /*\"then\" создает \"promise\". Какие-то данные придут от сервера и выполниться\r\n                стрелочная функция \"response\". Данные, которые конкретно будут нужны нам, будут находиться внутри\r\n                \"response.data\". Эта \"data\" создается самим запросом и туда помещается информация от сервера. Сама же\r\n                структура данных в \"data\" определяется сервером. Согласно API сервера там находятся:\r\n                    - \"resultCode\" - код, означающий успешно ли прошло изменение статуса пользователя, \"0\" - все хорошо,\r\n                    \"1\" - какая-то ошибка.\r\n                    - \"messages\" - массив с информационными сообщениями от сервера (например, при какой-либо ошибке во\r\n                    время фолловинга пользователя).\r\n                    - \"data\" - какие-то дополнительные данные (в данный момент не используется).*/\r\n                    return response.data; /*Затем получив ответ от сервера в виде нужных данных, возвращаем их далее,\r\n                    чтобы осуществить фолловинг пользователя при помощи TC \"follow\" в \"users-reducer.ts\".*/\r\n                })\r\n        );\r\n    }\r\n};","/*\r\nЧтобы избавиться от повторяющегося кода в \"users-reducer.ts\" в \"reducer\" в \"FOLLOW\" и \"UNFOLLOW\", мы создали\r\nэтот файл, который содержит общую логику для \"FOLLOW\" и \"UNFOLLOW\". При помощи этой логики можно перебирать\r\nэлемента (объекты) в любом массиве и менять какое-либо свойство при срабатывании условия у какого-то\r\nэлемента (объекта) в этом массиве.\r\n*/\r\n\r\n\r\n/*\r\nУбрали в этой функции стрелочный синтаксис и типизировали ее следующим образом. Эта функция имеет три уточняющих тип\r\nпараметра \"T\", \"K\" и \"P\".\r\n\r\nУточняющий тип параметр \"T\" указывает какой тип имеют элементы в массиве элементов первого параметра \"items\" этой\r\nфункции. В случае использования этой функции в рамках фолловинга/анфолловинга пользователей это должен быть тип\r\n\"UserType\", так как первым параметром мы передаем в эту функцию массив объектов с типом \"UserType\", где каждый объект\r\nпредставляет из себя информацию о каком-то пользователе. Следовательно, на этот параметр \"T\" установлено ограничение,\r\nчто этот тип должен быть похож на какой-либо объект.\r\n\r\nВторым уточняющим тип параметром \"K\" мы должны указывать тип ключа из объектов массива из первого уточняющего тип\r\nпараметра \"T\", так как третьим параметром в эту функцию мы передаем \"objPropName\" - имя свойства в объектах, по которому\r\nидет проверка сравнением, в случае фолловинга/анфолловинга пользователей это строковое значение 'id'. Чтобы получить\r\nключи объектов с типом \"T\" мы используем \"keyof T\". Это выдаст все ключи, например, того же типа \"UserType\": \"name\",\r\n\"id\", \"photos\", \"status\", \"followed\". И опять же, в случае фолловинга/анфолловинга пользователей мы передаем третьим\r\nпараметром строковое значение 'id', что будет совпадать с одним из этих полученных ключей. Следовательно, на параметр\r\n\"T\" установлено ограничение, что это тип должен быть ключами первого параметра \"T\", то есть \"keyof T\", и в случае\r\nфолловинга/анфолловинга пользователей мы укажем \"keyof UserType\".\r\n\r\nВторым параметром в эту функцию мы передаем \"itemID\" - значение для сравнения при поиске нужного объекта в массив,\r\nв случае фолловинга/анфолловинга пользователей это \"ID\" пользователя для фолловинга/анфолловинга. Следовательно, его тип\r\nуказан как \"T[K]\", так как опять же в случае фолловинга/анфолловинга пользователей это будет выглядеть как\r\n\"UserType['id']\", что равно \"UserType.id\", то есть мы получим значение свойства \"id\" в объекте с типом \"UserType\",\r\nкоторый содержит информацию по пользователю, которого мы пытаемся зафолловить или перестать фолловить.\r\n\r\nТретьим уточняющим тип параметром \"P\" мы должны указывать тип объекта (который мы передаем в эту функцию четвертым\r\nпараметром \"newObjProps\") со свойствами и их значениями, который нужно подменить на место старого в найденном объекте, в\r\nслучае фолловинга/анфолловинга пользователей мы должны поменять \"{followed: false}\" на \"{followed: true}\" для фолловинга\r\nи \"{followed: true}\" на \"{followed: false}\" для анфолловинга в найденном объекте с типом \"UserType\", который содержит\r\nинформацию по пользователю, которого мы пытаемся зафолловить или перестать фолловить. Следовательно, четвертый параметр\r\n\"newObjProps\" в этой функции, опять же, в случае фолловинга/анфолловинга пользователей должен быть одним из свойств\r\nобъекта с типом \"UserType\" - свойством \"followed\", поэтому на уточняющий тип параметр \"P\" уставлено ограничение, что он\r\nчастично или полностью должен копировать первый уточняющий параметр \"T\", то есть в случае фолловинга/анфолловинга\r\nпользователей тип \"UserType\", который как раз содержит свойство \"followed\". Это мы делаем при помощи \"Partial\" из\r\n\"TypeScript\" - \"P extends Partial<T>\", , и в случае фолловинга/анфолловинга пользователей мы укажем \"Partial<UserType>\".\r\n\r\nТакже в этой функции указано, что на выходе мы возвращаем массив объектов с типом \"T\", так как суть этой функции взять\r\nмассив каких-то объектов с определенным типом, найти какой-то интересующий нас объект среди этих объектов, у этого\r\nобъекта поменять значение какого-то свойство или значения нескольких каких-то свойств, и вернуть снова массив каких-то\r\nобъектов с тем же типом, в котором мы изменили какой-то один объект. То есть, в случае фолловинга/анфолловинга\r\nпользователей на входе мы даем \"Array<UserType>\" и на выходе должны получить \"Array<UserType>\".\r\n*/\r\nexport function updateObjectInArray<T extends {}, K extends keyof T, P extends Partial<T>>\r\n(items: Array<T>, itemID: T[K], objPropName: K, newObjProps: P): Array<T> {\r\n    /*\r\n    \"items\" - будет получать массив объектов (информация о пользователях для постраничного вывода из \"state\"\r\n    для \"FOLLOW\" и \"UNFOLLOW\").\r\n    \"itemID\" - значение для сравнения при поиске нужного объекта в массиве (\"ID\" пользователя для\r\n    фолловинга/анфолловинга из объекта \"action\" для \"FOLLOW\" и \"UNFOLLOW\").\r\n    \"objPropName\" - имя свойства в объектах, по которому идет проверка сравнением ('id' для \"FOLLOW\" и \"UNFOLLOW\").\r\n    \"newObjProps\" - объект со свойствами и их значениями, который нужно подменить на место старого в найденном объекте\r\n    (\"{followed: true}\" для фолловинга и \"{followed: false}\" для анфолловинга для \"FOLLOW\" и \"UNFOLLOW\").\r\n    */\r\n    return items.map(u => { /*Мапим полученный массив объектов. \"u\" - это каждый элемент массива. Метод \"map\" возвращает\r\n    новый массив в итоге на основе полученного массива.*/\r\n        if (u[objPropName] === itemID) { /*(Вспомним, что \"u.id\" и \"u[\"id\"]\" это одно и тоже) Если у какого-либо\r\n        элемента (объекта, содержащего информацию о пользователе для постраничного вывода в случае для \"FOLLOW\" и\r\n        \"UNFOLLOW\") массива указанное свойство \"objPropName\" (\"u.id\", то есть \"ID\" пользователя в случае для \"FOLLOW\" и\r\n        \"UNFOLLOW\") равно значению для сравнения \"itemID\" (из объекта \"action\" там будет \"ID\" пользователя для\r\n        фолловинга/анфолловинга для \"FOLLOW\" и \"UNFOLLOW\"),*/\r\n            return {...u, ...newObjProps} /*то делаем деструктуризацию этого элемента (объекта, содержащего информацию о\r\n            пользователе для постраничного вывода в случае для \"FOLLOW\" и \"UNFOLLOW\") и подменяем ему указанное свойство\r\n            со значением в \"newObjProps\" за место старого значения этого свойства (\"{followed: true}\" для фолловинга и\r\n            \"{followed: false}\" для анфолловинга для \"FOLLOW\" и \"UNFOLLOW\").*/\r\n        }\r\n        return u; /*Если же условие выше не срабатывает, то \"map\" вернет элемент массива как есть.*/\r\n    }) /*В итоге \"map\" соберет новый массив с теми же объектами, где у одного из них измениться значение одного из\r\n    свойств (\"{followed: true}\" для фолловинга и \"{followed: true}\" для анфолловинга для \"FOLLOW\" и \"UNFOLLOW\")*/\r\n};","/*\r\nЭто файл \"reducer\", отвечающего за страницу постраничного вывода пользователей. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport {usersAPI} from '../api/users-api'; /*Импортируем блок запросов, связанных со страницей с постраничным выводом\r\nпользователей.*/\r\n\r\nimport {updateObjectInArray} from '../utils/helpers/object-helpers'; /*Импортируем вспомогательную функцию, которая\r\nсодержит общую логику для \"FOLLOW\" и \"UNFOLLOW\" в \"reducer\".*/\r\n\r\nimport {ResponseWithDataType, ResultCodeEnum} from '../api/api'; /*Импортируем списки кодов ответов от сервера.*/\r\n\r\nimport {UserType} from '../types/types'; /*Подключаем типы.*/\r\nimport {InferActionsTypes, BaseThunkType, BaseDispatchType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\nexport type InitialUsersStateType = typeof initialState;\r\n\r\n/*Создали отдельный тип для данных из \"state\", которые отвечают за фильтрацию пользователей в постраничном выводе.*/\r\nexport type UsersFilterType = typeof initialState.filter;\r\n\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    users: [] as Array<UserType>, /*Свойство, которое будет хранить объекты с информацией о пользователях для\r\n    постраничного вывода, полученные с сервера. Указываем, что этот массив объектов имеет тип массива элементов с\r\n    типом \"UserType\". Тип \"UserType\" был создан нами и импортирован сюда.*/\r\n    pageSize: 30, /*Свойство, которое хранит значение, обозначающее сколько пользователей может максимально выводится\r\n    на одной странице в постраниченом выводе пользователей.*/\r\n    totalUsersCount: 0, /*Свойство, которое хранит значение, обозначающее общее количество пользователей.\r\n    Получается с сервера.*/\r\n    currentPage: 1, /*Свойство, которое хранит значение, обозначающее номер текущей выбранной страницы в постраничном\r\n    выводе пользователей.*/\r\n    isFetching: false, /*Специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение\r\n    данных по пользователям для постраничного вывода. Если в процессе, то будет отрисовываться\r\n    компонент-заглушка \"Preloader\".*/\r\n    WhoIsInFollowingProgress: [] as Array<number>, /*Специальное свойство, которое содержит массив, который будет\r\n    хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга,\r\n    то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя. Указываем, что это свойство\r\n    имеет тип массива элементов с типом \"number\" (число).*/\r\n    portionSize: 20, /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном выводе\r\n    может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих огромное\r\n    количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться\r\n    между этими порциями страниц.*/\r\n    filter: { /*Свойство, которое содержит объект, внутри которого указываются фильтры для выборки пользователей в\r\n    постраничном выводе. Это свойство будет использоваться в форме, которая была создана при помощи библиотеки\r\n    \"formik\", а для этой библиотеки не обязательно хранить значения формы в \"store\" из библиотеки \"redux\". Но мы это\r\n    делаем, так как эти фильтры будут применяться как параметры адресной строки, то есть будут являться данными BLL.*/\r\n        term: '', /*Свойство, которое содержит значение для фильтра в виде строкового значения, которое будет получать\r\n        сервер и искать наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких\r\n        пользователей.*/\r\n        friend: null as null | boolean /*Свойство, которое содержит значение для фильтра булева типа, если указать в нем\r\n        \"true\", то сервер выберет только тех пользователей, которых мы фолловим, если указать \"false\" - только тех, кого\r\n        мы не фолловим, если указать \"null\" или вообще не указывать, то выберет всех пользователей.*/\r\n    }\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst usersReducer = (state = initialState, action: ActionsType): InitialUsersStateType => { /*Указываем, что тип\r\n\"state\" на выходе имеет тот же тип \"InitialUsersStateType\", что и \"state\" на входе. На входе объекты \"action\" имеют тип\r\n\"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case 'demo-spa/users-reducer/FOLLOW':\r\n            return { /*Меняем флаг у пользователя, что мы его теперь фоллловим.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>\r\n                (state.users, action.userID, 'id', {followed: true})\r\n                /*\r\n                Вызываем вспомогательную функцию \"updateObjectInArray\" и передаем ей:\r\n                \"state.users\" - информацию о пользователях для постраничного вывода из \"state\".\r\n                \"action.userID\" - \"ID\" пользователя для фолловинга из объекта \"action\".\r\n                \"'id'\" - имя свойство в объектах, по которому идет проверка сравнением в \"updateObjectInArray\".\r\n                \"{followed: true}\" - объект со свойствами и их значениями, который нужно подменить на место старого\r\n                в найденном объекте.\r\n                В результате получим новый измененным массив объектов с информацией о пользователях для постраничного\r\n                вывода, в котором у одного из пользователей свойство \"followed\" станет \"true\", что будет означать, что\r\n                мы его зафолловили.\r\n                */\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/UNFOLLOW':\r\n            return { /*Меняем флаг у пользователя, что мы больше его не фоллловим.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                users: updateObjectInArray<UserType, keyof UserType, Partial<UserType>>\r\n                (state.users, action.userID, 'id', {followed: false})\r\n                /*\r\n                Вызываем вспомогательную функцию \"updateObjectInArray\" и передаем ей:\r\n                \"state.users\" - информацию о пользователях для постраничного вывода из \"state\".\r\n                \"action.userID\" - \"ID\" пользователя для анфолловинга из объекта \"action\".\r\n                \"'id'\" - имя свойство в объектах, по которому идет проверка сравнением в \"updateObjectInArray\".\r\n                \"{followed: false}\" - объект со свойствами и их значениями, который нужно подменить на место старого\r\n                в найденном объекте.\r\n                В результате получим новый измененным массив объектов с информацией о пользователях для постраничного\r\n                вывода, в котором у одного из пользователей свойство \"followed\" станет \"false\", что будет означать, что\r\n                мы его больше не фолловим.\r\n                */\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/SET-USERS':\r\n            return { /*Добавляем данные о пользователях \"users\" в \"state\", полученные с сервера.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                users: action.users /*Добавляем данные о пользователях \"users\" в \"state\". Здесь мы не добавляем к\r\n                существующим данным новые. Мы затираем старые данные, добавляя новые. Здесь мы не делаем глубокую копию,\r\n                так как работаем с примитивом.*/\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/SET-CURRENT-PAGE':\r\n            return { /*Устанавливаем значение текущей выбранной страницы в постраничном выводе пользователей в\"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                currentPage: action.currentPage, /*Устанавливаем значение текущей выбранной страницы в постраничном\r\n                выводе пользователей. Здесь мы не делаем глубокую копию, так как работаем с примитивом.*/\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT':\r\n            return { /*Устанавливаем общее количество пользователей в\"state\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                totalUsersCount: action.count /*Устанавливаем общее количество пользователей. Здесь мы не делаем\r\n                глубокую копию, так как работаем с примитивом.*/\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/TOGGLE-IS-FETCHING':\r\n            return { /*Указываем находится ли в процессе запрос на сервер на получение данных по пользователям для\r\n            постраничного вывода. Если в процессе, то будет отрисовываться компонент-заглушка \"Preloader\".*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                isFetching: action.isFetching /*Указываем находится ли в процессе запрос на сервер на получение данных\r\n                по пользователям для постраничного вывода. Здесь мы не делаем глубокую копию, так как работаем\r\n                с примитивом.*/\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS':\r\n            return { /*Оперируем массивом \"WhoIsInFollowingProgress\" для указания находятся ли или нет какие-либо\r\n            пользователи в процессе анфолловинга/фолловинга.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                WhoIsInFollowingProgress: action.isFollowingInProgress /*Если свойство \"isFollowingInProgress\" (нужен\r\n                только для того, чтобы попасть в первую или вторую строку)*/\r\n                    ? [...state.WhoIsInFollowingProgress, action.userID] /*является \"TRUE\", то делаем глубокую копию и\r\n                    помещаем \"ID\" пользователя, который находится в процессе анфолловинга/фолловинга\r\n                    в массив \"WhoIsInFollowingProgress\",*/\r\n                    : state.WhoIsInFollowingProgress.filter(id => id !== action.userID) /*иначе если является \"FALSE\",\r\n                    то делаем глубокую копию и удаляем \"ID\" этого пользователя из массива \"WhoIsInFollowingProgress\"\r\n                    при помощи метода \"filter()\", который создает новый массив (тем самым мы делаем копию), в который\r\n                    войдут только те элементы, которые не равны \"ID\" указанного пользователя.*/\r\n            };\r\n\r\n        case 'demo-spa/users-reducer/SET-FILTER': /*Устанавливаем данные по фильтрам для отображения пользователей в\r\n        постраничном выводе пользователей в \"state\".*/\r\n            return { /*Здесь благодаря деструктуризации мы сможем передать нужные значения свойств из \"payload\" в нужные\r\n            свойства \"state\" при совпадении имен свойств.*/\r\n                ...state, /*Делаем поверхностную копию \"state\".*/\r\n                filter: action.payload /*Объект \"action\" будет иметь объект \"payload\", который содержит объект \"filter\"\r\n                со свойствами \"term\" и \"friend\". Делаем глубокую копию, чтобы установить эти данные в \"state\",\r\n                деструктурируя этот объект \"payload\".*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InferActionsTypes<typeof usersAC>; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип \"InferActionsTypes\" для\r\nопределения типов всех объектов \"action\" у упакованных в единый объект \"usersAC\" AC.*/\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const usersAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные\r\nраннее на основе каждого AC. Также вверху удалили все константы со значениями для \"type\" и указывываем их сразу в AC,\r\nтак как \"TypeScript\" не даст нам допустить ошибку при указании этих \"types\" в \"reducer\". Согласно модульному паттерну\r\n\"Redux Ducks\", чтобы избежать случаев одиноковых значений свойств \"type\" из-за чего один и тот же объект \"action\" может\r\nсработать в нескольких \"reducers\", в значениях свойств \"type\" в объекте \"action\" указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\". Также в конце везде добавили \"as const\", чтобы \"reducer\" адекватно\r\nвоспринимал объекты \"action\". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных\r\nтипов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/\r\n    followSuccess: (userID: number) => ({ /*AC для указания того, что мы зафолловили пользователя. На входе получает\r\n    \"userID\", которое дожно быть числом.*/\r\n        type: 'demo-spa/users-reducer/FOLLOW', /*Обязательно свойство \"type\" для AC.*/\r\n        userID /*Это равносильно \"userID: userID\". \"ID\" пользователя, которого мы фолловим.*/\r\n    } as const),\r\n\r\n    unfollowSuccess: (userID: number) => ({ /*AC для указания того, что мы анфолловили пользователя. На входе получает\r\n    \"userID\", которое дожно быть числом.*/\r\n        type: 'demo-spa/users-reducer/UNFOLLOW', /*Обязательно свойство \"type\" для AC.*/\r\n        userID /*Это равносильно \"userID: userID\". \"ID\" пользователя, которого мы анфолловим.*/\r\n    } as const),\r\n\r\n    setUsers: (users: Array<UserType>) => ({ /*AC для установки данных пользователей \"users\" в \"state\", которые получены\r\n    с сервера. На входе получает \"users\", которое дожно быть массивом с объектами типа \"UserType\", созданного нами и\r\n    импортированного сюда.*/\r\n        type: 'demo-spa/users-reducer/SET-USERS', /*Обязательно свойство \"type\" для AC.*/\r\n        users /*Это равносильно \"users: users\". Данные по пользователям для постраничного вывода пользователей,\r\n        полученные с сервера.*/\r\n    } as const),\r\n\r\n    setCurrentPage: (currentPage: number) => ({ /*AC для установки значения текущей выбранной страницы в постраничном\r\n    выводе пользователей в \"state\". На входе получает \"currentPage\", которое дожно быть числом.*/\r\n        type: 'demo-spa/users-reducer/SET-CURRENT-PAGE', /*Обязательно свойство \"type\" для AC.*/\r\n        currentPage /*Это равносильно \"currentPage: currentPage\". Номер выбранной текущей страницы в постраничном\r\n        выводе пользователей.*/\r\n    } as const),\r\n\r\n    setTotalUsersCount: (totalUsersCount: number) => ({ /*AC для установки общего количество пользователей в \"state\". На\r\n    входе получает \"totalUsersCount\", которое дожно быть числом.*/\r\n        type: 'demo-spa/users-reducer/SET-TOTAL-USERS-COUNT', /*Обязательно свойство \"type\" для AC.*/\r\n        count: totalUsersCount /*Значение обозначающее общее количество пользователей.*/\r\n    } as const),\r\n\r\n    toggleIsFetching: (isFetching: boolean) => ({ /*AC для указания находится ли в процессе запрос на сервер на\r\n    получение данных по пользователям для постраничного вывода. Если в процессе, то будет отрисовываться\r\n    компонент-заглушка \"Preloader\". На входе получает \"isFetching\", которое дожно быть булева типа.*/\r\n        type: 'demo-spa/users-reducer/TOGGLE-IS-FETCHING', /*Обязательно свойство \"type\" для AC.*/\r\n        isFetching /*Это равносильно \"isFetching: isFetching\". Специальное свойство, которое обозначает находится ли в\r\n        процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/\r\n    } as const),\r\n\r\n    toggleIsFollowingInProgress: (isFollowingInProgress: boolean, /*На входе получает \"isFollowingInProgress\",\r\n                                  которое дожно быть булева типа.*/\r\n                                  userID: number /*На входе получает \"userID\", которое дожно быть числом.*/\r\n    ) => ({ /*AC для указания находится ли в процессе анфолловинга/фолловинга какой-либо пользователь. Если в процессе,\r\n    то кнопка для анфолловинга/фолловинга будет отключена.*/\r\n        type: 'demo-spa/users-reducer/TOGGLE-IS-FOLLOWING-IN-PROGRESS', /*Обязательно свойство \"type\" для AC.*/\r\n        isFollowingInProgress, /*Это равносильно \"isFollowingInProgress: isFollowingInProgress\". Специальное свойство,\r\n        которое указывает находится ли какой-либо пользователь в процессе анфолловинга/фолловинга.*/\r\n        userID /*Это равносильно \"userID: userID\". Специальное свойство, которое указывает \"ID\" пользователя по которому\r\n        идет проверка находится ли он в процессе анфолловинга/фолловинга.*/\r\n    } as const),\r\n\r\n    setFilter: (filter: UsersFilterType) => ({ /*AC для установки фильтров для отображения пользователей в постраничном\r\n    выводе пользователей в \"state\". На входе получает \"filter\", которое дожно быть типа \"UsersFilterType\", который мы\r\n    создали выше.*/\r\n        type: 'demo-spa/users-reducer/SET-FILTER', /*Обязательно свойство \"type\" для AC.*/\r\n        payload: filter /*Объект с данными по фильтрам для отображения пользователей в постраничном выводе\r\n        пользователей. Далее мы его деструктурируем в \"usersReducer\".*/\r\n    } as const)\r\n};\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype DispatchType = BaseDispatchType<ActionsType>; /*Создали тип для \"dispatch\", передается в \"thunks\" и TC.*/\r\n\r\ntype ThunkType = BaseThunkType<ActionsType>; /*Создали тип для \"thunks\".\r\n*/\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const requestUsers = (currentPage: number, /*На входе принимает номер текущей выбранной страницы в постраничном\r\n                             выводе пользователей, который должен быть числом.*/\r\n                             pageSize: number, /*На входе принимает свойство, которое хранит значение, обозначающее\r\n                             сколько пользователей может максимально выводится на одной странице в постраниченом выводе\r\n                             пользователей, которое должно быть числом.*/\r\n                             filter: UsersFilterType /*На входе принимает свойство, которое хранит данные по фильтрам\r\n                             для отображения пользователей в постраничном выводе пользователей, которые должны быть типа\r\n                             \"UsersFilterType\", который мы создали выше.*/\r\n): ThunkType => async (dispatch) => {\r\n/*Это TC для запроса и установки данных по пользователям в постраничном выводе. Здесь вместо использования \".then\"\r\nмы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC асинхронным. Этот TC на выходе\r\nвозвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами выше. Мы могли здесь также указать тип \"dispatch\",\r\n\"getState()\" и дополнительных аргументов, но типизируя то, что возвращает TC, то есть \"thunk\", мы также типизировали,\r\nчто в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n\r\n    dispatch(usersAC.toggleIsFetching(true)); /*Включаем компонент-заглушку \"Preloader\" перед началом\r\n    запроса на сервер.*/\r\n\r\n    dispatch(usersAC.setFilter(filter)); /*При помощи AC \"setFilter\" устанавливаем данные по фильтрам для отображения\r\n    пользователей в постраничном выводе пользователей в \"state\".*/\r\n\r\n    const response = await usersAPI.getUsers(currentPage, pageSize, filter.term, filter.friend); /*Делаем запрос на\r\n    сервер для получения данных по пользователям для постраничного вывода и ждем ответа от сервера. Здесь будет\r\n    ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как асинхронная\r\n    функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    dispatch(usersAC.toggleIsFetching(false)); /*После получения ответа от сервера, отключаем\r\n    компонент-заглушку \"Preloader\".*/\r\n    dispatch(usersAC.setUsers(response.items)); /*При помощи AC \"setUsers\" устанавливаем данные по пользователям\r\n    для постраничного вывода в \"state\".*/\r\n    dispatch(usersAC.setTotalUsersCount(response.totalCount)); /*Устанавливаем общее количество пользователей в\r\n    \"state\".*/\r\n};\r\n\r\n/*Это вспомогательный TC для осуществления анфолловинга/фоллофинга пользователей \"_followUnfollowFlow\". Он вызывается\r\nвнутри TC \"unfollow\" или \"follow\". Для своей работы он принимает следующие параметры: метод \"dispatch\" (обязателен для\r\n\"thunk\", \"store\" из \"redux\" его сам закинет), \"ID\" пользователя для анфолловинга/фолловинга, запрос на сервер для\r\nанфолловинга/фолловинга, AC для анфолловинга/фолловинга. Эти параметры он получает от TC \"unfollow\" или \"follow\".\r\nЗдесь вместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться в \"await\". \"async\" делает TC\r\nасинхронным.*/\r\nconst _followUnfollowFlow = async (dispatch: DispatchType, /*На входе принимает \"dispatch\", который должен быть типа\r\n                                   \"DispatchType\", который мы создали выше.*/\r\n                                   id: number, /*На входе принимает \"ID\" пользователя, которого мы фолловим/анфолловим,\r\n                                   которое должно быть числом.*/\r\n                                   apiMethod: (id: number) => Promise<ResponseWithDataType>, /*На входе принимает метод\r\n                                   API, который должен быть функцией, которая на входе принимает числовой параметр, а на\r\n                                   выходе выдаед промис, который резольвится данными типа \"ResponseWithDataType\". Такая\r\n                                   типизация сделана на основе запросов \"follow\" и \"unfollow\" из \"users-api.ts\".*/\r\n                                   actionCreator: (id: number) => ActionsType\r\n                                   /*На входе принимает AC, который должен быть функцией, которая на входе принимает\r\n                                   числовой параметр, а на выходе ранее возвращала объекты \"action\" либо с типом\r\n                                   \"FollowSuccessActionType\", либо с типом \"UnfollowSuccessActionType\", оба эти типа\r\n                                   были созданы нами, но затем удалены, поэтому сейчас эти объекты \"action\" временно\r\n                                   должны быть общего типа для всех объектов \"action\" - \"ActionsType\".*/\r\n) => {\r\n\r\n    dispatch(usersAC.toggleIsFollowingInProgress(true, id)); /*Указываем, что находимся в процессе\r\n    попытки зафолловить/заанфолловить какого-то пользователя.*/\r\n\r\n    const response = await apiMethod(id); /*Делаем запрос на сервер на анфолловинг/фолловинг и ждем ответа от сервера.\r\n    Здесь будет ожидаться промис. Когда он зарезольвиться, он сохраниться в \"response\". Здесь \"return\" не нужен, так как\r\n    асинхронная функция автоматически вернет промис, то есть можно сразу писать логику по работе с ответом от сервера.*/\r\n\r\n    if (response.resultCode === ResultCodeEnum.Success) { /*Если в ответе от сервера в свойстве \"resultCode\" указано \"0\"\r\n    (т.е. операция прошла успешно), то диспатчим AC на анфолловинг/фолловинг, передав в этот AC \"ID\" пользователя,\r\n    которого анфолловим/фолловим.*/\r\n        dispatch(actionCreator(id))\r\n    }\r\n\r\n    dispatch(usersAC.toggleIsFollowingInProgress(false, id)); /*Указываем, что больше не находимся в\r\n    процессе попытки зафолловить/заанфолловить какого-то пользователя.*/\r\n}\r\n\r\n/*Далее идут два основных TC для осуществления анфолловинга/фоллофинга пользователей \"unfollow\" и \"follow\". Все, что они\r\nделают это вызывают вспомогательный TC для осуществления анфолловинга/фоллофинга пользователей \"_followUnfollowFlow\" и\r\nпередают ему ряд параметров для его работы: метод \"dispatch\" (обязателен для \"thunk\", \"store\" из \"redux\" его сам\r\nзакинет), \"ID\" пользователя для анфолловинга/фолловинга, запрос на сервер для анфолловинга/фолловинга, AC для\r\nанфолловинга/фолловинга. Здесь вместо использования \".then\" мы используем \"async/await\". Промис будет ожидаться\r\nв \"await\". \"async\" делает TC асинхронным.*/\r\nexport const unfollow = (id: number): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления анфолловинга какого-либо пользователя. На входе принимает \"ID\" пользователя, которого мы\r\nанфолловим, которое должно быть числом. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный\r\nнами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что\r\nвозвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    await _followUnfollowFlow(dispatch, id, usersAPI.unfollow.bind(usersAPI), usersAC.unfollowSuccess); /*Так как мы\r\n    берем метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли этот метод\r\n    какие-нибудь свойства с \"this\" и т.д., поэтому мы используем здесь \"bind()\", чтобы не потерять контекст \"this\". Но\r\n    вроде и без этого должно работать.*/\r\n};\r\n\r\nexport const follow = (id: number): ThunkType => async (dispatch) => {\r\n/*Это TC для осуществления фолловинга какого-либо пользователя. На входе принимает \"ID\" пользователя, которого мы\r\nфолловим, которое должно быть числом. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный\r\nнами выше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что\r\nвозвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    await _followUnfollowFlow(dispatch, id, usersAPI.follow.bind(usersAPI), usersAC.followSuccess); /*Так как мы берем\r\n    метод у объекта и вызываем этот метод оторванно от этого объекта, то мы не знаем использует ли этот метод\r\n    какие-нибудь свойства с \"this\" и т.д., поэтому мы используем здесь \"bind()\", чтобы не потерять контекст \"this\". Но\r\n    вроде и без этого должно работать.*/\r\n};\r\n\r\n\r\nexport default usersReducer; /*Экспортируем \"usersReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"usersReducer\", экспорт необходим для импорта.*/","/*\r\nЭто специальный файл, содержащий логику для высчитывания и отображения текущей страницы в постраничном\r\nвыводе пользователей. Но этот файл можно использовать по идее и для постраничного вывода любых других элементов.\r\n*/\r\n\r\nimport React, {useState} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\n*/\r\n\r\nimport styles from './Paginator.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport cn from 'classnames';\r\n/*\r\n\"classnames\" - это библиотека для простого условного объединения имен классов .Для этого мы здесь используем\r\nфункцию \"cn\" из этой библиотеки.\r\nКак можно добавить два класса:\r\nclassName = {styles.first + ' ' + styles.second} (без библиотеки \"classnames\")\r\nclassName = {`${styles.first} ${styles.second}`} (без библиотеки \"classnames\")\r\nclassName = {cn(styles.second, styles.first)} (с библиотекой \"classnames\")\r\nТакже при использовании этой библиотеки можно добавлять условия:\r\nclassName = {cn(\r\n                styles.first,\r\n                {[styles.second] : true}\r\n                )\r\n            };\r\n*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    totalItemsCount: number /*Общее количество элементов для постраничного вывода должно быть числом.*/\r\n    pageSize: number /*Максимальное количество элементов на одной странице в постраничном выводе должно быть числом.*/\r\n    currentPage: number /*Текущая выбранная страница в постраничном выводе должна быть числом.*/\r\n    onPageChange: (p: number) => void /*Метод для обновления данных при смене текущей выбранной страницы в постраничном\r\n    выводе должен быть функцией, которая принимает числовой параметр и ничего не возвращает.*/\r\n    portionSize?: number /*Свойство, которое указывает какое максимальное количество номеров страниц в постраничном\r\n    выводе может отображаться в одной порции таких страниц, должно быть числом. Не является обязательным.*/\r\n};\r\n\r\n\r\n/*\r\n\"Paginator\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Paginator(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Paginator\" является компонентом, который способен создавать постраничный вывод элементов.\r\nВ нашем приложении он используется для постраничного вывода пользователей.\r\nЭтот компонент подключается в компоненте \"Users\".\r\n*/\r\nconst Paginator: React.FC<PropsType> = ({ /*Указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n\"props.totalItemsCount\", \"props.pageSize\" и так далее. Такое мы делаем только в функциональных компонентах. Указали при\r\nпомощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n                                        totalItemsCount, /*Общее количество элементов для постраничного\r\n                                        вывода.*/\r\n                                        pageSize, /*Максимальное количество элементов на одной странице в\r\n                                        постраничном выводе.*/\r\n                                        currentPage, /*Текущая выбранная страница в постраничном выводе.*/\r\n                                        onPageChange, /*Метод для обновления данных при смене текущей выбранной страницы\r\n                                        в постраничном выводе.*/\r\n                                        portionSize = 10 /*Свойство, которое указывает какое\r\n                                        максимальное количество номеров страниц в постраничном выводе может отображаться\r\n                                        в одной порции таких страниц. Это сделано, чтобы не выводились все номера\r\n                                        страниц, коих огромное количество, а имелась возможность\r\n                                        выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться\r\n                                        между этими порциями страниц. Если значение этого свойства не будет указано, то\r\n                                        по умолчанию оно будет равно 10.*/\r\n                                    }) => {\r\n\r\n    let pagesCount = Math.ceil(totalItemsCount / pageSize); /*Высчитываем сколько страниц пользователей нам\r\n    нужно (делим общее количество элементов на максимальное количество элементов на одной странице) и помещаем\r\n    результат в переменную \"pagesCount\". Метод \"Math.ceil\" округляет в большую сторону.*/\r\n\r\n    let pages: Array<number> = []; /*Создаем массив, который будет содержать такое количество элементов\r\n    (например, 1,2,3 и т.д., т.е. номера страниц), которое будет равно количеству страниц в постраничном выводе\r\n    пользователей \"pagesCount\". Далее мы будем мапить этот массив, чтобы вывести список номеров страниц для\r\n    навигации по постраничному выводу элементов. Этот массив имеет тип массива чисел.*/\r\n\r\n    for (let i = 1; i <= pagesCount; i++) { /*Заполняем массив \"pages\" путем перебора \"pagesCount\".*/\r\n        pages.push(i); /*При помощи метода \"push()\" добавляем в конец массива \"pages\" каждый \"i\".*/\r\n    };\r\n\r\n    /*\r\n    \"portionCount\" - how many portions of pages we have. Количество порций страниц, которое мы имеем.\r\n\r\n    \"portionSize\" - how many pages in a portion, you can get it from state. Максимальное количество страниц в одной\r\n    порции. Мы это берем из \"state\".\r\n\r\n    \"lowerLimitOfCurrentPortion\" - the number of the page which is a lower bound of the current portion of pages. Номер\r\n    страницы, который является нижней границей текущей порции страниц.\r\n\r\n    \"upperLimitOfCurrentPortion\" - the number of the page which is an upper bound of the current portion of pages. Номер\r\n    страницы, который является верхней границей текущей порции страниц.\r\n\r\n    \"currentPortionNumber\" - the number of the current portion of pages, used in \"useState\". Номер текущей порции\r\n    страниц, используется в хуке \"useState\".\r\n\r\n    \"setCurrentPortionNumber\" - a function that can change the number of the current portion of pages, used in\r\n    \"useState\". Функция, которая может менять номер текущей порции страниц, используется в хуке \"useState\".\r\n\r\n    \"useState\" - a hook from \"ReactJS\". Хук из \"ReactJS\".\r\n    */\r\n\r\n    let portionCount = Math.ceil(pagesCount / portionSize); /*Вычисляем количество порций страниц, путем деления\r\n    количества всех страниц с пользователями на максимальное количество страниц в одной порции. Метод \"Math.ceil\"\r\n    округляет в большую сторону.*/\r\n    let [currentPortionNumber, setCurrentPortionNumber] = useState(1); /*При помощи деструктуризирующего\r\n    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент\r\n    будет означать номер текущей порции страниц (изначально \"1\"). Вторая переменная будет хранить функцию из хука\r\n    \"useState\", которая будет изменять первый элемент (то есть менять номер текущей порции страниц).*/\r\n    let lowerBoundOfCurrentPortion = (currentPortionNumber - 1) * portionSize + 1; /*Высчитываем номер страницы, который\r\n    является нижней границей текущей порции страниц. Изначально это будет \"(1 - 1) + 1 = 1\".*/\r\n    let upperBoundOfCurrentPortion = currentPortionNumber * portionSize; /*Высчитываем номер страницы, который является\r\n    верхней границей текущей порции страниц. Изначально это будет \"1 * 20 = 20\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.paginator}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n\r\n            {currentPortionNumber > 1 && /*Если текущий номер порции страниц больше 1,*/\r\n            <button onClick={() => { /*то отрисовываем элемент \"button\", при нажатии на который будет уменьшаться\r\n            текущий номер порции страниц на 1, то есть мы будем переходить назад на предыдущую порцию страниц (например,\r\n            с \"от 21 до 40\" до  \"1 до 20\"). Соотвественно изначально это кнопка не отрисовывается, так как мы\r\n            по дефолтку находимся на 1-ой порции страниц.*/\r\n                setCurrentPortionNumber(currentPortionNumber - 1)\r\n            }}>\r\n                PREV {/*Текст кнопки \"предыдущая порция страниц\".*/}\r\n            </button>}\r\n\r\n            {pages\r\n                .filter(p => p >= lowerBoundOfCurrentPortion && p <= upperBoundOfCurrentPortion) /*Из массива \"pages\"\r\n                берем только те номера страниц, которые больше или равны нижней границе текущей порции страниц и\r\n                меньше или равны верхней границе текущей порции страниц.*/\r\n                .map(p => { /*Далее мапим отфильтрованный массив \"pages\".*/\r\n                    return ( /*Здесь возвращаем JSX в виде \"span\" элементов. Количество этих \"span\" элементов будет\r\n                    равно количеству элементов в массиве \"pages\". Это будет список номеров страниц для навигации в\r\n                    постраничном выводе пользователей.*/\r\n                        <span className={cn({[styles.selectedPage]: currentPage === p}, styles.pageNumber)}\r\n                        /*Будет применяться особый стиль к странице \"p\", номер которой равен номеру текущей выбранной\r\n                        страницы в постраничном выводе из \"state\", благодаря использованию функции \"cn\".*/\r\n                              key={p} /*При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания\r\n                              ошибок.*/\r\n                              onClick={(e) => { /*Это анонимная функция, которая будет\r\n                              вызываться при событии нажатия на элемент.*/\r\n                                  onPageChange(p) /*Эта анонимная функция будет вызывать наш метод \"onPageChange\" и\r\n                                  передавать в него номер страницы, на которую мы нажали. В результате мы изменим\r\n                                  текущую выбранную страницу в постраничном выводе в \"state\".*/\r\n                              }}>\r\n                            {p} {/*Выводим текст самого номера страницы в элементе \"span\".*/}\r\n                        </span>\r\n                    )\r\n                })\r\n            }\r\n\r\n            {portionCount > currentPortionNumber && /*Если количество порций страниц, которое мы имеем, больше текущего\r\n            номера порции страниц,*/\r\n            <button onClick={() => { /*то отрисовываем элемент \"button\", при нажатии на который будет увеличиваться\r\n            текущий номер порции страниц на 1, то есть мы будем переходить вперед на следующуюю порцию страниц\r\n            (например, с \"от 1 до 20\" до  \"21 до 40\"). Соотвественно на последнее порции страниц это кнопка\r\n            не отрисовывается, так текущая порция страниц, которая является последней порцией страниц, равна\r\n            максимальному количеству порций страниц.*/\r\n                setCurrentPortionNumber(currentPortionNumber + 1)\r\n            }}>\r\n                NEXT {/*Текст кнопки \"следующая порция страниц\".*/}\r\n            </button>}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default Paginator; /*Экспортируем компонент \"Paginator\" по default и будем его использовать в нашем проекте под\r\nименем \"Paginator\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './User.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport userPhoto from '../../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя,\r\nна случай если у пользователя нет фото.*/\r\n\r\nimport {UserType} from '../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    user: UserType /*Данные по одному пользователю для постраничного вывода должны быть в виде объекта с типом\r\n    \"UserType\", который был создан нами и импортирован сюда.*/\r\n    WhoIsInFollowingProgress: Array<number> /*Специальное свойство, которое содержит массив, который будет хранить \"ID\"\r\n    пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним\r\n    отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя, должно быть массивом чисел.*/\r\n    unfollow: (id: number) => void /*TC для анфолловинга пользователей должен быть функцией, которая принимает числовой\r\n    параметр и ничего не возвращает.*/\r\n    follow: (id: number) => void /*TC для фолловинга пользователей должен быть функцией, которая принимает числовой\r\n    параметр и ничего не возвращает.*/\r\n};\r\n\r\n\r\n/*\r\n\"User\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function User(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Users\" является компонентом, который описывает, как должны выглядеть блоки с информацией о пользователе на странице\r\nс постраничным выводом пользователей.\r\nЭтот компонент подключается в компоненте \"Users\".\r\n*/\r\nconst User: React.FC<PropsType> = ({/*Указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.user\",\r\n\"props.WhoIsInFollowingProgress\" и так далее. Такое мы делаем только в функциональных компонентах. Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n                  user, /*Объект с данным по пользователю.*/\r\n                  WhoIsInFollowingProgress, /*Специальное свойство, которое содержит массив, который будет\r\n                  хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе\r\n                  анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга\r\n                  от пользователя.*/\r\n                  unfollow, /*TC для анфолловинга пользователей.*/\r\n                  follow /*TC для фолловинга пользователей.*/\r\n}) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <span>\r\n                <div> {/*Это отдельный элемент \"div\" для отображения фото пользователя в виде элемента \"NavLink\" для\r\n                перехода на профиль пользователя.*/}\r\n                    <NavLink to={'/profile/' + user.id}> {/*Создаем маршрут для пути перехода на страницу выбранного\r\n                    пользователя. Отрисуется компонент \"Profile\".*/}\r\n                        <img src={user.photos.small !== null ? user.photos.small : userPhoto}\r\n                             alt='' className={styles.userPhoto}/> {/*Отображаем фото пользователя, если его нет, то\r\n                             подгружаем дефолтный аватар из проекта приложения.*/}\r\n                    </NavLink>\r\n                </div>\r\n\r\n                <div> {/*Это отдельный элемент \"div\" для кнопок с функционалом \"Follow/Unfollow\".*/}\r\n                    {user.followed /*Если значение \"followed\" (свойство, которое говорит фолловим ли мы уже\r\n                    пользователя или нет, это свойство меняется в \"usersReducer\") у пользователя*/\r\n                        ? <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)} /*является \"TRUE\", то\r\n                        отображаем элемент кнопки (причем кнопка будет отключена, если на нее нажали и происходит\r\n                        процесс анфолловинга пользователя, то есть мы берем массив \"WhoIsInFollowingProgress\" и вызываем\r\n                        для него метод \"some()\", который вернет \"TRUE\" если в указанном массиве есть \"ID\" пользователя\r\n                        равное \"ID\" пользователя, указанного при создании отдельного экземпляра компонента \"User\"\r\n                        в результате маппинга)*/\r\n                                  onClick={() => { /*и если нажать на кнопку, то*/\r\n                                      unfollow(user.id); /*сработает TC \"unfollow\", чтобы заанфолловить пользователя,*/\r\n                                  }}>Unfollow</button> /*и отображаем текст \"Unfollow\" на кнопке.*/\r\n\r\n                        : <button disabled={WhoIsInFollowingProgress.some(id => id === user.id)} /*является \"FALSE\", то\r\n                        отображаем элемент кнопки (причем кнопка будет отключена, если на нее нажали и происходит\r\n                        процесс фолловинга пользователя, то есть мы берем массив \"WhoIsInFollowingProgress\" и вызываем\r\n                        для него метод \"some()\", который вернет \"TRUE\" если в указанном массиве есть \"ID\" пользователя\r\n                        равное \"ID\" пользователя, указанного при создании отдельного экземпляра компонента \"User\"\r\n                        в результате маппинга)*/\r\n                                  onClick={() => { /*и если нажать на кнопку, то*/\r\n                                      follow(user.id); /*сработает TC \"follow\", чтобы зафолловить пользователя.*/\r\n                                  }}>Follow</button> /*и отображаем текст \"Follow\" на кнопке.*/\r\n                    }\r\n                </div>\r\n            </span>\r\n\r\n            <span> {/*Это отдельный элемент \"span\" для отображения информации с id, именем и статусом пользователя.\r\n            А также имеется заглушка для страны и города пользователя, так как на данный момент на сервере такой\r\n            информации нет.*/}\r\n                <span> {/*Это отдельный элемент \"span\" для отображения информации с id, именем и статусом\r\n                пользователя.*/}\r\n                    <div>{user.id}</div> {/*Этот элемент \"div\" отображает \"ID\" пользователя.*/}\r\n                    <div>{user.name}</div> {/*Этот элемент \"div\" отображает имя пользователя.*/}\r\n                    <div>{user.status}</div> {/*Этот элемент \"div\" отображает статус пользователя.*/}\r\n                </span>\r\n                <span> {/*Это отдельный элемент \"span\" для отображения заглушки для страны и города пользователя.*/}\r\n                    <div>{\"user.location.country\"}</div> {/*Этот элемент \"div\" отображает заглушку для страны\r\n                    пользователя.*/}\r\n                    <div>{\"user.location.city\"}</div> {/*Этот элемент \"div\" отображает заглушку для города\r\n                    пользователя.*/}\r\n                </span>\r\n            </span>\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default User; /*Экспортируем компонент \"User\" по default и будем его использовать в нашем проекте под именем\r\n\"User\", экспорт необходим для импорта.*/","/*\r\nСелектор - это функция, которая принимает \"state\", достает из него то, что ей нужно и возвращает это в BLL.\r\nСелекторы осуществляют определенную выборку данных из \"state\".\r\nЗдесь содержаться селекторы для данных из \"users-reducer.ts\".\r\n*/\r\n\r\nimport {createSelector} from 'reselect';\r\n/*\r\n\"mapStateToProps\" в методе \"connect\" срабатывает каждый раз, когда что-то меняется в \"state\". Если мы будем использовать\r\nсложные селекторы с дополнительной внутренней логикой, то такие селекторы будут вызывать большую нагрузку и заставлять\r\nчасто перерисовывать приложение. Также такие селекторы сложно дебажить. Чтобы избежать этих проблем мы используем\r\nбиблиотеку \"reselect\". Эта библиотека помогает нам не перезапускать наши сложные селекторы, если в этом нет\r\nнеобходимости. Наш селектор после запуска не только должен отправить что-то в \"mapStateToProps\", но и сохранить это\r\nчто-то в отдельном месте, чтобы в следующий вызов этого селектора он не срабатывал снова, а просто возвращалось это\r\nсохраненное что-то, если оно не было изменено, то есть мы должны указывать от чего зависит наш селектор.\r\nИмпортируем \"createSelector\" из библиотеки \"reselect\", чтобы создавать наши селекторы. \"createSelector\" - это\r\nспециальная функция, которая возвращает селектор, а внутри она получает функцию, описывающую логику селектора. Для того,\r\nчтобы передать \"state\" в \"createSelector\" нам нужно создать примитивный селектор, получающий \"state\". Можно создавать\r\nсложные селекторы на основе нескольких примитивных селекторов или на основе нескольких примитивных и сложных селекторов.\r\n*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Селекторы для компонента \"UsersContainer\".*/\r\nconst getUsersPrimitive = (state: AppStateType) => { /*Создали примитивный селектор, получающий \"users\" из \"state\". На\r\nвходе этот селектор принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.usersPage.users\r\n};\r\n\r\nexport const getUsers = createSelector (getUsersPrimitive, (users) => { /*Создали сложный селектор\r\nна основе примитивного селектора \"getUsersPrimitive\". Можно указать несколько таких селекторов через запятую. Этот\r\nпримитивный селектор будет создавать \"(users)\" - данные по пользователям. Внутри этого сложного логика просто передается\r\nвесь \"users\" как есть. Если бы мы указали, например два селектора вместо одного, то и помимо \"users\" нужно было бы\r\nуказать еще что-то. Этот селектор возвращает данные по пользователям для постраничного вывода.*/\r\n    return users.filter(u => true)\r\n});\r\n\r\n\r\nexport const getPageSize = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает максимальное количество пользователей, которое выводится в постраничном выводе пользователей. На входе этот\r\nселектор принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.usersPage.pageSize\r\n};\r\n\r\nexport const getPortionSize = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает свойство, которое указывает какое количество номеров страниц в постраничном выводе может отображаться в одной\r\nпорции таких страниц. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы создали и\r\nимпортировали сюда.*/\r\n    return state.usersPage.portionSize\r\n};\r\n\r\nexport const getTotalUsersCount = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает общее количество пользователей. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы\r\nсоздали и импортировали сюда.*/\r\n    return state.usersPage.totalUsersCount\r\n};\r\n\r\nexport const getCurrentPage = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает текущий номер выбранной страницы в постраничном выводе пользователей. На входе этот селектор принимает\r\n\"state\" с типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.usersPage.currentPage\r\n};\r\n\r\nexport const getIsFetching = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает специальное свойство, которое обозначает находится ли в процессе запрос на сервер на получение данных по\r\nпользователям для постраничного вывода. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы\r\nсоздали и имопртировали сюда.*/\r\n    return state.usersPage.isFetching\r\n};\r\n\r\nexport const getWhoIsInFollowingProgress = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\"\r\nселектор. Он возвращает специальное свойство, которое содержит массив, который будет хранить \"ID\" пользователей, которые\r\nв какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы\r\nдля анфолловинга/фолловинга от пользователя. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы\r\nсоздали и импортировали сюда.*/\r\n    return state.usersPage.WhoIsInFollowingProgress\r\n};\r\n\r\nexport const getUsersFilter = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает свойство, которое содержит данные по фильтрам для отображения пользователей в постраничном выводе\r\nпользователей. На входе этот селектор принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали\r\nсюда.*/\r\n    return state.usersPage.filter\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Field, Form, Formik} from 'formik';\r\n/*\r\nИспользуем библиотеку \"formik\" как аналог библиотеки \"redux-form\". Последнее нас не устраивает то, что библиотека\r\n\"redux-form\" использует \"store\" из библиотеки \"redux\", храня среди данных BLL данные UI, и может лишний раз\r\nспровоцировать перерисовку приложения.\r\nИмпортируем \"Formik\" из этой библиотеки, чтобы создавать тег \"Formik\", внутри которого указывается код для создания\r\nформы. Внутри можно указать атрибут \"validate\", в котором можно указывать валидацию формы. Также внутри нужно указывать\r\nатрибут \"onSubmit\", который должен содержать логику сабмита данных формы. Также внутри можно указать атрибут\r\n\"initialValues\", который содержит стартовые значения данных формы, которые будут в ней собираться.\r\nИмпортируем \"Form\" из этой библиотеки, чтобы создавать тег \"Form\", внутри которого идет создание самой формы с ее\r\nполями.\r\nИмпортируем \"Field\" из этой библиотеки, чтобы создавать тег \"Field\", внутри которого идет создание поля для формы.\r\nВнутри может указываться атрибут \"name\" для именования данных, которые будут собираться в этом поле и обрабатываться\r\nдалее в приложении, то есть это аналог атрибута \"name\" из библиотеки \"redux-form\".\r\n*/\r\nimport {useSelector} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI\r\nнежелательно общаться с BLL напрямую. Библиотека \"react-redux\" предоставляет продвинутые инструкции по созданию\r\nконтейнерных компонент и контекста.\r\n\"useSelector\" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.\r\n*/\r\n\r\nimport {getUsersFilter} from '../../redux/users-selectors'; /*Импортируем селектор, который возвращает данные по\r\nфильтрам для отображения пользователей в постраничном выводе пользователей.*/\r\n\r\nimport {UsersFilterType} from '../../redux/users-reducer'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    onFilterChange: (filter: UsersFilterType) => void /*Метод для обновления данных по фильтрам для отображения\r\n    пользователей в постраничном выводе пользователей при изменении этих данных должен быть функцией, которая принимает\r\n    параметр типа \"UsersFilterType\", который мы создали и импортировали сюда, и ничего не возвращает.*/\r\n};\r\n\r\ntype FilterFriendFormType = 'true' | 'false' | 'null'; /*Указали тип для свойства, которое содержит значение для\r\nфильтра, который работает следующим образом: если указать в нем \"true\", то сервер выберет только тех пользователей,\r\nкоторых мы фолловим, если указать \"false\" - только тех, кого мы не фолловим, если указать \"null\" или вообще не\r\nуказывать, то выберет всех пользователей. Здесь мы специально указали это в виде строковых значений, так как библиотека\r\n\"formik\" работает внутри формы со строковыми значениями. Но в самой форме мы делаем преобразования в булевый тип и в\r\n\"null\" для нашего \"state\" и для запросов на сервер.*/\r\n\r\n/*Создаем отдельный тип для данных, которые собирает форма ниже в компоненте \"UsersSearchForm.tsx\".*/\r\ntype FormType = {\r\n    term: string /*Свойство, которое содержит значение для фильтра в виде строкового значения, которое будет получать\r\n    сервер и искать наличие этого значения в именах всех пользователей, чтобы в итоге вывести только таких\r\n    пользователей.*/\r\n    friend: FilterFriendFormType /*Свойство, которое содержит значение для фильтра булева типа, если указать в нем\r\n    \"true\", то сервер выберет только тех пользователей, которых мы фолловим, если указать \"false\" - только тех, кого мы\r\n    не фолловим, если указать \"null\" или вообще не указывать, то выберет всех пользователей, должно быть типа\r\n    \"FilterFriendFormType\", который мы создали выше.*/\r\n};\r\n\r\n\r\n/*Вынесли отдельно функцию для валидации формы, которая указывается в атрибуте \"validate\" в теге \"Formik\" из библиотеки\r\n\"formik\".*/\r\nconst usersSearchFormValidate = (values: any) => {\r\n    const errors = {}; /*В данном случае не указали никаких ошибок при валидации.*/\r\n    return errors;\r\n};\r\n\r\n\r\n/*\r\n\"UsersSearchForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function UsersSearchForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"UsersSearchForm\" является компонентом, который отображает форму с фильтрами для поиска пользователей на странице с\r\nпостраничным выводом пользователей. Этот компонент подключается в компоненте \"Users\".\r\n*/\r\nconst UsersSearchForm: React.FC<PropsType> = React.memo(({onFilterChange}) => { /*Для оптимизации лишних\r\nотрисовок мы обворачиваем этот функциональный компонент при помощи \"React.memo()\". Также указываем какие именно \"props\"\r\nмы получаем, чтобы не писать далее \"props.onFilterChange\". Такое мы делаем только в функциональных компонентах. Также\r\nуказали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\", созданный нами\r\nвыше.*/\r\n\r\n    const filter = useSelector(getUsersFilter); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getUsersFilter\", получаем данные для фильтрации пользователей в постраничном выводе.*/\r\n\r\n    /*Создаем callback функцию \"onSubmitForm\", которая будет указываться в атрибуте \"onSubmit\" в теге \"Formik\" из\r\n    библиотеки \"formik\" и которая содержит логику сабмита данных формы. Согласно библиотеке \"formik\" эта функция должна\r\n    принимать значения данных формы в виде первого параметра \"values\", который имеет тип \"FormType\", созданный нами\r\n    выше. Вторым параметром эта функция должна принимать функцию \"setSubmitting\" (будет получена при помощи\r\n    деструктуризации). Указали, что эта функция \"setSubmitting\" является функцией, которая принимает булевый параметр\r\n    \"isSubmitting\" (который указывается внутри стрелочной функции элемента \"Formik\", которая возвращает элемент \"Form\",\r\n    содержащий саму форму) и ничего не возвращает.\r\n    При срабатывании этой функции формируется объект \"filter\" на основе данных формы при их сабмите, содержащий данные\r\n    по фильтрам для отображения пользователей в постраничном выводе пользователей. Затем вызывается метод\r\n    \"onFilterChange\", в который передается этот объект \"filter\", далее благодаря срабатыванию метода \"onFilterChange\"\r\n    данные по фильтрам устанавливаются в наш \"state\" и формируется запрос данных по пользователям для постраничного\r\n    вывода на сервер, содержащий фильтры для отображения пользователей в постраничном выводе. После этого вызывается\r\n    функция \"setSubmitting\", в которую передается параметр \"false\", чтобы указать, что больше не происходит сабмит\r\n    данных формы для того, чтобы кнопка сабмита данных снова стала активна, и мы могли указать новые данные фильтров и\r\n    снова сделать сабмит данных для запроса новых пользователей, но по идее надо делать так, чтобы кнопка стала активна\r\n    только после того, как отобразятся пользователи в ответ на наш запрос.*/\r\n    const onSubmitForm = (values: FormType, {setSubmitting}: {setSubmitting: (isSubmitting: boolean) => void}) => {\r\n        const filter: UsersFilterType = { /*Создаем объект, который содержит данные по фильтрам для отображения\r\n        пользователей в постраничном выводе пользователей. Он будет получать эти данные из формы, которые будут в ней\r\n        собираться в объекте \"values\" при сабмите данных и попадать в эту callback функцию.*/\r\n            term: values.term, /*Строковое значение из \"values.term\" сохраняем как есть.*/\r\n            friend: values.friend === 'null' ? null : values.friend === 'true' ? true : false /*Здесь же строковые\r\n            значения из \"values.friend\" мы преобразовываем в \"null\" и булевый тип для нашего \"state\" и для запросов на\r\n            сервер.*/\r\n        };\r\n\r\n        onFilterChange(filter);\r\n        setSubmitting(false);\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <Formik /*Создает элемент \"Formik\" из библиотеки \"formik\" для создания формы. Внутри указываем атрибуты\r\n            \"initialValues\", \"validate\" и \"onSubmit\".*/\r\n                enableReinitialize={true} /*Таким образом указали библиотеке \"formik\", чтобы она переинициировала форму\r\n                при получении новых \"props\", например, \"filter.term\" или \"filter.friend\". Если не указывать значение\r\n                этого атрибута, то будет тоже \"true\".*/\r\n                initialValues={{term: filter.term, friend: String(filter.friend) as FilterFriendFormType}} /*В атрибуте\r\n                \"initialValues\", который содержит стартовые значения данных формы, которые будут в ней собираться,\r\n                указали значения \"filter.term\" и \"filter.friend\" для свойств \"term\" и \"friend\" соответственно. Значение\r\n                \"filter.friend\" мы преобразовываем в строку при помощи функции \"String()\" и указываем, чтобы полученное\r\n                значение воспринималось как типа \"FilterFriendFormType\" при помощи \"as FilterFriendFormType\". Нам нужны\r\n                здесь строковые значения, так как библиотека \"formik\" работает внутри со строковыми значениями данных\r\n                формы.*/\r\n                validate={usersSearchFormValidate} /*В атрибуте \"validate\", который ответственен за валидацию формы из\r\n                библиотеки \"formik\", указали функцию \"usersSearchFormValidate\", которую создали выше.*/\r\n                onSubmit={onSubmitForm} /*В атрибуте \"onSubmit\", который ответственен за логику сабмита данных формы из\r\n                библиотеки \"formik\", указали функцию \"onSubmitForm\", которую создали выше.*/\r\n            >\r\n                {({isSubmitting}) => ( /*Внутри элемента \"Formik\" должна указываться таким образом стрелочная\r\n                функция, которая принимает булевый параметр \"isSubmitting\" и возвращает элемент \"Form\", содержащий саму\r\n                форму. Параметр \"isSubmitting\" указывает происходит ли сейчас сабмит данных формы или нет. Пока\r\n                происходит сабмит данных формы библиотека \"formik\" по умолчанию делает неактовной кнопку сабмита\r\n                данных.*/\r\n                    <Form> {/*При помощи элемента \"Form\" из библиотеки \"formik\" создаем саму форму. Внутри указываем\r\n                    поля формы при помощи элементов \"Field\" из библиотеки \"formik\".*/}\r\n                        <Field type='text' name='term'/> {/*Первое поле формы имеет тип поля для ввода текста и собирает\r\n                        данные в виде свойства \"term\". В этом поле будет вводиться текст, который будет отправляться на\r\n                        сервер, чтобы сервер мог отфильтровать пользователей, которые содержат этот текст в своем имени,\r\n                        и выдать нам таких пользователей.*/}\r\n                        <Field as='select' name='friend' > {/*Второе поле формы имеет тип выпадающего списка и собирает\r\n                        данные в виде свойства \"friend\". В этом поле будет выбираться одна из трех опций, которые\r\n                        созданы ниже при помощи элементов \"option\", и значение этой выбранной опции будет отправляться\r\n                        на сервер, чтобы сервер в зависимости от полученного значение мог отфильтровать пользователей\r\n                        для выдачи их нам.*/}\r\n                            <option value='null'>All</option> {/*Первым значением в выпадающем списке будет \"null\", что\r\n                            для сервера будет означать вывести всех пользователей.*/}\r\n                            <option value='true'>Followed</option> {/*Вторым значением в выпадающем списке будет \"true\",\r\n                            что для сервера будет означать вывести только тех пользователей, которых мы фолловим.*/}\r\n                            <option value='false'>Unfollowed</option> {/*Третьим значением в выпадающем списке будет\r\n                            \"false\", что для сервера будет означать вывести только тех пользователей, которых мы не\r\n                            фолловим.*/}\r\n                        </Field>\r\n                        <button type='submit' disabled={isSubmitting}> {/*Внутри формы также создаем кнопку с текстом\r\n                        \"Find\" для сабмита данных формы. Также этот элемент содержит атрибут \"disabled\" для указания\r\n                        параметру \"isSubmitting\" значение \"false\", чтобы таким образом указать, что больше не происходит\r\n                        сабмит данных формы для того, чтобы кнопка сабмита данных снова стала активна, и мы могли\r\n                        указать новые данные фильтров и снова сделать сабмит данных.*/}\r\n                            Find\r\n                        </button>\r\n                    </Form>\r\n                )}\r\n            </Formik>\r\n        </div>\r\n    )\r\n});\r\n\r\n\r\nexport default UsersSearchForm; /*Экспортируем компонент \"UsersSearchForm\" по default и будем его использовать в нашем\r\nпроекте под именем \"UsersSearchForm\", экспорт необходим для импорта.*/","import React, {useEffect, useState} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\nПодключаем хук \"useEffect\", который принимает функцию первым параметром и выполняет ее, когда произойдет\r\nотрисовка компонента, то есть после каждого вызова \"render\". Вторым параметром этот хук принимает зависимости -\r\nзависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то\r\nэтот хук сработает только один раз. Этот хук используется для side effects.\r\n*/\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI\r\nнежелательно общаться с BLL напрямую. Библиотека \"react-redux\" предоставляет продвинутые инструкции по созданию\r\nконтейнерных компонент и контекста.\r\n\"useSelector\" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.\r\n\"useDispatch\" - это hook, который принимает AC или TC и диспатчит их.\r\n*/\r\nimport {useHistory} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем хук \"useHistory\", который взаимодействует и управляет данными, связанными с роутингом и маршрутами, например,\r\nс адресной строкой (в виде объекта \"history\"). С похожими данными работает HOC \"withRouter\".\r\n*/\r\n\r\nimport {\r\n    requestUsers, /*Подключаем TC \"requestUsers\" из \"users-reducer.ts\".*/\r\n    follow, /*Подключаем TC \"follow\" из \"users-reducer.ts\".*/\r\n    unfollow, /*Подключаем TC \"unfollow\" из \"users-reducer.ts\".*/\r\n    UsersFilterType /*Подключаем типы из \"users-reducer.ts\".*/\r\n} from '../../redux/users-reducer';\r\n\r\nimport {usersAC} from '../../redux/users-reducer'; /*Подключаем объект \"usersAC\", что использовать оттуда AC из\r\n\"users-reducer.ts\".*/\r\n\r\nimport Paginator from '../common/Paginator/Paginator'; /*Подключаем компонент \"Paginator\".*/\r\nimport User from './User'; /*Подключаем компонент \"User\".*/\r\nimport UsersSearchForm from './UsersSearchForm'; /*Подключаем компонент \"UsersSearchForm\".*/\r\nimport {Preloader} from '../common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\r\n\r\nimport {\r\n    getCurrentPage, /*Импортируем селектор, который возвращает общее количество пользователей.*/\r\n    getPageSize, /*Импортируем селектор, который возвращает максимальное количество пользователей, которое выводится в\r\n    постраничном выводе пользователей.*/\r\n    getTotalUsersCount, /*Импортируем селектор, который возвращает общее количество пользователей.*/\r\n    getWhoIsInFollowingProgress, /*Импортируем селектор, который возвращает специальное свойство, которое содержит\r\n    массив, который будет хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе\r\n    анфолловинга/фолловинга, то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\n    getUsers, /*Импортируем селектор, который возвращает данные по пользователям для постраничного вывода.*/\r\n    getPortionSize, /*Импортируем селектор, который возвращает свойство, которое указывает какое количество номеров\r\n    страниц в постраничном выводе может отображаться в одной порции таких страниц.*/\r\n    getUsersFilter, /*Импортируем селектор, который возвращает данные по фильтрам для отображения пользователей в\r\n    постраничном выводе пользователей.*/\r\n    getIsFetching, /*Импортируем селектор, который возвращает специальное свойство, которое обозначает находится ли в\r\n    процессе запрос на сервер на получение данных по пользователям для постраничного вывода.*/\r\n} from '../../redux/users-selectors';\r\n\r\n\r\nimport * as queryString from 'querystring'; /*Импортируем объект \"queryString\" из библиотеки \"querystring\", чтобы оттуда\r\nиспользовать функцию \"parse()\" для парсинга строки и преобразования ее в объект, и функцию \"stringify\" для обратного\r\nпреобразования.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n\r\n};\r\n\r\ntype QueryParamsType = {term?: string, friend?: string, page?: string}; /*Создали тип для сформированного на основе\r\nпараметров адресной строки объекта, который будет содержать свойства, обозначающие данные для фильтрации пользователей в\r\nпостраничном выводе.*/\r\n\r\n\r\n/*\r\n\"Users\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Users(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Users\" является компонентом, который отображает страницу с постраничным выводом пользователей.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВнутри компонента \"Users\" подключаются компоненты:\r\n- \"User\", который описывает, как должны выглядеть блоки с информацией о пользователе на странице с постраничным\r\nвыводом пользователей;\r\n- \"Paginator\", который осуществляет функционал постраничного вывода информации;\r\n- \"Preloader\", который является компонентом-заглушкой;\r\n- \"UsersSearchForm\", который отображает форму с фильтрами для поиска пользователей на странице с постраничным выводом\r\nпользователей.\r\n*/\r\nexport const Users: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n    const totalUsersCount = useSelector(getTotalUsersCount); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getTotalUsersCount\", получаем общее количество пользователей.*/\r\n    const currentPage = useSelector(getCurrentPage); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getCurrentPage\", получаем номер текущей выбранной страницы в постраничном выводе.*/\r\n    const pageSize = useSelector(getPageSize); /*При помощи хука \"useSelector\", передав в него селектор \"getPageSize\",\r\n    получаем максимальное количество пользователей на одной странице в постраничном выводе.*/\r\n    const portionSize = useSelector(getPortionSize); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getPortionSize\", получаем свойство, которое указывает какое максимальное количество номеров страниц в постраничном\r\n    выводе может отображаться в одной порции таких страниц. Это сделано, чтобы не выводились все номера страниц, коих\r\n    огромное количество, а имелась возможность выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и\r\n    переключаться между этими порциями страниц.*/\r\n    const users = useSelector(getUsers); /*При помощи хука \"useSelector\", передав в него селектор \"getUsers\", получаем\r\n    данные по пользователям для постраничного вывода.*/\r\n    const WhoIsInFollowingProgress = useSelector(getWhoIsInFollowingProgress); /*При помощи хука \"useSelector\", передав\r\n    в него селектор \"getWhoIsInFollowingProgress\", получаем специальное свойство, которое содержит массив, который будет\r\n    хранить \"ID\" пользователей, которые в какой-то определенный момент находятся в процессе анфолловинга/фолловинга, то\r\n    есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга от пользователя.*/\r\n    const filter = useSelector(getUsersFilter); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getUsersFilter\", получаем данные для фильтрации пользователей в постраничном выводе.*/\r\n    const isFetching = useSelector(getIsFetching); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getIsFetching\", получаем специальное свойство, которое обозначает находится ли в процессе запрос на сервер на\r\n    получение данных по пользователям для постраничного вывода (если в процессе, то будет отрисовываться\r\n    компонент-заглушка \"Preloader\").*/\r\n\r\n    const [isNotJustCreated, setIsNotJustCreated] = useState<boolean>(false); /*При помощи деструктуризирующего\r\n    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент\r\n    будет означать специальное свойство, которое показывает то, что мы успели уже указать данные для фильтрации\r\n    пользователей в постраничном выводе или не успели (изначально \"false\"). Нам это нужно, чтобы затриггерить функцию\r\n    \"push\" в компоненте \"Users.tsx\", когда мы выбираем первую страницу после того как уже выбрали другую страницу в\r\n    постраничном выводе. Вторая переменная будет хранить функцию из хука \"useState\", которая будет изменять первый\r\n    элемент (то есть указывать то, что мы успели уже указать данные для фильтрации пользователей в постраничном выводе\r\n    или не успели). При помощи типизации указали, что первый параметр должен быть булева типа.*/\r\n\r\n    const [isJustCreated, setIsJustCreated] = useState<boolean>(true); /*При помощи деструктуризирующего\r\n    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент\r\n    будет означать специальное свойство, которое показывает то, что мы еще не успели указать данные для фильтрации\r\n    пользователей в постраничном выводе или успели (изначально \"true\"). Нам это нужно, чтобы не затриггерить функцию\r\n    \"push\" в компоненте \"Users.tsx\" при первой отрисовке, то есть когда не указано параметров фильтрации пользователей и\r\n    выбрана первая страница в постраничном выводе по умолчанию, так как UI-фреймворк \"Ant Design\" при взаимодействии с\r\n    некоторыми элементами интерфейса (например, при нажатии на кнопки или при изменении параметров адресной строки)\r\n    сворачивает все подменю, чего нам не хотелось бы видеть при первой отрисовке компонента. Вторая переменная будет\r\n    хранить функцию из хука \"useState\", которая будет изменять первый элемент (то есть указывать то, что мы еще не\r\n    успели уже указать данные для фильтрации пользователей в постраничном выводе или успели). При помощи типизации\r\n    указали, что первый параметр должен быть булева типа.*/\r\n\r\n    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука \"useDispatch\".*/\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы получить данные по пользователям для постраничного\r\n    вывода при отрисовке компонента.*/\r\n            dispatch(requestUsers(currentPage, pageSize, filter)); /*Первый параметр это TC \"requestUsers\" для запроса и\r\n        установки данных по пользователям в постраничном выводе, передав значение текущей выбранной страницы,\r\n        максимальное количество пользователей на одной странице в постраничном выводе и данные для фильтрации\r\n        пользователей в постраничном выводе.*/\r\n        },\r\n        [] /*Второй параметр это пустой массив, так как мы хотим, чтобы TC \"requestUsers\" из первого параметра\r\n        сработал только один раз после создания компонента.*/\r\n    );\r\n\r\n    const history = useHistory(); /*Делаем это для более краткого использования хука \"useHistory\".*/\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы синхронизировать данные для фильтрации пользователей в\r\n    постраничном выводе и номер текущей выбранной страницы в постраничном выводе, указанные в параметрах адресной\r\n    строки, с аналогичными данными из глобального \"state\" при отрисовке компонента.*/\r\n        const search = history.location.search.substr(1); /*Первым параметром мы получаем параметры, которые\r\n        указаны в адресной строке (например, строку \"?term=a&friend=true&page=2\"), обращаясь к объекту \"history\",\r\n        который возвращается хуком \"useHistory\". Поскольку нам не нужен знак \"?\" в полученной строке, то мы используем\r\n        также функцию \"substr()\", передав в нее \"1\" в качестве параметра, чтобы считывалось все после первого символа.*/\r\n\r\n        const parsed = queryString.parse(search) as QueryParamsType; /*Также в рамках первого параметра, при помощи\r\n        функции \"parse()\" из библиотеки \"querystring\" мы парсим строку с параметрами адресной строки, превращая ее в\r\n        объект, например, \"{term: \"a\", friend: \"true\", page: \"1\"}\". Также указали, чтобы этот объект воспринимался как\r\n        объект типа \"QueryParamsType\".*/\r\n\r\n        let actualCurrentPage = currentPage; /*Также в рамках первого параметра, получаем номер актуальной текущей\r\n        выбранной страницы в постраничном выводе.*/\r\n\r\n        let actualFilter = filter; /*Также в рамках первого параметра, получаем актуальные данные для фильтрации\r\n        пользователей в постраничном выводе.*/\r\n\r\n        if (!!parsed.page) actualCurrentPage = Number(parsed.page); /*Также в рамках первого параметра, если в\r\n        параметрах адресной строки была указана текущая выбранная страница, то ее номер запишется в переменную\r\n        \"actualCurrentPage\". При помощи функции \"Number()\" приводим строку к числу. При помощи \"!!\" переводим значение\r\n        \"parsed.page\" в булевый тип.*/\r\n\r\n        if (!!parsed.term) actualFilter = {...actualFilter, term: parsed.term as string}; /*Также в рамках первого\r\n        параметра, если в параметрах адресной строки был указан параметр \"term\", то значение этого параметра запишется в\r\n        переменную \"actualFilter\". Делаем здесь глубокое копиривание, чтобы соблюдать иммутабельность, поскольку\r\n        работаем с объектом. Если мы укажем в адресной строке какой-либо параметр больше одного раза, то ни один из них\r\n        не будет перезатирать других, и если мы получаем эти параметры в виде строки, переводя ее в объект, то этот\r\n        параметр в объекте будет иметь значение массива со всеми значениями этого параметра, указанными в адресной\r\n        строке, поэтому мы указываем, чтобы значение параметра \"term\" воспринималось как строка при помощи \"as string\".\r\n        При помощи \"!!\" переводим значение \"parsed.term\" в булевый тип.*/\r\n\r\n        switch (parsed.friend) { /*Также в рамках первого параметра, если в параметрах адресной строки был указан\r\n        параметр \"friend\", то значение этого параметра запишется в переменную \"actualFilter\". Делаем здесь глубокое\r\n        копиривание, чтобы соблюдать иммутабельность, поскольку работаем с объектом. Используем здесь конструкцию\r\n        \"switch/case\", чтобы преобразовывать строковые значения в булевый тип или \"null\".*/\r\n            case 'null':\r\n                actualFilter = {...actualFilter, friend: null};\r\n                break;\r\n            case 'true':\r\n                actualFilter = {...actualFilter, friend: true};\r\n                break;\r\n            case 'false':\r\n                actualFilter = {...actualFilter, friend: false};\r\n                break;\r\n        };\r\n\r\n        dispatch(usersAC.setCurrentPage(actualCurrentPage)); /*Также в рамках первого параметра вызываем AC\r\n        \"setCurrentPage\" для установки значения текущей выбранной страницы в постраничном выводе пользователей в\r\n        \"state\", передав номер актуальной текущей выбранной страницы, который был получен из параметров адресной\r\n        строки.*/\r\n\r\n        dispatch(requestUsers(actualCurrentPage, pageSize, actualFilter)); /*Также в рамках первого параметра вызываем\r\n        TC \"requestUsers\" для запроса и установки данных по пользователям в постраничном выводе, передав значение\r\n        актуальной текущей выбранной страницы, максимальное количество пользователей на одной странице в постраничном\r\n        выводе и актуальные данные для фильтрации пользователей в постраничном выводе.*/\r\n    },\r\n        [] /*Второй параметр это пустой массив, так как мы хотим, чтобы все, что есть в первом параметре сработало\r\n        только один раз после отрисовки компонента.*/\r\n    );\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы синхронизировать данные для фильтрации пользователей в\r\n    постраничном выводе и номер текущей выбранной страницы в постраничном выводе из глобального \"state\" с аналогичными\r\n    данными из UI, чтобы указать эти данные в адресной строке в виде параметров. Это использование хука \"useEffect\"\r\n    должно обязательно идти после предыдущего использования хука \"useEffect\", иначе будут затираться полученные из\r\n    параметров адресной строки данные при отрисовке компонента, поскольку порядок хуков имеет значение.*/\r\n        const query: QueryParamsType = {}; /*В рамках первого параметра создаем объект типа \"QueryParamsType\", который в\r\n        дальнейшем будет хранить объект, сформированный на основе параметров адресной строки, который будет содержать\r\n        свойства, обозначающие данные для фильтрации пользователей в постраничном выводе и номер текущей выбранной\r\n        страницы в постраничном выводе.*/\r\n\r\n        if (!!filter.term) {\r\n            query.term = filter.term;\r\n            setIsJustCreated(false);\r\n            setIsNotJustCreated(true);\r\n        }; /*Также в рамках первого параметра, если есть свойство \"term\" в объекте \"filter\", то добавляем его в наш\r\n        объект \"query\". При помощи \"!!\" переводим значение \"filter.term\" в булевый тип. Также указываем, что успели\r\n        указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции \"setIsJustCreated\" и\r\n        функции \"setIsNotJustCreated\" из хуков \"useState\" выше.*/\r\n\r\n        if (filter.friend !== null) {\r\n            query.friend = String(filter.friend);\r\n            setIsJustCreated(false);\r\n            setIsNotJustCreated(true);\r\n        }; /*Также в рамках первого параметра, если свойство \"friend\" в объекте \"filter\" не равно \"null\", то есть равно\r\n        \"true\" или \"false\", то преобразовываем значение этого свойства в строку при помощи функции \"String()\" и\r\n        добавляем преобразованное значение в наш объект \"query\". Также указываем, что успели указать данные для\r\n        фильтрации пользователей в постраничном выводе при помощи вызова функции \"setIsJustCreated\" и функции\r\n        \"setIsNotJustCreated\" из хуков \"useState\" выше.*/\r\n\r\n        if (currentPage !== 1) {\r\n            query.page = String(currentPage);\r\n            setIsJustCreated(false);\r\n            setIsNotJustCreated(true);\r\n        }; /*Также в рамках первого параметра, если номер текущей выбранной страницы не равен \"1\", то сохраняем этот\r\n        номер, переведя его в строку при помощи функции \"String()\", в наш объект \"query\". Также указываем, что успели\r\n        указать данные для фильтрации пользователей в постраничном выводе при помощи вызова функции \"setIsJustCreated\" и\r\n        функции \"setIsNotJustCreated\" из хуков \"useState\" выше.*/\r\n\r\n        if (currentPage === 1 && isNotJustCreated) {\r\n            query.page = String(currentPage);\r\n            setIsJustCreated(false);\r\n            setIsNotJustCreated(false);\r\n        }; /*Также в рамках первого параметра, если номер текущей выбранной страницы равен \"1\" и мы успели уже указать\r\n        данные для фильтрации пользователей в постраничном выводе, то сохраняем этот номер, переведя его в строку при\r\n        помощи функции \"String()\", в наш объект \"query\". Также указываем, что успели указать данные для фильтрации\r\n        пользователей в постраничном выводе при помощи вызова функции \"setIsJustCreated\" из хука \"useState\" выше, но в\r\n        этот раз вызываем функцию \"setIsNotJustCreated\" из хука \"useState\" выше, чтобы изменить свойство\r\n        \"isNotJustCreated\" в локальном \"state\" на \"false\", чтобы если мы после того, как мы совершим следующие операции:\r\n        1) Отрисовать компонент \"Users.tsx\";\r\n        2) Указать какие-либо параметры для фильтрации пользователей в постраничном выводе и сделать запрос\r\n        пользователей;\r\n        3) Сбросить все параметры (в том числе выбрать первую страницу) для фильтрации пользователей в постраничном\r\n        выводе и сделать запрос пользователей;\r\n        4) Отрисовать другой компонент;\r\n        5) Еще раз отрисовать компонент \"Users.tsx\";\r\n        мы не затриггерили функцию \"push\", чтобы библиотека \"Ant Design\" не свернула все подменю в навигационном меню,\r\n        так как по стандартному поведению библиотеки \"Ant Design\" если мы взаимодействуем с некоторыми элементами UI\r\n        (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все подменю.*/\r\n\r\n        if (!isJustCreated) { /*Поскольку работа функции \"push\" по изменению адресной строки считается UI-фреймворком\r\n        \"Ant Design\" за взаимодействие с UI, поэтому при первом нажатии на пункт \"Users\" сворачивается подменю \"People\",\r\n        так как по стандартному поведению UI-фреймворка \"Ant Design\" если мы взаимодействуем с некоторыми элементами UI\r\n        (например, нажимаем на кнопки или меняем параметры адресной строки), то сворачиваются все подменю. Поэтому мы\r\n        добавили проверку, чтобы выполнять эту функцию \"push\" только в том случае, когда какие-либо из данных в\r\n        \"state\", которые используются для формирования параметров адресной строки, были изменены.*/\r\n            history.push({ /*Также в рамках первого параметра вызываем функцию \"push\" объекта \"history\", который\r\n            возвращается хуком \"useHistory\", для того, чтобы перенаправить нас на адрес по пути \"/users\", дописав к\r\n            этому пути параметры адресной строки из свойства \"search\" объекта \"history\".*/\r\n                pathname: '/users',\r\n                search: queryString.stringify(query) /*Здесь при помощи функции \"stringify()\" из библиотеки\r\n                \"querystring\" мы преобразовываем наш объект \"query\" в строку, в итоге, например, получая строку\r\n                \"?term=dad&friend=false&page=2\". Аналогично мы могли бы не формировывать наш объект \"query\" сверху и\r\n                написать здесь так: \"search: `?term=${filter.term}&friend=${filter.friend}&page=${currentPage}`\".*/\r\n            });\r\n        };\r\n    },\r\n        [filter, currentPage] /*Второй параметр это данные для фильтрации пользователей в постраничном выводе и\r\n        номер текущей выбранной страницы в постраничном выводе из глобального \"state\". Если эти данные будут меняться,\r\n        то будет срабатывать каждый раз все то, что указано в первом параметре.*/\r\n    );\r\n\r\n    const onPageChange = (pageNumber: number) => { /*Создали специальную функцию, которая будет вызываться при смене\r\n    страницы в постраничном выводе пользователей. Эта функция принимает номер новой текущей выбранной страницы.*/\r\n        dispatch(usersAC.setCurrentPage(pageNumber)); /*Вызываем AC \"setCurrentPage\" для установки значения текущей\r\n        выбранной страницы в постраничном выводе пользователей в \"state\", передав номер новой текущей выбранной\r\n        страницы.*/\r\n        dispatch(requestUsers(pageNumber, pageSize, filter)); /*Вызываем TC \"requestUsers\" для запроса и установки\r\n        данных по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы, максимальное\r\n        количество пользователей на одной странице в постраничном выводе и данные для фильтрации пользователей в\r\n        постраничном выводе.*/\r\n    };\r\n\r\n    const onFilterChange = (filter: UsersFilterType) => { /*Создали специальную функцию, которая будет вызываться при\r\n    изменении данных по фильтрам для отображения пользователей в постраничном выводе пользователей. Эта функция\r\n    принимает данные по фильтрам для отображения пользователей в постраничном выводе пользователей, которые должны быть\r\n    типа \"UsersFilterType\", который мы создали и импортировали сюда.*/\r\n        dispatch(requestUsers(1, pageSize, filter)); /*Вызываем TC \"requestUsers\" для запроса и установки\r\n        данных по пользователям в постраничном выводе, передав значение новой текущей выбранной страницы (указали \"1\",\r\n        так как если бы передавали сюда последнюю текущую выбранную страницу, то могли бы быть случаи, когда мы уже\r\n        вывели несколько страниц пользователей, перешли на какую-то страницу, кроме первой, потом сделали новый запрос\r\n        пользователей с другими фильтрами, и нам в ответ могло прийти меньшее количество страниц пользователей, чем\r\n        номер страницы, которую мы до этого выбрали, например, были на шестой странице, а пришло пять страниц, в итоге\r\n        мы окажемся на пустой шестой странице, а указав \"1\", после каждого нового запроса пользователей нас будет всегда\r\n        сбрасывать на первую страницу), максимальное количество пользователей на одной странице в постраничном выводе и\r\n        данные для фильтрации пользователей в постраничном выводе.*/\r\n        dispatch(usersAC.setCurrentPage(1)); /*Вызываем AC \"setCurrentPage\" для установки значения текущей\r\n        выбранной страницы в постраничном выводе пользователей в \"state\", передав \"1\" как номер новой текущей выбранной\r\n        страницы, чтобы избежать случая , когда мы уже вывели несколько страниц пользователей, перешли на какую-то\r\n        страницу, кроме первой, потом сделали новый запрос пользователей с другими фильтрами, и нам в ответ могло прийти\r\n        меньшее количество страниц пользователей, чем номер страницы, которую мы до этого выбрали, например, были на\r\n        шестой странице, а пришло пять страниц, в итоге мы окажемся на пустой шестой странице, а указав \"1\", после\r\n        каждого нового запроса пользователей нас будет всегда сбрасывать на первую страницу.*/\r\n    };\r\n\r\n    const unfollowCallback = (userID: number) => { /*Таким образом используем TC \"unfollow\" для передачи его в компонент\r\n    \"User\" ниже. Этот синтаксис похож на тот, который мы использовали при создании \"mapDispatchToProps\" в самом начале\r\n    (смотри компонент \"DialogsContainer.tsx\").*/\r\n        dispatch(unfollow(userID));\r\n    };\r\n\r\n    const followCallback = (userID: number) => { /*Таким образом используем TC \"follow\" для передачи его в компонент\r\n    \"User\" ниже. Этот синтаксис похож на тот, который мы использовали при создании \"mapDispatchToProps\" в самом начале\r\n    (смотри компонент \"DialogsContainer.tsx\").*/\r\n        dispatch(follow(userID));\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {isFetching ? <Preloader/> : null} {/*Если в \"state\" значение \"isFetching\" является \"true\", то показываем\r\n            компонент \"Preloader\". Этот элемент \"Preloader\" и будет нашим корневым элементом. Если же компонент\r\n            \"Preloader\" не отрисовывается, то далее отрисовываем компоненты \"UsersSearchForm\", \"Paginator\" и \"User\".*/}\r\n\r\n            {/*Отрисовываем компонент \"UsersSearchForm\" и передаем ему через \"props\" необходимы для него данные. Этот\r\n            компонент представляет из себя форму с фильтрами для поиска пользователей по различным критериям.*/}\r\n            <UsersSearchForm onFilterChange={onFilterChange}/> {/*Функция \"onFilterChange\" для обновления данных по\r\n            фильтрам для отображения пользователей в постраничном выводе пользователей при изменении этих данных.*/}\r\n\r\n            {/*Далее отрисовываем компонент \"Paginator\" и передаем ему через \"props\" необходимы для него данные.*/}\r\n            <Paginator totalItemsCount={totalUsersCount} /*Общее количество пользователей. Переименовали\r\n                       в \"totalItemsCount\", так как компонент \"Paginator\" может использоваться для постраничного вывода\r\n                       любых элементов, не только пользователей.*/\r\n                       pageSize={pageSize} /*максимальное количество пользователей на одной странице\r\n                       в постраничном выводе.*/\r\n                       currentPage={currentPage} /*Номер текущей выбранной страницы в постраничном выводе.*/\r\n                       onPageChange={onPageChange} /*Функция \"onPageChange\" для обновления данных при смене текущей\r\n                       выбранной страницы в постраничном выводе.*/\r\n                       portionSize={portionSize} /*Свойство, которое указывает какое максимальное количество\r\n                       номеров страниц в постраничном выводе может отображаться в одной порции таких страниц. Это\r\n                       сделано, чтобы не выводились все номера страниц, коих огромное количество, а имелась возможность\r\n                       выбирать страницы из порций (например, от 1 до 20, от 21 до 40) и переключаться между этими\r\n                       порциями страниц.*/\r\n            />\r\n\r\n            {/*Далее в отдельном эдлементе \"div\" отрисовываем компонент \"User\" при помощи функции \"map\".*/}\r\n            <div>\r\n                {/*\r\n                В JSX в массив можно вкладывать компоненты.\r\n                В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде\r\n                строки.\r\n                \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования\r\n                исходного массива.\r\n                Метод \"map\" принимает стрелочную функцию.\r\n                То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n                и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n                будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n                Потом будет браться следующий объект из исходного массива объектов\r\n                и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n                будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n                И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n                То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов\r\n                в изначальном массиве объектов.\r\n                В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n                Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n                В этом элементе <div> будут выводится компоненты \"User\", отображающие информацию о каждом пользователе\r\n                в постраничном выводе пользователей.\r\n                При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n                */}\r\n                {users.map(u => <User key={u.id} /*При использовании метода \"map\" нужно указывать атрибут \"key\" для\r\n                                      избежания ошибок.*/\r\n                                      user={u} /*Объект с данным по пользователю.*/\r\n                                      WhoIsInFollowingProgress={WhoIsInFollowingProgress} /*Специальное свойство,\r\n                                      которое содержит массив, который будет хранить \"ID\" пользователей, которые\r\n                                      в какой-то определенный момент находятся в процессе анфолловинга/фолловинга,\r\n                                      то есть по ним отправляются AJAX-запросы для анфолловинга/фолловинга\r\n                                      от пользователя.*/\r\n                                      unfollow={unfollowCallback} /*TC для анфолловинга пользователей.*/\r\n                                      follow={followCallback} /*TC для фолловинга пользователей.*/\r\n                />)}\r\n            </div>\r\n        </div>\r\n    )\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Music.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {};\r\n\r\n\r\n/*\r\n\"Music\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Music(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Music\" является компонентом, который отображает музыку пользователя.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nexport const Music: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            Music\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './News.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {};\r\n\r\n\r\n/*\r\n\"News\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function News(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"News\" является компонентом, который отображает новости пользователя.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nexport const News: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            News\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Settings.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {};\r\n\r\n\r\n/*\r\n\"Settings\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Settings(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Settings\" является компонентом, который отображает настройки сайта.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nexport const Settings: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            Settings\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Friends.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {};\r\n\r\n\r\n/*\r\n\"Friends\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Friends(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Friends\" является компонентом, который отображает друзей пользователя.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nexport const Friends: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\", что\r\n\"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент. Пока является заглушкой.*/}\r\n            Friends\r\n        </div>\r\n    );\r\n};","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Redirect} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\n\"Redirect\" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется\r\nатрибут \"to\".\r\nМаршрут для пути редиректа уже должен быть создан.\r\n*/\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI\r\nнежелательно общаться с BLL напрямую. Библиотека \"react-redux\" предоставляет продвинутые инструкции по созданию\r\nконтейнерных компонент и контекста.\r\n\"useSelector\" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.\r\n\"useDispatch\" - это hook, который принимает AC или TC и диспатчит их.\r\n*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"LoginForm\".\r\n- обворачиваем компонент \"LoginForm\" HOC-ом \"reduxForm\" в компоненте \"LoginReduxForm\", тем самым предоставляя\r\ncallback \"handleSubmit\" для компонента \"LoginForm\".\r\n- компонент \"LoginReduxForm\" указывается в компоненте \"Login\", куда в событие \"onSubmit\" будет попадать объект\r\nс данными, сформированный в событии \"onSubmit\" при помощи callback \"handleSubmit\" в компоненте \"LoginForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"LoginForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"onSubmitForm\" (доступен из контейнерного компонента \"LoginReduxForm\") из компонента \"Login\",\r\nв который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент\r\n\"LoginReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под именем \"login\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n\r\nВ компонент \"LoginForm\" внедряются некие дополнительные \"props\" (например, тот же \"handleSubmit\") ХОКом, который\r\nобразуется при помощи компонента \"LoginReduxForm\". Эти \"props\" содержатся под именем \"InjectedFormProps\". Эти\r\n\"InjectedFormProps\" также содержат добавленные нами \"props\". Поэтому мы импортировали \"InjectedFormProps\" из библиотеки\r\n\"reduxForm\", чтобы типизировать такие \"props\" в компоненте \"LoginForm\".\r\n*/\r\nimport {maxLengthCreator, required} from '../../utils/validators/validators'; /*Подключаем валидаторы для полей форм.*/\r\nimport {createField, GetValuesKeysType, Input} from '../common/FormsControls/FormsControls'; /*Подключаем созданный нами\r\nкомпонент \"Input\" для создания элемента \"input\" с возможностью указывать валидацию. Также импортируем функцию\r\n\"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания формы в компоненте\r\n\"LoginForm\". Дополнительно импортируем оттуда тип \"GetValuesKeysType\".*/\r\n\r\nimport {login} from '../../redux/auth-reducer'; /*Подключаем TC \"login\" из \"auth-reducer\".*/\r\n\r\nimport {\r\n    getCaptchaURL, /*Импортируем селектор, который возвращает URL капчи при логинизации.*/\r\n    getIsAuth /*Импортируем селектор, который возвращает информацию о том, что являемся ли мы залогинены в приложение\r\n    или нет.*/\r\n} from '../../redux/auth-selectors';\r\n\r\nimport styles from './Login.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport style from '../common/FormsControls/FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Создаем общий тип для всех \"props\" компонента \"Login\" путем комбинации двух созданных выше типов \"MapStateToPropsType\"\r\nи \"MapDispatchToPropsType\". Все это нужно для указания типа \"props\" в функциональном компоненте \"Login\".*/\r\ntype LoginPropsType = {\r\n\r\n};\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"LoginForm\". \"Собственные props\" в этом компоненте должны обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype LoginFormOwnPropsType = {\r\n    captchaURL: string | null /*Путь к капче, который должен быть строкой или \"null\", то есть быть пустым.*/\r\n};\r\n\r\n/*Создаем тип для \"props\" компонента \"LoginForm\", которые будут использоваться в \"formData\" для компонента \"Login\". Эти\r\n\"props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.*/\r\ntype LoginFormValuesType = {\r\n    email: string /*\"Email\" пользователя, который должен быть строкой.*/\r\n    password: string /*Пароль пользователя, который должен быть строкой.*/\r\n    rememberMe: boolean /*Информация запомнить ли пользователя, которая должна быть булева типа.*/\r\n    captcha: string /*Путь к капче, который должен быть строкой.*/\r\n};\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства \"name\" в \"createField\".\r\nЭто свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы использовали созданный\r\nнами и иимпортированный сюда вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"LoginFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"LoginFormValuesType\".*/\r\ntype LoginFormValuesKeysType = GetValuesKeysType<LoginFormValuesType>;\r\n\r\n\r\nconst maxLength30 = maxLengthCreator(30); /*Создали валидатор, который проверяет не введено ли больше\r\n30 символов в поле.*/\r\n\r\n\r\n/*\r\n\"LoginForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function LoginForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"LoginForm\" является компонентом, который представляет из себя форму логинизации в виде заготовки для обворачивания ее\r\nв HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"LoginReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым получая\r\ncallback \"handleSubmit\".\r\n*/\r\nconst LoginForm: React.FC<InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType> =\r\n    ({handleSubmit, error, captchaURL}) => {\r\n    /*При помощии деструктуризации \"props\" указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n    \"props.handleSubmit\", \"props.error\" и так далее:\r\n    - callback \"handleSubmit\";\r\n    - \"error\" - текст ошибки, которая может появиться при использовании формы, формируется при помощи библиотеки\r\n    - \"redux-form\";\r\n    - \"captchaURL\" - URL капчи при логинизации.\r\n    Такое мы делаем только в функциональных компонентах.\r\n    Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип\r\n    \"InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType> & LoginFormOwnPropsType>\". Такая комбинация\r\n    получилась следующим образом:\r\n    - \"InjectedFormProps<LoginFormValuesType, LoginFormOwnPropsType>\" - здесь мы уточнили внедренные ХОКом, который\r\n    образуется при помощи компонента \"LoginReduxForm\", \"InjectedFormProps\". \"LoginFormValuesType\" указывает, что\r\n    приходит из этого ХОКа, а \"LoginFormOwnPropsType\" указывает, что приходит со стороны - \"captchaURL\".\r\n    - \"& LoginFormOwnPropsType\" - также этот компонент содержит некие свои собственные \"props\", которые не приходят от\r\n    ХОКа выше - тот же \"captchaURL\".\r\n    Это мы сделали на основании файла декларации \"InjectedFormProps\" (\"Ctrl+click\" в \"WebStorm\"). Там указано, что\r\n    первым параметром принимаются \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого\r\n    обворачиваем \"reduxForm\" (то есть компонент \"LoginForm\"), и собственные \"props\" этого компонента \"LoginForm\",\r\n    которые не приходят от ХОКа выше (так нужно для внутренней работы \"InjectedFormProps\"); а вторым параметром\r\n    принимаются еще раз некие свои собственные \"props\", которые не приходят от ХОКа выше (так уже надо для работы самого\r\n    этого компонента \"LoginForm\"). Третьим параметром принимается вид ошибки формы типа строка, но данном случае мы\r\n    этого не указываем. Только все эти три параметра указываются как бы вместе как единый параметр, а не через запятую\r\n    как три разных параметра. ВОЗМОЖНО, это потому, что \"InjectedFormProps\" это объект (как единое целое состоит из\r\n    разных свойств, которые можно типизировать суммой разных типов), а тот же \"reduxForm\" это функция (принимает\r\n    последовательность параметров, где каждый параметр нужно отдельно типизировать).\r\n    */\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указывает\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            {createField<LoginFormValuesKeysType>\r\n            (\"Email\", \"email\", Input, [required, maxLength30])}\r\n            {/*Создали поле для ввода почты на основе импортированной функции \"createField\". Уточняем здесь функцию\r\n            \"createField\", что она имеет тип \"LoginFormValuesKeysType\", созданный нами выше.*/}\r\n            {createField<LoginFormValuesKeysType>\r\n            (\"Password\", \"password\", Input, [required, maxLength30], {type: \"password\"})}\r\n            {/*Создали поле для ввода пароля на основе импортированной функции \"createField\". Уточняем здесь функцию\r\n            \"createField\", что она имеет тип \"LoginFormValuesKeysType\", созданный нами выше.*/}\r\n            {createField<LoginFormValuesKeysType>\r\n            (undefined, \"rememberMe\", Input, [], {type: \"checkbox\"}, \"Remember me?\")}\r\n            {/*Добавили чек-бокс \"Запомнить меня?\" на основе импортированной функции \"createField\". \"undefined\" означает\r\n            отсутствие свойства.  Уточняем здесь функцию \"createField\", что она имеет тип \"LoginFormValuesKeysType\",\r\n            созданный нами выше.*/}\r\n\r\n            {captchaURL && <img src={captchaURL} alt=\"\"/>} {/*Если есть капча, то отрисуем элемент \"img\"\r\n            с изображением капчи.*/}\r\n            {captchaURL && createField<LoginFormValuesKeysType>\r\n            (\"Enter the captcha\", \"captcha\", Input, [required])}\r\n            {/*Если есть капча, то отрисуем поле для ввода текства с капчи. Это поле создается на основе импортированной\r\n            функции \"createField\". Уточняем здесь функцию \"createField\", что она имеет тип \"LoginFormValuesKeysType\",\r\n            созданный нами выше.*/}\r\n\r\n            {error && <div className={style.formSummaryError}>{error}</div>} {/*Если произошла какая-то ошибка, то\r\n            выведем ее в отдельном элементе \"div\". Свойство \"error\" будет в объекте \"props\" благодаря\r\n            библиотеке \"redux-form\", в него подцепится значение из TC \"login\" из \"auth-reducer.ts\".*/}\r\n\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>Log in</button>\r\n            </div>\r\n        </form>\r\n    );\r\n};\r\n\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"LoginForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"LoginReduxForm\" будет заниматься общением\r\nс глобальным \"state\".*/\r\nconst LoginReduxForm = reduxForm<LoginFormValuesType, LoginFormOwnPropsType>({ /*\"reduxForm\" является \"generic\",\r\nпоэтому мы его уточнили. В файле декларации \"reduxForm\" (\"Ctrl+click\" в \"WebStorm\") указано, что он принимает следующие\r\nданные:\r\n- \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого обворачиваем \"reduxForm\" (то\r\nесть компонент \"LoginForm\");\r\n- \"собственные props\" компонента, вокруг которого обворачиваем \"reduxForm\" (то есть компонент \"LoginForm\");\r\n- вид ошибки формы типа строка, но данном случае мы этого не указываем.*/\r\n    form: 'login' /*Это то самое уникальное имя для данных этой формы, которые будут попадать в глобальный \"state\".*/\r\n})(LoginForm);\r\n\r\n\r\n/*\r\n\"Login\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Login(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Login\" является компонентом, который представляет из себя финальную страницу с формой логинизации.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВнутри компонента \"Login\" подключается компонент \"LoginReduxForm\", в котором обворачиваем компонент \"LoginForm\"\r\nHOC-ом \"reduxForm\", тем самым предоставляя callback \"handleSubmit\" для компонента \"LoginForm\".\r\n*/\r\nexport const Login: React.FC<LoginPropsType> = (props) => { /*Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"LoginPropsType\", созданный нами выше. Также\r\nуказали, что экспортируем этот компонент.*/\r\n    const captchaURL = useSelector(getCaptchaURL); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getCaptchaURL\", получаем URL капчи при логинизации.*/\r\n    const isAuth = useSelector(getIsAuth); /*При помощи хука \"useSelector\", передав в него селектор \"getIsAuth\",\r\n    получаем информацию о том, что являемся ли мы залогинены в приложение или нет.*/\r\n\r\n    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука \"useDispatch\".*/\r\n\r\n    const onSubmitForm = (formData: LoginFormValuesType) => { /*Создали специальный callback \"onSubmitForm\", который\r\n    будет вызываться при срабатывании события \"onSubmit\" в форме. Этот callback будет собирать все данные формы (email\r\n    пользователя, пароль пользователя, указание запомнить ли данные входа, и капча, если присуствует) в одном месте. Эти\r\n    данные будут отдаваться TC \"login\" для осуществления логинизации. Этот callback получает указанные данные на входе в\r\n    объекте \"formData\" с типом \"LoginFormValuesType\".*/\r\n        dispatch(login(formData.email, formData.password, formData.rememberMe, formData.captcha));\r\n    };\r\n\r\n    if (isAuth) { /*Если пользователь залогинен, то его должно перенаправить на страницу профиля, вместо показа\r\n    формы для логинизации.*/\r\n        return <Redirect to={'/profile/'}/>\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <h1>Log in</h1> {/*Отрисовываем элемент \"h1\" c текстом \"Log in\".*/}\r\n            <LoginReduxForm onSubmit={onSubmitForm} captchaURL={captchaURL}/> {/*Здесь в событии \"onSubmit\" будет\r\n            приходить объект с данными из callback \"handleSubmit\" из компонента \"LoginForm\", который обвернут\r\n            компонентом \"LoginReduxForm\". Далее будет вызываться при этом событии нами созданный\r\n            callback \"onSubmitForm\", в который будет передаваться этот объект с данными. После этого эти данные будут\r\n            отправлятся в часть глобального \"state\", которую обрабатывает библиотека \"redux-form\", с целью\r\n            осуществления работы нашей формы логина. Поскольку мы вызываем функцию \"onSubmitForm\" как callback,\r\n            поэтому не ставим \"()\" после имени функции.*/}\r\n        </div>\r\n    );\r\n};","/*\r\nПри отрисовке приложения в браузере файлы проекта собираются в отдельные группы файлов - бандлы (bundles). При помощи\r\nних HTTP быстрее загружает приложение. Можно сделать так, чтобы подгружалось только то, что необходимо для отображения,\r\nа не все бандлы. Все остальное будет загружаться по необходимости. Это называется \"lazy loading\". В зависимости от\r\nцелей можно использовать \"lazy loading\" или загружать бОльшее количество бандлов. Бандлы собираются путем пробега\r\n\"WebPack\" по импортам в проекте. Компоненты в \"lazy loading\" нужно обворачивать в \"Suspense\" из \"ReactJS\". Для этого\r\nобварачивания мы создали этот HOC \"WithSuspense.tsx\". Далее мы используем этот HOC в компоненте \"App.tsx\" для\r\nкомпонентов \"DialogContainer.jsx\" и \"ProfileContainer.tsx\".\r\n*/\r\n\r\nimport React, {Suspense, ComponentType} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nИмпортируем \"Suspense\" для реализации \"lazy loading\" (больше об этом в HOC \"WithSuspense.tsx\").\r\nИмпортируем \"ComponentType\" для типизации.\r\n*/\r\n\r\nimport {Preloader} from '../components/common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\r\n\r\n\r\nexport function withSuspense<WrappedProps> (Component: ComponentType<WrappedProps>) { /*Это и есть наш HOC, который в\r\nкачестве параметра принимает какой-либо компонент \"Component\". Не используем здесь синтаксис стрелочной функции, чтобы\r\nможно было уточнить \"props\" как \"WrappedProps\", как мы это сделали здесь.\r\n\r\nЭтот HOC принимает какой-то \"generic\" компонент \"Component\", который ожидает \"props\" c типом \"WrappedProps\". Компонент\r\n\"Component\" должен быть типа \"ComponentType\", то есть быть каким-то компонентом из \"ReactJS\".\r\n\r\nУточняем, что внутри ожидаются \"props\" c типом \"WrappedProps\", то есть теже \"props\" компонента \"Component\", который мы\r\nбудем передавать в этот HOC, так как наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\".*/\r\n    return (props: WrappedProps) => { /*Наш HOC возвращает другой компонент, \"props\" которого являются тоже типа\r\n    \"WrappedProps\", так как опять же наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\"*/\r\n        return ( /*Этот HOC обварачивает полученный компонент \"Component\" в тег \"Suspense\" для реализации \"lazy\r\n        loading\". Также в этот компонент \"Component\" передаются все его изначальные \"props\".*/\r\n            <Suspense fallback={<Preloader/>}> {/*Пока будет идти загрузка компонента будет показываться\r\n            компонент-заглушка \"Preloader\".*/}\r\n                <Component {...props}/>\r\n            </Suspense>\r\n        )\r\n    };\r\n};\r\n","/*\r\nЭто файл \"reducer\", отвечающего за сайдбар. Каждый \"reducer\" состоит из:\r\n- констант, содержащих значения для свойства \"type\" объекта \"action\"\r\n- \"initialState\" - своей части \"state\"\r\n- самой функции \"reducer\"\r\n- \"Action Creators\" или \"AC\"\r\n- \"Thunk Creators\" или \"TC\".\r\n*/\r\n\r\nimport avatarSource from '../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\nimport {AvatarSourceType} from '../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\nexport type InitialSidebarStateType = typeof initialState;\r\n\r\n/*Создаем тип для объектов с данными по друзьям, которые в онлайне и отображаются в сайдбаре. Объект, содержащий\r\nинформацию с данными по друзьям, которые в онлайне и отображаются в сайдбаре, должен обязательно содержать следующие\r\nполя с указанными типами.*/\r\ntype FriendType = {\r\n    id: number /*\"ID\" друга в онлайне должно быть числом.*/\r\n    name: string /*Имя друга в онлайне должно быть числом.*/\r\n    avatar: AvatarSourceType /*Аватар друга в онлайне должен быть типа \"AvatarSourceType\".*/\r\n};\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = {\r\n    friendsData: [ /*Создаем массив объектов, которые хранят информацию о друзьях пользователя в онлайне, которые\r\n    отображаются в сайдбаре.*/\r\n        {id: 1, name: 'Abba', avatar: avatarSource},\r\n        {id: 2, name: 'Bret', avatar: avatarSource},\r\n        {id: 3, name: 'Carry', avatar: avatarSource}\r\n    ] as Array<FriendType> /*Указываем, что этот массив объектов имеет тип массива элементов с типом \"FriendType\".\r\n    Тип \"FriendType\" был создан нами выше.*/\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst sidebarReducer = (state = initialState, action: any): InitialSidebarStateType => {\r\n/*Указываем, что тип \"state\" на выходе имеет тот же тип \"InitialSidebarStateType\", что и \"state\" на входе.*/\r\n    return state; /*Этот \"reducer\" просто возвращает \"state\".*/\r\n};\r\n\r\nexport default sidebarReducer; /*Экспортируем \"sidebarReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"sidebarReducer\", экспорт необходим для импорта.*/","/*\r\nНам нужен этот \"reducer\", чтобы избежать моргания страницы (кроме страницы профиля) после \"F5\", так как после каждого\r\nобновления страницы отправляется запрос на логинизацию, и пока осуществляется этот запрос мы будем считаться\r\nнезалогиненными, соотвественно будем видеть страницу логинизации, а когда запрос на логинизацию завершится мы увидим\r\nстраницу профиля вместо нужной нам страницы. И чтобы этого не допустить мы не будем ничего показывать, пока не убедимся\r\nчто мы залогинены.\r\n*/\r\n\r\nimport {getAuthUserData} from './auth-reducer'; /*Подключаем TC \"getAuthUserData\"  для запроса и установки данных\r\nзалогиненного пользователя в \"state\" из \"auth-reducer.ts\".*/\r\n\r\nimport {InferActionsTypes, BaseThunkType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип \"state\" из самого \"state\" при помощи \"typeof\".*/\r\ntype InitialAppStateType = typeof initialState;\r\n\r\n/*Создаем сам \"state\".*/\r\nlet initialState = { /*Указываем, что \"initialState\" имеет тип \"InitialStateType\", созданный нами\r\nвыше.*/\r\n    initialized: false /*Свойство, которое показывает инициализировано ли приложение.*/\r\n};\r\n\r\n\r\n/*\r\nЭто \"reducer\" - чистая функция, которая принимает объект \"action\" и копию части \"state\".\r\nПотом \"reducer\" изменяет (или не изменяет, если объект \"action\" не подошел) определенную часть \"state\" и возвращает ее.\r\nПосле этого все возвращенные части \"state\" всех \"reducers\" собираются в новый \"state\".\r\n*/\r\nconst appReducer = (state = initialState, action: ActionsType): InitialAppStateType => { /*Указываем,\r\nчто тип \"state\" на выходе имеет тот же тип \"InitialAppStateType\", что и \"state\" на входе. На входе объекты \"action\"\r\nимеют тип \"ActionsType\", созданный нами ниже.*/\r\n    switch (action.type) {\r\n        case 'demo-spa/app-reducer/INITIALIZATION-SUCCESSFUL':\r\n            return { /*Указываем, что приложение успешно инициализировано.*/\r\n                ...state, /*Делаем поверхностную копию \"state\". На данный момент этого не требуется, так как далее\r\n                мы меняем примитив.*/\r\n                initialized: true /*Меняем свойство, показывающее инициализировано ли приложение.*/\r\n            };\r\n\r\n        default: /*Если объект \"action\" никуда не подошел, то по default возвращается тот же \"state\", чтобы не вызвать\r\n        перерисовку.*/\r\n            return state;\r\n    }\r\n};\r\n\r\n\r\n/*Создаем типы для объектов \"action\".*/\r\ntype ActionsType = InferActionsTypes<typeof appAC>; /*Здесь мы все созданные раннее типы для объектов \"action\"\r\nобъеденили в один тип. Мы его получили следующим образом: используем экспортированный сюда тип \"InferActionsTypes\" для\r\nопределения типов всех объектов \"action\" у упакованных в единый объект \"appAC\" AC.*/\r\n\r\n\r\n/*\r\nAction Creators.\r\nAC создает объект, который передается в reducer.\r\nЭтот объект как минимум должен иметь свойство \"type\", которое определяет, что необходимо выполнить в reducer.\r\n*/\r\nexport const appAC = { /*Создали специальный объект, содержащий все наши AC. Также удалили все типы, созданные\r\nраннее на основе каждого AC. Также вверху удалили все константы со значениями для \"type\" и указывываем их сразу в AC,\r\nтак как \"TypeScript\" не даст нам допустить ошибку при указании этих \"types\" в \"reducer\". Согласно модульному паттерну\r\n\"Redux Ducks\", чтобы избежать случаев одиноковых значений свойств \"type\" из-за чего один и тот же объект \"action\" может\r\nсработать в нескольких \"reducers\", в значениях свойств \"type\" в объекте \"action\" указываются\r\n\"имя-проекта/имя-файла/имя-объекта-action\". Также в конце везде добавили \"as const\", чтобы \"reducer\" адекватно\r\nвоспринимал объекты \"action\". Все AC мы поместили в единый объект с целью избавиться от большого количества отдельных\r\nтипов для каждого AC в обмен на один общий для них тип, который мы создали выше.*/\r\n    initializingApp: () => ({ /*AC для инициализации приложения.*/\r\n        type: 'demo-spa/app-reducer/INITIALIZATION-SUCCESSFUL' /*Обязательно свойство \"type\" для AC.*/\r\n    } as const)\r\n};\r\n\r\n\r\n/*Создаем типы для \"Thunk Creators\".*/\r\ntype ThunkType = BaseThunkType<ActionsType>; /*Создали тип для \"thunks\".\r\n\r\n\r\n/*\r\nThunk creators.\r\n\"Thunk\" это функция, которая может выполнять AJAX-запросы и \"dispatch\".\r\nПоскольку \"reducers\" нужны объекты \"action\" и \"reducers\" работают синхронно (AJAX-запросы несинхронные, поэтому будут\r\nзамедлять этот процесс),\r\nа также \"reducers\" являются чистыми функциями, то мы не можем напрямую диспатчить \"thunk\".\r\nВ таком случае, \"thunk\" должен сначала сам запуститься, внутри него задиспатчаться объекты \"action\" и\r\nв дальнейшем будут раскиданы по \"reducers\".\r\nВ параметрах \"thunk\" всегда приходит функция \"dispatch\".\r\n\"store\" из \"Redux\" запускает \"thunk\" и закидывает в него функцию \"dispatch\" потому, что она у него есть.\r\nНо, например, для добавления сообщения нам нужен текст этого сообщения. Чтобы передать этот текст в \"thunk\" нам нужно\r\nиспользовать замыкание из нативного JS. Полезное замыкание нужно, когда нам необходимо передать функции какие-то\r\nдополнительные данные. Замыкание появляется там, где одна функция возвращает другую функцию, и эта 2-я функция имеет\r\nдоступ к данным 1-й функции. Этой 1-й родительской функцией является \"Thunk creator\" (по аналогии с \"Action creator\").\r\nВ TC передается текст сообщения, а сам \"thunk\" возьмет это сообщения из замыкания. В итоге мы диспатчм \"TC\",\r\nа не сам \"thunk\". Также для этого нам нужен некий промежуточный слой \"thunk middleware\" между \"store.dispatch\" и\r\n\"reducers\". Если в \"store\" придет объект \"action\", то \"thunk middleware\" передаст его в \"reducers\". Если же в \"store\"\r\nпридет \"thunk\", то \"thunk middleware\" запустить этот \"thunk\", закинет в него функцию \"dispatch\" и на выходе будет\r\nобъект \"action\", который затем будет передан в \"reducers\". Если в \"thunk\" будет несколько AC, то сначала отправится\r\nпервый AC в \"thunk middleware\", потом второй AC и так далее до тех пор, пока не переберутся все AC. Это и есть\r\nзамыкание. Для установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\". Установка происходит в файле со \"store\"\r\nиз \"redux\". В TC мы диспатчим не сам AC, а их вызовы.\r\n*/\r\nexport const initializeApp = (): ThunkType => (dispatch) => {\r\n/*TC для инициализации приложения. Этот TC на выходе возвращает \"thunk\", который имеет тип \"ThunkType\", созданный нами\r\nвыше. Мы могли здесь также указать тип \"dispatch\", \"getState()\" и дополнительных аргументов, но типизируя то, что\r\nвозвращает TC, то есть \"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые\r\n\"dispatch\", \"getState()\" и дополнительные аргументы.*/\r\n    let promise = dispatch(getAuthUserData()); /*Здесь \"dispatch\" возвращает то, что вернет \"getAuthUserData\" (TC\r\n    отвечающий за запрос и установку данных залогиненного пользователя в \"state\"), и поместит это в массив \"promise\"\r\n    (потому, что вернется массив). В этом массиве будет разная информация, в том числе и разные \"promise\".*/\r\n\r\n    Promise.all([promise]) /*Здесь мы будем ждать выполнения всех \"promise\" в массиве \"[promise]\" (причем не\r\n    важно успешно они завершатся или нет). После этого сработает блок \"then\".*/\r\n        .then(() => {\r\n            dispatch(appAC.initializingApp()); /*вызываем TC \"initializingApp\" для указания, что инициализации\r\n            приложения завершена.*/\r\n        });\r\n};\r\n/*\r\nЭтот TC работает примерно так:\r\n- сначала срабатывает TC \"getAuthUserData\".\r\n- ожидаем выполнения 1-го шага.\r\n- после завершения 1-го шага указываем, что приложение инициализировано.\r\n*/\r\n\r\nexport default appReducer; /*Экспортируем \"appReducer\" по default и будем его использовать в нашем проекте под\r\nименем \"appReducer\", экспорт необходим для импорта.*/","/*\r\nЭтот файл содержит наш \"store\", созданный при помощи библиотеки \"redux\".\r\n\"React Developer Tools\" - это плагин для браузеров, который позволяет отслеживать какой компонент\r\nсколько рендериться, увидеть дерево компонентов (props, hooks) и прочее.\r\n\"Redux DevTools\" - это плагин для браузеров, который показывает, что находится в \"state\" и все объекты \"action\",\r\nкоторые диспатчатся в \"state\".\r\n*/\r\n\r\nimport {Action, applyMiddleware, combineReducers, compose, createStore, Dispatch} from 'redux';\r\n/*\r\nБиблиотека \"redux\" помогает организовать FLUX-круговорот и \"state management\".\r\nВ \"redux\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\n\"Store\" в \"redux\" при уведомлении подписчиков не передает им \"state\".\r\nМетод \"createStore\" позволяет создать \"store\".\r\nДля работы этого \"store\" нужно создавать отдельные \"reducers\".\r\nМетод \"combineReducers\" позволяет объеденить все \"reducers\".\r\nМетоде \"applyMiddleware\" добавляет возможность указывать и подключать в \"store\" промежуточный слой между\r\n\"store.dispatch\" и \"reducers\".\r\nНам нужен будет слой \"thunk middleware\" для работы с \"thunks\".\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и HOCs.\r\nОбвертки и HOCs указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\nИмпортировали \"Dispatch\" из библиотеки \"redux\", чтобы создать тип для \"dispatch\", который передается в \"thunks\" и TC.\r\nИмпортировали \"Action\" из библиотеки \"redux\", чтобы создать тип для объектов \"action\", который передается в \"thunks\" и\r\nTC.\r\n*/\r\nimport thunkMiddleWare, {ThunkAction} from 'redux-thunk';\r\n/*\r\nДля установки \"thunk middleware\" нам нужна библиотека \"redux-thunk\".\r\n\"thunk middleware\" это промежуточный слой между \"store.dispatch\" и \"reducers\" для работы с \"thunks\".\r\nДля добавления в наш проект этого слоя мы импортируем \"thunkMiddleWare\".\r\nИмпортировали \"ThunkAction\" из библиотеки \"redux-thunk\", чтобы создать тип для \"thunks\".\r\n*/\r\nimport {reducer as formReducer} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\n*/\r\n\r\nimport profileReducer from './profile-reducer'; /*Импортируем \"reducer\", отвечающий за страницу профиля.*/\r\nimport dialogsReducer from './dialogs-reducer'; /*Импортируем \"reducer\", отвечающий за страницу диалогов.*/\r\nimport sidebarReducer from './sidebar-reducer'; /*Импортируем \"reducer\", отвечающий за сайдбар.*/\r\nimport usersReducer from './users-reducer'; /*Импортируем \"reducer\", отвечающий за страницу пользователей.*/\r\nimport authReducer from './auth-reducer'; /*Импортируем \"reducer\", отвечающий за аутентификацию пользователей.*/\r\nimport appReducer from './app-reducer'; /*Импортируем \"reducer\", отвечающий за инициализацию приложения.*/\r\nimport chatReducer from './chat-reducer'; /*Импортируем \"reducer\", отвечающий за чат в нашем приложении.*/\r\n\r\n\r\n/*Делаем на основе нашего корневого \"reducer\" \"rootReducer\" тип при помощи \"typeof\". В итоге там получится что-то вроде\r\nфункции \"(globalState: AppStateType) => AppStateType\", то есть получает на входе \"state\" типа \"AppStateType\" (имя\r\nвыдумано нами) и на выходе возвращает \"state\" того же типа. То есть мы получили тип для нашего \"rootReducer\".*/\r\ntype RootReducerType = typeof rootReducer;\r\n\r\n/*Сохраняем тип нашего \"state\" в переменную \"AppStateType\", чтобы можно было указывать тип \"state\" в компонентах, при\r\nпомощи \"ReturnType\" (скорее всего получает тип того, что возвращается, а \"reducer\" возвращает \"state\") из типа\r\n\"rootReducer\".*/\r\nexport type AppStateType = ReturnType<RootReducerType>;\r\n\r\n\r\ntype PropertiesTypes<T> = T extends {[key: string]: infer U} ? U : never; /*В данном случае наш тип \"PropertiesTypes\"\r\nявляется \"generic\", который принимает подтип \"T\", подразумевается, что будет уточняться тип объекта в этом \"T\" при\r\nпомощи \"typeof\" (если конкретно, то \"typeof\" многих упакованных AC в единый объект). Если подтип \"T\" будет совпадать с\r\nобъектом, у которого есть какой-то ключ \"[key: string]\" (\"string\" - так как имя ключа это текст) с неким значением \"U\",\r\nто при помощи \"infer\" будет проанализировано это значение \"U\" и возвращено это значение \"U\", иначе вернет \"never\", что\r\nпримерно означает ничего не сделать. И через такой алгоритм пройдет каждое свойство объекта. Это вспомогательный тип,\r\nкоторый будет использоваться в типе \"InferActionsTypes\" ниже. Также этот тип можно использовать для определения типов\r\nAC (функции, возвращающие объекты \"action\"), упакованных в единый объект.*/\r\n\r\ntype InferActionsTypesOld<T extends {[key: string]: (...args: any[]) => any}> = ReturnType<PropertiesTypes<T>>;\r\n/*Здесь мы создаем специальный тип, который позволит нам определять тип объектов \"action\", возвращаемых AC, которые\r\nв свою очередь должны быть упакованы в единый объект. Создаем псевдоним для \"ReturnType<PropertiesType<T>>\", где \"T\"\r\nэто \"typeof packedActions\" (\"packedActions\" - одно из возможных имен объекта, содержащего все AC), под названием\r\n\"InferActionsTypes\". Здесь мы также уточняем, что в типе \"InferActionsTypes\" нужно указать ограничение (constraint) для\r\nпередаваемого \"T\", указав, что это обязательно должен быть объект, у которого в качестве значений свойств обязательно\r\nдолжны быть функции, принимающие что-нибудь и возвращающие что-нибудь, коими являются AC. Мы экспортируем этот тип,\r\nчтобы компактно определять типы объектов \"action\" в \"reducers\".*/\r\n\r\nexport type InferActionsTypes<T> = T extends {[key: string]: (...args: any[]) => infer U} ? U : never; /*Это более\r\nкраткий аналог сразу двух типов \"PropertiesTypes\" и \"InferActionsTypesOld\", которые мы создали выше выше.*/\r\n\r\n\r\n/*Создаем типы для всех \"Thunk Creators\".*/\r\nexport type BaseGetStateType = () => AppStateType; /*Создали тип для \"getState()\", который получают \"thunks\" и TC.\r\n\"getState()\" должен быть функцией, которая ничего не получает на входе и возвращает объект с типом \"AppStateType\",\r\nкоторый был создан нами. Мы это пока не используем в проекте, так как типизация \"thunks\" при помощи типа\r\n\"BaseThunkType\", который создан ниже, перекрывает эту типизацию, поскольку типизируя то, что возвращает TC, то есть\r\n\"thunk\", мы также типизировали, что в \"thunk\" будет передаваться дальше, то есть те самые \"dispatch\", \"getState()\" и\r\nдополнительные аргументы.*/\r\n\r\nexport type BaseDispatchType<ActionsType extends Action> = Dispatch<ActionsType>; /*Создали тип для \"dispatch\", который\r\nпередается в \"thunks\" и TC. \"dispatch\" должен быть \"Dispatch\" из библиотеки \"redux\", работающий с объектами \"action\"\r\nтипа \"ActionsType\", который мы должны указывать первым параметром и который в свою очередь должен совпадать с \"Action\"\r\nиз библиотеки \"redux\".*/\r\n\r\nexport type BaseThunkType<ActionsType extends Action, R = void> = ThunkAction<R, AppStateType, unknown, ActionsType>;\r\n/*Создали тип для \"thunks\". \"thunks\" должны быть объектами \"action\" для \"thunks\" с типом \"ThunkAction\" из библиотеки\r\n\"redux-thunk\", работающими с:\r\n1. промисами, которые ничего не возвращают (промисы потому, что у нас асинхронные \"thunks\" из-за использования\r\n\"async/await\", хотя обычно \"thunks\" ничего не возвращают), указываем их вторым параметром \"R\" и поскольку \"thunks\"\r\nобычно ничего не возвращают, то делаем значение \"void\" значением по умолчанию этого параметра \"R\", хотя в уроке было\r\nуказано \"Promise<void>\" вместо \"void\", но такой вариант не работал в типизации \"app-reducer.ts\", поскольку там мы\r\nиспользуем \"Promise.all\";\r\n2. \"state\" с типом \"AppStateType\", который был создан нами;\r\n3. какими-то неизвестными дополнительными аргументами;\r\n4. объектами \"action\" типа \"ActionsType\", который мы должны указывать первым параметром \"ActionsType\" и который должен\r\nсовпадать с \"Action\" из библиотеки \"redux\".\r\nЭти уточнения мы нашли в файле декларации \"ThunkAction\", \"Ctrl+click\" в \"WebStorm\".\r\nВ уроке (1:19) также было указано, что по умолчанию первый параметр \"ActionsType\" может быть \"Action\" из библиотеки\r\n\"redux\" (\"= Action\"), но я пока этого не стал указывать.\r\n*/\r\n\r\n\r\n/*Это список наших \"reducers\" в нашем \"store\".*/\r\nlet rootReducer = combineReducers({ /*При помощи метода \"combineReducers\" объеденяем все наши \"reducers\"\r\nв \"rootReducer\". Иногда можно дробить \"reducers\" на \"под-reducers\", которые вызываются внутри \"reducers\". Наш\r\n\"rootReducer\" сначала берет весь начальный \"state\", раздает его по кускам в \"reducers\", они в свою очередь возвращают\r\nобратно измененные куски \"state\", которые \"rootReducer\" собирает в новый \"state\" и возвращает его.*/\r\n    profilePage: profileReducer,\r\n    dialogsPage: dialogsReducer,\r\n    sidebar: sidebarReducer,\r\n    usersPage: usersReducer,\r\n    auth: authReducer,\r\n    form: formReducer, /*Здесь важно, чтобы часть \"state\", которая создается библиотекой \"redux-form\", называлась\r\n    именно \"form\", иначе придется многое переписывать дополнительно.*/\r\n    app: appReducer,\r\n    chat: chatReducer\r\n});\r\n\r\n\r\n/*Здесь идет создание \"store\" и установка плагина \"Redux DevTools\".*/\r\n/*Также далее идет комментарий, который говорит \"TypeScript\", чтобы он игнорировал следующий\r\nза этим комментарием код.*/\r\n// @ts-ignore\r\nconst composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\r\n/*\"window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__\" - это какой-то глобальный объект из плагина \"Redux DevTools\".\r\nЭта строчка является необходимой для того, чтобы плагин \"Redux DevTools\" работал.\r\nЭтим \"composeEnhancers\" мы ниже обварачиваем создание промежуточного слоя \"thunkMiddleWare\" в \"store\",\r\nчто также необходимо, чтобы плагин \"Redux DevTools\" работал.*/\r\nconst store = createStore(rootReducer, composeEnhancers(applyMiddleware(thunkMiddleWare)));\r\n/*\r\nПри помощи метода \"createStore\"\r\nсоздаем \"store\", передавая ему наш \"rootReducer\". При помощи метода \"applyMiddleware\" указываем, что подключаем в\r\n\"store\" промежуточный слой \"thunkMiddleWare\".\r\n*/\r\n\r\n\r\n/*Далее идет комментарий, который говорит \"TypeScript\", чтобы он игнорировал следующий\r\nза этим комментарием код. Если же все-таки нужно будет типизировать объект \"window\", то вроде можно написать такое:\r\n\r\ndeclare global {\r\n    interface Window {\r\n        __REDUX_DEVTOOLS_EXTENSION_COMPOSE__: any,\r\n        store: any\r\n    }\r\n};\r\n\r\n*/\r\n// @ts-ignore\r\nwindow.__store__ = store; /*На случай если нам нужно будет глобально обратиться к \"store\".*/\r\n\r\n\r\nexport default store; /*Экспортируем весь \"store\" по default и будем его использовать в нашем проекте под\r\nименем \"store\", экспорт необходим для импорта.*/","/*\n\"GitHub\" имеет примитивный хостинг для статических страниц.\nМы создали отдельный репозиторий на GitHub (\"demo-spa\") для хостинга нашего приложения.\nЖелательно настраивать \"SSH\" вместо \"HTTPS\" в \"GitHub\".\nВ \"GitHub\" в настройках репозитория есть \"GitHub Pages\", там в \"source\" нужно выбрать \"master\" ветку.\nЧтобы сайт отобразился нужно там же в настройках выбрать тему сайта.\nЧтобы на \"GitHub\" открывалось наше приложения нужно сначала собрать его \"build\". Для этого в \"npm\" нужно выбрать \"build\"\nили ввести \"npm run build\". После этого появится папка \"build\", в которой будет лежать наше билд нашего приложения.\nНо если загрузить этот билд на \"GitHub\", то будут проблемы с URL, так как \"GitHub\" не является полноценным хостингом\nи наше приложения будет находится относительно другого URL - \"myname.github.io/repo-name/\".\nДля того, чтобы развернуть приложение на \"ReactJS\" нужно установить пакет \"gh-pages\":\n\"npm install gh-pages --save -dev\".\nДалее нужно внести изменения в файл \"package.json\", чтобы указать домашнюю страницу. Нужно в верхний уровень (например,\nперед \"dependencies\") ввести:\n\"homepage\": \"сайт-репозитория\".\nТакже здесь нужно добавить пару скриптов в раздел \"scripts\":\n\"predeploy\": \"npm run build\",\n\"deploy\": \"gh-pages -d build\".\nКоманда \"deploy\" автоматически создает ветку \"gh-pages\" на \"GitHub\" куда разместит билд нашего приложение.\nНо с \"GitHub\" запрещено делать запросы к нашему API сервера, поэтому на сайте \"API\" в настройках нужно указать домен:\n\"https://имя-аккаунта.github.io\".\nВ итоге на ветке \"master\" должен быть исходный код нашего приложения, а на ветке \"gh-pages\" билд нашего приложения.\nМы должны быть подключены к нашему удаленному репозиторию для осуществления этих действий:\n\"git remote add origin url-адресс-github-репозитория.git\". После этого уже можно делать \"deploy\".\n\nПосле этого сайт уже должен отрисовываться, но все еще могут быть некоторые проблемы.\nИзначально приложение отрисовывается по такому пути: \"имя-аккаунта-на-github/имя-репозитория/\", но при переходе\nпо компонентам, имя репозитория затирается путем для компонента (например, \"/profile\"). И если мы нажимаем \"F5\", то\n\"GitHub\" не поймет нашего адреса и не найдет наше приложение, так как будет считать, что \"/profile\" - это один из\nнаших репозиториев. Чтобы решить эту проблему нужно настроить \"BrowseRouter\" в \"App.tsx\". Там, где мы используем\nтег \"BrowserRouter\", мы должны добавить:\n\"<BrowserRouter basename={process.env.PUBLIC_URL}>\".\nЭто будет говорить, что надо автоматически брать URL из окружения. \"process\" - это глобальный объект из \"Node.JS\",\n\"env\" - это окружения, тоже из \"Node.JS\", \"PUBLIC_URL\" - если \"localhost\", то тут будет пустота, если \"GitHub\", то\n\"gh-pages\" укажет ссылку на репозиторий. Но мы это не используем в проекте, так как это все равно не решает проблему,\nпоскольку \"GitHub\" пытается после нажатия \"F5\" найти \"index.html\", например, в папке \"/profile\", про которую он\nне знает.\n\nИ для решения этой проблемы мы используем \"HashRouter\" вместо \"BrowseRouter\". \"HashRouter\" использует якори \"#\". Якори\nизначально использовались для перемещения по странице, но в дальнейшем стали использоваться для переключения страниц\nбез изменения URL. Так делали до появления \"HistoryAPI\" в \"HTML5\", поэтому \"HashRouter\" не особо используется сегодня.\nНо в нашем случае он поможет, поскольку \"#\" и все, что идет после, не будут считаться частью названия сайта и \"GitHub\"\nбудет искать \"index.html\" там, где надо. \"#\" - это браузерная фишка.\n\nТо есть перед каждым \"deploy\" нужно сделать две вещи:\n1. \"BrowseRouter\" заменить на \"HashRouter\".\n2. В файл \"package.json\" в верхний уровень (например, перед \"dependencies\") ввести:\n\"homepage\": \"сайт-репозитория\".\nА после можно вернуть все обратно.\n\nПосле каждого \"deploy\" нужно немного подождать, чтобы наше приложение обновилось на \"GitHub\".\nЧтобы в ветку \"master\" добавить исходный код нужно ввести:\n\"git push origin master\".\n*/\n\nimport React, {Suspense, ComponentType} from 'react';\n/*\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\n\"WebPack\" уже встроен в \"ReactJS\".\nИмпортируем \"Suspense\" для реализации \"lazy loading\" (больше об этом в HOC \"WithSuspense.tsx\").\nИмпортируем \"ComponentType\" для типизации.\n*/\nimport {Route, BrowserRouter, HashRouter, withRouter, Redirect, Switch} from 'react-router-dom';\n/*\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\nПодключаем \"Route\" для создания маршрутов.\nВ каждом \"Route\" указывается путь \"path\", которые прослушивается.\nТакже в каждом \"Route\" указывается компонент в \"render\", который отображается если активируется прослушиваемый путь.\nЧтобы маршруты \"Route\" работали их нужно всех обвернуть в корневой тег \"BrowserRouter\".\nДля перемещения по \"Route\" маршрутам используетс \"NavLink\" (в этом компоненте этого нет, но есть в других).\nФункция \"withRouter\" это HOC.\nHOC - high order component (компонента высшего порядка).\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\nна выходе возвращает другой компонент.\nHOC позволяет создавать однообразные контейнерные компоненты.\nПоскольку URL тоже является источником данных, то компоненту иногда могут понадобиться эти данные.\nЧтобы их получить, можно воспользоваться \"withRouter\".\nHOC \"withRouter\" принимает в качестве параметра компонент и передает ему через \"props\" данные из URL, чтобы компонент\nзнал где он находиться - т.е. какой у него маршрут.\nЕсли подключить на самом высоком уровне дерева компонентов этот HOC, например, в \"App.tsx\", то данные URL будут доступны\nи в дочерних компонентах.\nПри использовании \"connect\" роутинг сбивается. Чтобы решить эту проблемы мы обварачиваем \"connect\" при помощи\n\"withRouter\". Но сейчас вроде и без этого все работает.\n\"Redirect\" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется\nатрибут \"to\".\nМаршрут для пути редиректа уже должен быть создан.\n\"Switch\" - это аналог для реализации \"exact\" (смотри в коде ниже). Работает по принципу \"switch/case\" - как только\nнашли \"Route\" с подходящим путем, то его сразу и отрисовываем.\n\"HashRouter\" - описание в самом верху, используем только для развертывания нашего приложения на \"GitHub\".\n*/\nimport {connect, Provider} from 'react-redux';\n/*\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\nЭта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\nHOC - high order component (компонента высшего порядка).\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\nна выходе возвращает другой компонент.\nHOC позволяет создавать однообразные контейнерные компоненты.\nМетод \"connect\" используется для создания компонентов и контейнеров.\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\nМетод \"connect\" упрощает перекидывание \"props\".\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\nBLL и DAL.\n\"Provider\" позволяет указать компонент, который будет поставщиком данных BLL и DAL для всего его дочерних компонентов.\nТак же использование \"Provider\" избавляет нас от обязанности прокидывать указанные данные через все дерево компонентов.\nВ нашем случае это компонент \"AppContainer\".\n*/\nimport {compose} from 'redux';\n/*\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\nнесколько обверток вокруг компонента и HOCs.\nОбвертки и HOCs указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\n\"connect\" из библиотеки \"react-redux\".\n*/\n\nimport {Preloader} from './components/common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\nimport {Header} from './components/Header/Header'; /*Подключаем компонент \"Header\".*/\nimport {Navbar} from './components/Navbar/Navbar'; /*Подключаем компонент \"Navbar\".*/\nimport {Users} from './components/Users/Users'; /*Подключаем компонент \"Users\".*/\nimport {Music} from './components/Music/Music'; /*Подключаем компонент \"Music\".*/\nimport {News} from './components/News/News'; /*Подключаем компонент \"News\".*/\nimport {Settings} from './components/Settings/Settings'; /*Подключаем компонент \"Settings\".*/\nimport {Friends} from './components/Friends/Friends'; /*Подключаем компонент \"Friends\".*/\nimport {Login} from './components/Login/Login'; /*Подключаем компонент \"LoginPage\".*/\n\nimport {withSuspense} from './hoc/WithSuspense'; /*Подключаем наш HOC \"WithSuspense.tsx\" для реализации \"lazy loading\"\nдля компонентов \"DialogContainer.jsx\" и \"ProfileContainer.tsx\".*/\n\nimport store, {AppStateType} from './redux/redux-store'; /*Подключаем наш \"store\" из \"redux\". Также подключаем тип\n\"AppStateType\" оттуда.*/\nimport {initializeApp} from './redux/app-reducer'; /*Подключаем TC \"initializeApp\" из \"app-reducer\".*/\n\nimport './App.css'; /*Подключаем файл CSS.*/\nimport 'antd/dist/antd.css'; /*Импортируем CSS-стили из UI-фреймфорка \"Ant Design\".*/\nimport {Layout} from 'antd'; /*Импортируем из UI-фреймфорка \"Ant Design\" \"Layout\" для получения из него объектов\n\"Content\" и \"Footer\", чтобы использовать их как теги для реализации основного содержания страницы и футера.*/\n\nconst DialogsContainer = React.lazy(() => import('./components/Dialogs/DialogsContainer'));\nconst ProfileContainer = React.lazy(() => import('./components/Profile/ProfileContainer'));\nconst ChatPage = React.lazy(() => import('./pages/Chat/ChatPage'));\n/*\nЗдесь вместо стандартного импорта компонентов \"DialogContainer.jsx\" и \"ProfileContainer.tsx\" (чтобы они не попали\nв бандлы) в целях реализации \"lazy loading\" мы используем \"React.lazy\". Ниже в роутах мы обварачиваем эти компоненты\nв \"Suspense\" или в наш HOC \"WithSuspense.tsx\" для реализации \"lazy loading\". Также здесь нужно помнить, что надо делать\nэкспорт компонентов по умолчанию при использовании \"React.lazy()\", иначе придется писать дополнительный код.\n*/\n\n\n/*Создаем тип для \"MapStateToProps\". \"MapStateToProps\" в этом компоненте должен обязательно содержать следующие поля с\nуказанными типами.*/\ntype MapStateToPropsType = {\n    initialized: boolean /*Свойство, которое показывает инициализировано ли приложение, должно быть булева типа.*/\n};\n\n/*Создаем тип для \"MapDispatchToProps\". \"MapDispatchToProps\" в этом компоненте должен обязательно содержать следующие\nполя с указанными типами.*/\ntype MapDispatchToPropsType = {\n    initializeApp: () => void /*TC для инициализации приложения должен быть функцией, которая ничего не принимает и\n    ничего не возвращает.*/\n};\n\n/*Создали отдельный тип для объекта \"location\" из функции \"withRouter\" из библиотеки \"react-router-dom\".*/\ntype PathnameType = {\n    location: {\n        pathname: string\n    }\n};\n\n/*Создаем общий тип для всех \"props\" путем комбинации трех созданных выше типов. Все это нужно для указания типа\n\"props\" в классовом компоненте.*/\ntype PropsType = MapStateToPropsType & MapDispatchToPropsType & PathnameType;\n\n\nconst ProfileContainerWithSuspense = withSuspense(ProfileContainer); /*Обвернули \"withSuspense(ProfileContainer)\" в\nотдельную переменную \"ProfileContainerWithSuspense\", чтобы это можно было использовать как тег ниже в маршруте\n\"/profile/:userID?\". Мы это сделали после типизации HOC \"withSuspense\", нам из-за этого пришлось добавить в этот маршрут\n\"() => \", поскольку HOC возвращает новый компонент, но не отрисовывает его. Поэтому для отрисовки нам теперь там нужен\nтег (в маршруте \"/dialogs/\" мы уже использовали тег так-то).*/\n\nconst ChatPageWithSuspense = withSuspense(ChatPage); /*Обвернули \"withSuspense(ChatPage)\" в отдельную переменную\n\"ChatPageWithSuspense\", чтобы это можно было использовать как тег ниже в маршруте \"/chat/\". Мы это сделали после\nтипизации HOC \"withSuspense\", нам из-за этого пришлось добавить в этот маршрут \"() => \", поскольку HOC возвращает новый\nкомпонент, но не отрисовывает его. Поэтому для отрисовки нам теперь там нужен тег (в маршруте \"/dialogs/\" мы уже\nиспользовали тег так-то).*/\n\n\n/*\n\"App\" это классовый компонент.\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\nконцепцию ООП.\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\nвзаимодействует.\nНапример, у него можно постоянно запрашивать JSX.\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\nКомпонент это функция, которая возвращает JSX.\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\nJSX совмещает в себе JS и HTML.\nКомпонент это функция, которая возвращает JSX.\nJSX совмещает в себе JS и HTML.\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\nКаждый компонент желательно помещать в отдельный файл.\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\nПринято объект с параметрами именовать как \"props\".\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\n\"App\" является главным корневым компонентом, к которой в дереве компонентов подключаются остальные компоненты.\n*/\nclass App extends React.Component<PropsType/*, StateType*/> /*Указали, что \"props\" в этом классовом компоненте имеют тип\n\"PropsType\". Еще здесь можно указать тип \"state\", но мы не указали.*/ {\n    /*Далее идет код, который отлавливает отклоненные промисы. \"promiseRejectionEvent\" - это перехватчик событий.\n    Желательно вместо \"alert\" сделать красивый вывод ошибки. Внизу в \"componentDidMount()\" совместно\n    с \"componentWillUnmount()\" есть еще одна реализация перехвата отклоненных промисов. В данный момент мы не используем\n    ни один из этих вариантов, так как используем для перехвата ошибок \"try/catch\" в TC \"updateUserStatus\" в файле\n    \"profile-reducer.ts\", что будет мешать работать прослушиванию событий (хотя возможно первая реализация будет\n    работать).*/\n    /*catchAllUnhandledErrors = (promiseRejectionEvent: promiseRejectionEvent) => {\n        alert(\"some error occurred\");\n    };*/\n\n    componentDidMount() {/*Это метод жизненного цикла классового компонента. Он вызывается в момент первой отрисовки\n    (монтирования) компонента.*/\n        this.props.initializeApp(); /*При монтировании компонента вызывается TC \"initializeApp\" для инициализации\n        приложения. Поскольку мы это делаем в компоненте \"App\", который является точкой входа, то есть мы его всегда\n        видим, то это будет работать во всем приложении.*/\n\n        /*Еще одна реализация перехвата отклоненных промисов, продолжение ниже в \"componentWillUnmount()\".\n        \"window.addEventListener\" - это side effects, подписались на прослушивание событий по типу\n        \"unhandledrejection\". Когда происходит событие, то вызывается метод \"this.catchAllUnhandledErrors\".*/\n        /*window.addEventListener(\"unhandledrejection\", this.catchAllUnhandledErrors);*/\n    };\n\n    /*\"componentWillUnmount()\" - это метод жизненного цикла классового компонента. Он вызывается в момент, когда\n    компонент перестает быть отрисованным. Здесь при демонтирования компонента мы отписываемся от прослушивания\n    событий из \"componentDidMount()\".*/\n    /*componentWillUnmount() {\n        window.removeEventListener(\"unhandledrejection\", this.catchAllUnhandledErrors);\n    };*/\n\n    render() {\n        if (!this.props.initialized) { /*Пока мы не убедимся, что приложение инициализировано, мы будем показывать\n        компонент \"Preloader\", тем самым избежим мигания сайта из-за редиректов.*/\n            return <Preloader/>\n        };\n\n        const {Content, Footer} = Layout; /*При помощи деструктуризации берем объекты \"Content\" и \"Footer\" из объекта\n        \"Layout\" из UI-фреймфорка \"Ant Design\", чтобы использовать их как теги внутри для реализации основного\n        содержания страницы и футера.*/\n\n        /*\n        Здесь после return в компоненте начинается HTML разметка.\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\n        */\n        return (\n            <Layout> {/*Этот элемент \"Layout\" и есть наш корневой элемент. Элемент \"Layout\" - это макет, то есть это\n            самая внешняя структура проекта, обычно  состоящая из навигации, футера, сайдбара, уведомлений и\n            содержания.*/}\n                <Header/> {/*Отрисовываем компонет \"Header\", указывая его тег в JSX.*/}\n\n                <Content className='main-content'> {/*Элемент \"Content\" - это элемент для включения в него содержания\n                страницы. В данном случае мы включаем все содержимое страницы в этот элемент.*/}\n                    <Layout> {/*Элемент \"Layout\" - это макет, то есть это самая внешняя структура проекта, обычно\n                    состоящая из навигации, футера, сайдбара, уведомлений и содержания.*/}\n                        <Navbar location={this.props.location}/> {/*Отрисовываем компонет \"Navbar\", указывая его тег в\n                        JSX. Передаем в этот компонент информацию о пути, на котором сейчас находимся.*/}\n\n                        <Content className='actual-content'> {/*Этот элемент \"Content\" содержит основной контент нашего\n                        приложения.*/}\n                            <Switch>\n                                <Route exact path='/' /*Создаем маршрут для пути '/'. \"exact\" говорит о том, что путь\n                                должен совпадать точь в точь, то есть если, например, будет какой-то подпуть, то такой\n                                путь не подойдет.*/\n                                       render={() => <Redirect to='/profile'/>}/> {/*\"render\" это анонимная функция из\n                                       библиотеки \"react-router-dom\", которую вызовет \"Route\" при совпадении пути.\n                                       \"render\" позволяет передавать параметры. В данном случае произойдет редирект на\n                                       путь '/profile'.*/}\n\n                                {/*Это еще одна версия вышеуказанного \"Route\" редиректом. Оба варианта рабочие, если они\n                                обвернуты в тег <Switch>.*/}\n                                {/*\n                                <Route exact path='/'>\n                                    <Redirect to='/profile'/>\n                                </Route>\n                                */}\n\n                                <Route path='/dialogs/' /*Создаем маршрут для пути '/dialogs/'.*/\n                                       render={() => <Suspense fallback={<Preloader/>}><DialogsContainer/></Suspense>}/>\n                                {/*\"render\" это анонимная функция из библиотеки \"react-router-dom\", которую вызовет\n                                \"Route\" при совпадении пути. \"render\" позволяет передавать параметры. Здесь мы также\n                                использовали тег \"Suspense\", чтобы реализовать \"lazy loading\" без нашего HOC\n                                \"WithSuspense.tsx\". Также здесь указано, что пока будет идти загрузка компонента будет\n                                показываться компонент-заглушка \"Preloader\".*/}\n\n                                <Route path='/profile/:userID?' /*Создаем маршрут для пути '/profile/:userID?'.\n                                \":userID\" означает, что у пути может быть какое-то дополнение по типу \"ID\" пользователя,\n                                это не является параметром запроса. \"?\" в конце означает, что это дополнение является\n                                опциональным, если это не указать, то просто переход в \"/profile\" не отрисует\n                                компонент.*/\n                                       render={() => <ProfileContainerWithSuspense/>}/> {/*\"render\" это анонимная\n                                       функция из библиотеки \"react-router-dom\", которую вызовет \"Route\" при совпадении\n                                       пути. \"render\" позволяет передавать параметры. Здесь мы также используем наш HOC\n                                       \"WithSuspense.tsx\" для реализации \"lazy loading\".*/}\n\n                                {/*Далее представлен еще один способ реализации \"lazy loading\" для компонентов\n                                \"DialogContainer.jsx\" и \"ProfileContainer.tsx\" без использования нашего HOC\n                                \"WithSuspense.tsx\". Здесь мы сразу несколько тегов \"Route\" обварачиваем в один тег\n                                \"Suspense\". В данный момент этот вариант не используется в нашем проекте.*/}\n                                {/*\n                                <Suspense fallback={<Preloader/>}>\n                                    <Route path='/dialogs/'\n                                        render={() => <DialogsContainer/>}/>\n                                    <Route path='/profile/:userID?'\n                                        render={() => <ProfileContainer/>}/>\n                                </Suspense>\n                                */}\n\n                                <Route path='/users/' /*Создаем маршрут для пути '/users/'.*/\n                                       render={() => <Users/>}/> {/*\"render\" это анонимная функция из\n                                       библиотеки \"react-router-dom\", которую вызовет \"Route\" при совпадении пути.\n                                       \"render\" позволяет передавать параметры.*/}\n\n                                <Route path='/news/' /*Создаем маршрут для пути '/news/'.*/\n                                       render={() => <News/>}/> {/*\"render\" это анонимная функция из библиотеки\n                                       \"react-router-dom\", которую вызовет \"Route\" при совпадении пути. \"render\"\n                                       позволяет передавать параметры.*/}\n\n                                <Route path='/music/' /*Создаем маршрут для пути '/music/'.*/\n                                       render={() => <Music/>}/> {/*\"render\" это анонимная функция из библиотеки\n                                       \"react-router-dom\", которую вызовет \"Route\" при совпадении пути. \"render\"\n                                       позволяет передавать параметры.*/}\n\n                                <Route path='/settings/' /*Создаем маршрут для пути '/settings/'.*/\n                                       render={() => <Settings/>}/> {/*\"render\" это анонимная функция из библиотеки\n                                       \"react-router-dom\", которую вызовет \"Route\" при совпадении пути. \"render\"\n                                       позволяет передавать параметры.*/}\n\n                                <Route path='/friends/' /*Создаем маршрут для пути '/friends/'.*/\n                                       render={() => <Friends/>}/> {/*\"render\" это анонимная функция из библиотеки\n                                       \"react-router-dom\", которую вызовет \"Route\" при совпадении пути. \"render\"\n                                       позволяет передавать параметры.*/}\n\n                                <Route path='/login/' /*Создаем маршрут для пути '/login/'. Если нужно, что в компонент\n                                \"Login\" можно было попасть только по одному адресу, то нужно использовать\n                                \"exact path='/login/'\". Тогда, например, если перейти по пути '/login/facebook', то мы\n                                не попадем в этот компонент. Аналогичный результат можно получить, если обвернуть все\n                                \"Route\" в тег <Switch>.*/\n                                       render={() => <Login/>}/> {/*\"render\" это анонимная функция из библиотеки\n                                       \"react-router-dom\", которую вызовет \"Route\" при совпадении пути. \"render\"\n                                       позволяет передавать параметры.*/}\n\n                                <Route path='/chat/' /*Создаем маршрут для пути '/chat/'.*/\n                                       render={() => <ChatPageWithSuspense/>}/> {/*\"render\" это анонимная функция из\n                                       библиотеки \"react-router-dom\", которую вызовет \"Route\" при совпадении пути.\n                                       \"render\" позволяет передавать параметры.*/}\n\n                                <Route path='*' /*Создаем маршрут для пути '*'. Этот путь обозначает неверный URL, то\n                                есть любой отличающийся от любого пути в указанных нами маршрутах. Нужно для отображения\n                                \"404\" в таких случаях. Чтобы это работало нужно обвернуть все \"Route\" в тег <Switch>.*/\n                                       render={() => <div>404 NOT FOUND</div>}/> {/*\"render\" это анонимная функция из\n                                       библиотеки \"react-router-dom\", которую вызовет \"Route\" при совпадении пути.\n                                       \"render\" позволяет передавать параметры.*/}\n                            </Switch>\n                        </Content>\n                    </Layout>\n                </Content>\n\n                <Footer className='main-footer'>It's 2021 and there is a footer here</Footer> {/*Отрисовываем\n                футер при помощи элемента \"Footer\".*/}\n            </Layout>\n        );\n    }\n};\n\n\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => ({ /*Здесь указываются данные из \"state\", которые\nнеобходимо передать в компонент \"App\". Эта функция возвращает указанные данные в виде объекта. На входе\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\nданные с типом \"MapStateToPropsType\".*/\n    initialized: state.app.initialized /*Свойство, которое показывает инициализировано ли приложение.*/\n});\n\n\n/*Поскольку мы не можем обворачивать компонент \"App\" в файле \"index.js\", мы это делаем здесь. Создали внутри этого\nфайла контейнерный компонент \"AppContainer\", который обварачивает наш компонент \"App\" при помощи метода \"compose\".*/\nlet AppContainer = compose<ComponentType>( /*При помощи функции \"compose\" объеденяем HOCs \"withRouter\" и \"connect\",\nвозвращая итоговый компонент \"AppContainer\". Здесь мы уточнили тип только одним параметром, так как согласно файлу\nдекларации функции \"compose\" (раздел \"rest\"), нам нужно уточнить только такой компонент, свойства \"props\" которого не\nбудут переданы в этот компонент функциями, которые были переданы внутрь функции \"compose\", то есть функциями \"connect\" и\n\"withRouter\", то есть никакие свойства, так как мы не передаем извне ничего в компонент \"AppContainer\" снизу в\nкомпоненте \"AppMain\".*/\n    withRouter, /*При помощи метода \"withRouter\" передаем в этот контейнерный компонент данные из URL.*/\n    connect(mapStateToProps, {initializeApp}) /*При помощи метода \"connect\" создаем контейнерный\n    компонент, и тем самым передаем нужные данные BLL и DAL компоненту \"App\".*/\n)(App);\n\n\n/*Далее мы обварачиваем созданный выше контейнерный компонент \"AppContainer\" в \"Provider\" и в \"BrowserRouter\".\nПолучившийся в итоге компонент \"AppMain\" экспортируется, чтобы использоваться в файле \"index.js\".\nПри помощи этих двух компонентов \"AppContainer\" и \"AppMain\" мы избавились от обверток вокруг компонента \"App\"\nв файле \"index.js\". Указали, что компонент \"AppMain\" имеет тип \"React.FC\", без уточнения типов \"props\", так как ничего\nвнутрь не передаем.*/\nconst AppMain: React.FC = (props) => {\n    return (\n        <HashRouter> {/*Обворачиваем компонент \"AppContainer\" в тег \"BrowserRouter\", чтобы работали маршруты \"Route\"\n        в компоненте \"App\".*/}\n            <Provider store={store}> {/*Обворачиваем компонент \"AppContainer\" в тег \"Provider\", чтобы указать,\n            что этот компонент будет поставщиком данных BLL и DAL для дочерних компонентов, то есть для создания\n            контекста, из которого контейнерные компоненты смогут брать указанные данные. Также здесь указываем\n            наш \"store\".*/}\n                <AppContainer/>\n            </Provider>\n        </HashRouter>\n    )\n};\n\n\nexport default AppMain; /*Экспортируем компонент \"AppMain\" по default и будем его использовать в нашем проекте под\nименем \"AppMain\", экспорт необходим для импорта.*/","/*\nВ \"index.js\" не должно быть обверток вокруг \"App\", поэтому мы их перенесли в \"App.tsx\".\n\"index.js\" - это точка входя для сборщика \"WebPack\".\n\"index.html\" - это точка входа нашего приложения.\n\"index.css\" содержит общие стили для всего приложения.\n*/\n\nimport * as serviceWorker from './serviceWorker'; /*Было уже изначально. Это из темы \"Progressive Web\nApplication (PWA)\".*/\nimport React from 'react';\n/*\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\n\"WebPack\" уже встроен в \"ReactJS\".\n*/\nimport ReactDOM from 'react-dom'; /*Подключаем ReactDOM для метода \"render\", который отрисовывает\nDOM-дерево из ReactJS.*/\n\nimport './index.css'; /*Подключаем файл CSS.*/\n\nimport AppMain from './App'; /*Импортируем компонент \"AppMain\", который будет отрисовываться.*/\n\n\n/*В index.js мы указываем главный компонент \"AppMain\" (компонент \"App\" обвернутый разными обвертками), который\nбудет отрисовываться.*/\nReactDOM.render(\n    <React.StrictMode> {/*\"StrictMode\" это специальный строгий режим из \"ReactJS\", для избежания некоторых ошибок.*/}\n        <AppMain /> {/*Будет отрисовываться компонент \"AppMain\".*/}\n    </React.StrictMode>,\n    document.getElementById('root') /*JS будет отрисовывать приложение\n    в элементе \"div\" с \"ID\" \"root\" в \"index.html\".*/\n);\n\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","/*\r\nОдной из задач этого файла является настройка графического отображения срабатываний валидаторов.\r\n*/\r\n\r\nimport React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Field, WrappedFieldMetaProps, WrappedFieldProps} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\n\"WrappedFieldMetaProps\" - этот тип мы нашли в файле декларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и использовали его\r\nдля указания типа созданного нами компонента \"FormControl\". Поэтому импортировали этот тип сюда из библиотеки\r\n\"redux-form\".\r\n\"WrappedFieldProps\" - этот тип мы нашли в файле декларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и использовали его для\r\nуказания типа созданных нами компонентов \"Textarea\" и \"Input\". Поэтому импортировали этот тип сюда из библиотеки\r\n\"redux-form\".\r\n*/\r\nimport {FieldValidatorType} from '../../../utils/validators/validators'; /*Подключаем типы.*/\r\n\r\nimport styles from './FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*Типизируем \"props\" для компонента \"FormControl\". \"Props\" в этом компоненте должны обязательно содержать следующие\r\nполя с указанными типами. Все это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype FormControlPropsType = {\r\n    meta: WrappedFieldMetaProps /*Объект \"meta\" с мета-данными, который приходит к нам сверху из элемента \"Field\" из\r\n    библиотеки \"redux-form\", должен иметь тип \"WrappedFieldMetaProps\", который мы нашли в файле декларации \"Field\"\r\n    (\"Ctrl+click\" в \"WebStorm\") и импортировали сюда.*/\r\n};\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства \"name\" в \"createField\".\r\nЭто свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы строим свой \"generic\",\r\nчтобы можно было уточнить \"createField\". Нужные нам имена свойств уже должны быть перечислены в каком-то другом типе,\r\nчтобы мы при помощи \"keyof\" получали ключи из этого типа. Далее при помощи \"Extract\" (из библиотеки \"TypeScript\") берем\r\nиз этих ключей, только те, которые могут быть назначены как строка. И на основе этого создаем тип. Для больших деталей\r\nсмотри реализацию \"createField\" в \"FormsControls.tsx\".*/\r\nexport type GetValuesKeysType<T> = Extract<keyof T, string>;\r\n\r\n\r\n/*\r\n\"FormControl\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function FormControl(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"FormControl\" является компонентом, который будет содержать общую логику для графического отображения срабатывания\r\nвалидаторов независимо от типа элемента. Этот компонент получает на входе мета-данные, содержащие информацию о том, что\r\nкасались ли мы элемента и есть ли какая-либо ошибка (вроде это все берется из библиотеки \"redux-form\", текст ошибки\r\nвроде берется из того, что возвращают валидаторы при срабатывании и передают это в элемент \"Field\", собственно от\r\nэлемента \"Field\" этот компонент и будет получать эти данные при помощи замыкания), а также получает информацию\r\nо дочернем элементе.\r\n*/\r\nconst FormControl: React.FC<FormControlPropsType> =\r\n    ({meta: {touched, error}, children}) => {\r\n    const hasError = touched && error; /*Создали специальную константу для удобства, которая содержит условие, что\r\n    в мета-данных указано, что мы касались элемента (meta.touched) и что присутствует какая-то ошибка (meta.error).\r\n    Этот объект \"meta\" с мета-данными придет к нам сверху из элемента \"Field\". Указали при помощи \"React.FC<>\", что\r\n    \"props\" в этом функциональном компоненте имеют тип \"FormControlPropsType\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.formControl + \" \" + (hasError ? styles.error : \"\")}> {/*Этот элемент \"div\" и есть наш\r\n        корневой элемент. Этот компонент возврщает JSX, в котором будет элемент \"div\", внутри которого будет меняться\r\n        CSS в зависимости от значения константы \"hasError\".\r\n        То есть будет два варианта:\r\n        - \"styles.formControl styles.error\"\r\n        - \"styles.formControl \"*/}\r\n            <div> {/*Внутри отрисовываем еще один элемент \"div\". \"children\" это ключевое слово в \"ReactJS\". При помощи\r\n            этого слова этот элемент \"div\" будет отрисовывать потомков, которые будут указаны в месте вызова компонента\r\n            \"FormControl\".*/}\r\n                {children}\r\n            </div>\r\n            <div> {/*Также внутри отрисовываем еще один элемент \"div\". В этом элементе будет отображаться элемент \"span\"\r\n            с текстом ошибки, указанного в валидаторе.*/}\r\n                {hasError && <span>{error}</span>}\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n/*Далее создаем два компонента на экспорт, которые будут использоваться для отрисовки элементов \"textarea\" и \"input\" в\r\nдругих местах, где в таких элементах требуется валидация.*/\r\nexport const Textarea: React.FC<WrappedFieldProps> = (props) => { /*Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"WrappedFieldProps\". Этот тип мы нашли в файле\r\nдекларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и импортировали сюда.*/\r\n    const {input, meta, ...restProps} = props; /*Таким образом при помощи деструктуризации мы создаем константы:\r\n    - const input = props.input; (здесь внутри есть \"input.value\" - это то, что введено в поле, создается элементом\r\n    \"Field\" из библиотеки \"redux-form\")\r\n    - const meta = props.meta. (это мета-данные (тоже создаются элементом \"Field\" из библиотеки \"redux-form\"), например,\r\n    внутри них есть \"touched\" или \"error\", которые используются в компоненте \"FormControl\")\r\n    А \"...restProps\" это остальные \"props\" (в виде объекта), которые в дальнейшем можно передавать как \"...restProps\",\r\n    например, там будет \"placeholder\" для элементов \"textarea\" или \"input\".*/\r\n    return <FormControl {...props}><textarea {...input} {...restProps}/></FormControl> /*Этот компонент возвращает\r\n    компонент \"FormControl\", который получит \"props\" свыше и деструктуризирует их и передаст дочерним элементам. А в\r\n    качестве дочернего элемента этот компонент будет иметь элемент \"textarea\", внутри которого будет при помощи\r\n    деструктуризации передано:\r\n    - \"input.value\" - то, что введено в поле;\r\n    - остальные \"input.\" свойства;\r\n    - и объект с остальными \"props\".\r\n\r\n    То есть поскольку компонент \"Textarea\" будет использоваться в элементе \"Field\" из библиотеки \"redux-form\" (цепочка\r\n    будет такая: элемент \"Field\" - компонент \"Textarea\" - компонент \"FormControl\" - элемент \"textarea\"), то значит, что\r\n    компонент \"FormControl\" получит \"сверху\" \"props.meta.touched\" и \"props.meta.error\" при помощи\r\n    библиотеки \"redux-form\", которые ему необходимы для работы. А также компонент \"FormControl\" получит информацию о\r\n    своем дочернем элементе \"textarea\", так использует ключевое слово \"children\" из React, поэтому он сможет передать\r\n    этому дочернему элементу необходимые для него \"props\", например \"placeholder\" (то есть при помощи замыкание будет\r\n    доступ к \"props\" из элемента \"Field\", компонента \"Textarea\" и компонента \"FormControl\").*/\r\n};\r\n\r\n\r\nexport const Input: React.FC<WrappedFieldProps> = (props) => { /*Указали при помощи\r\n\"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"WrappedFieldProps\". Этот тип мы нашли в файле\r\nдекларации \"Field\" (\"Ctrl+click\" в \"WebStorm\") и импортировали сюда.*/\r\n    const {input, meta, ...restProps} = props; /*Таким образом при помощи деструктуризации мы создаем константы:\r\n    - const input = props.input; (здесь внутри есть \"input.value\" - это то, что введено в поле, создается элементом\r\n    \"Field\" из библиотеки \"redux-form\")\r\n    - const meta = props.meta. (это мета-данные (тоже создаются элементом \"Field\" из библиотеки \"redux-form\"), например,\r\n    внутри них есть \"touched\" или \"error\", которые используются в компоненте \"FormControl\")\r\n    А \"...restProps\" это остальные \"props\" (в виде объекта), которые в дальнейшем можно передавать как \"...restProps\",\r\n    например, там будет \"placeholder\" для элементов \"textarea\" или \"input\".*/\r\n    return <FormControl {...props}><input {...input} {...restProps}/></FormControl> /*Этот компонент возвращает\r\n    компонент \"FormControl\", который получит \"props\" свыше и деструктуризирует их и передаст дочерним элементам. А в\r\n    качестве дочернего элемента этот компонент будет иметь элемент \"input\", внутри которого будет при помощи\r\n    деструктуризации передано:\r\n    - \"input.value\" - то, что введено в поле;\r\n    - остальные \"input.\" свойства;\r\n    - и объект с остальными \"props\".\r\n\r\n    То есть поскольку компонент \"Input\" будет использоваться в элементе \"Field\" из библиотеки \"redux-form\" (цепочка\r\n    будет такая: элемент \"Field\" - компонент \"Input\" - компонент \"FormControl\" - элемент \"input\"), то значит, что\r\n    компонент \"FormControl\" получит \"сверху\" \"props.meta.touched\" и \"props.meta.error\" при помощи\r\n    библиотеки \"redux-form\", которые ему необходимы для работы. А также компонент \"FormControl\" получит информацию о\r\n    своем дочернем элементе \"input\", так использует ключевое слово \"children\" из React, поэтому он сможет передать этому\r\n    дочернему элементу необходимые для него \"props\", например \"placeholder\" (то есть при помощи замыкание будет доступ\r\n    к \"props\" из элемента \"Field\", компонента \"Input\" и компонента \"FormControl\").*/\r\n};\r\n\r\n\r\n/*Создали функцию \"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания\r\nформы в \"Login.tsx\".*/\r\nexport function createField<FormKeysType extends string>( /*Указали, что \"createField\" теперь обобщенный, то есть\r\n\"generic\". Если бы мы описали эту функцию стрелочным синтаксисом, то у нас так не получилось бы ее сделать \"generic\".\r\nТо есть теперь мы можем уточнять эту функцию при ее использовании, а точнее мы будем уточнять свойство \"name\", поэтому\r\nуказываем придуманный нами тип \"FormKeysType\" здесь и в самом \"name\" дальше. При помощи \"extends string\" указали, что\r\nэтот тип экстендится от типа строки (то есть должен совпадать со строкой), хотя и может быть более сложным. Последнее\r\nнам нужно, чтобы не было ошибки ниже в \"name={name}\", так как там по сути ожидается строка.*/\r\n                            placeholder: string | undefined, /*Текст \"placeholder\". Должен быть строкой или \"undefined\"\r\n                            (то есть отсуствовать вовсе, а не быть пустым).*/\r\n                            name: FormKeysType, /*Имя данных, которые будут вводится в это поле. Имеют тип\r\n                            \"FormKeysType\", то есть здесь указываются какие-то ключи, но какие именно мы должны\r\n                            указывать сами в каждой форме. Нам это нужно для того, чтобы проводить типизацию в целях\r\n                            избежания ошибки при указании свойства \"name\" в \"createField\" в компонентах. Это свойство\r\n                            важно для формирования имен свойств \"formData\", то есть данных формы.*/\r\n                            component: React.FC<WrappedFieldProps>, /*Какой компонент отрисовываем (например,\r\n                            \"Textarea\"). Указали при помощи \"React.FC<>\", что \"props\" в этих функциональных компонентах\r\n                            имеют тип \"WrappedFieldProps\". Этот тип мы нашли в файле декларации \"Field\" (\"Ctrl+click\"\r\n                            в \"WebStorm\") и импортировали сюда.*/\r\n                            validators: Array<FieldValidatorType>, /*Валидаторы. Должны быть в виде массива элементов с\r\n                            типом \"FieldValidatorType\", который мы создали и импортировали сюда.*/\r\n                            props = {}, /*Любые другие \"props\".*/\r\n                            text = '' /*Текст, который необходим некоторым элементам (например, \"Remember me?\"\r\n                            для чек-бокса \"Запомнить меня?\"). Должно быть по умолчанию строкой.*/\r\n) {\r\n    return (\r\n        <div> {/*В итоге функция создает отдельный элемент \"div\", в котором внутри есть элемент \"Field\" из библиотеки\r\n        \"redux-form\". Что из себя будет представлять этот элемент \"Field\" будет зависеть от параметров выше.*/}\r\n            <Field placeholder={placeholder}\r\n                   name={name}\r\n                   component={component}\r\n                   validate={validators}\r\n                   {...props}\r\n            /> {text}\r\n        </div>\r\n    )\r\n};","export default __webpack_public_path__ + \"static/media/preloader.5f3f0496.gif\";","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Preloader.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport preloader from '../../../assets/images/preloader.gif'; /*Импортируем из ассетов анимированное изображение,\r\nизображающее загрузку.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {};\r\n\r\n\r\n/*\r\n\"Preloader\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Preloader(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Preloader\" является компонентом-заглушкой, который используется, чтобы показать анимацию загрузки в других компонентах,\r\nкогда идет какой-то процесс в них (например, AJAX-запрос).\r\nЭтот компонент подключается в компонентах \"App\", \"ProfileInfo\", \"UsersContainer\", и в HOC \"WithSuspense\".\r\n*/\r\nexport const Preloader: React.FC<PropsType> = (props) => { /*Указали при помощи \"React.FC<>\",\r\nчто \"props\" в этом функциональном компоненте имеют тип \"PropsType\". Также указали, что экспортируем этот компонент.*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.preloader}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <img alt='' src={preloader}/> {/*Отрисовываем элемент \"img\" с изображением анимации загрузки.*/}\r\n        </div>\r\n    )\r\n};","/*\r\nЭтот файл содержит валидаторы для полей и форм. Валидацию можно делать\r\nкак для отдельного поля, так и для всей формы.\r\nМета-данные это дополнительные данные о данных.\r\nБиблиотека redux-form позволяет нам использовать валидаторы, встроенные в нее.\r\nВ нашем проекте добавленя валидация на страница Профиля, Диалогов и Логина.\r\nПри срабатывании указанных здесь валидаторов, \"submit\" формы не сработает.\r\nТо, что возвращают валидаторы попадает в свойство \"error\", которое создается библиотекой \"redux-form\".\r\n*/\r\n\r\n/*Создаем тип для валидаторов.*/\r\nexport type FieldValidatorType = (value: string) => string | undefined; /*Валидатор должен быть функцией, которая\r\nпринимает строковой параметр и возвращает строковой параметр или \"undefined\", то есть ничего.*/\r\n\r\n\r\n/*Это валидатор, который проверяет обязательное заполнение поля.*/\r\nexport const required: FieldValidatorType = (value) => { /*При вызове этой функции в нее будет приходить то,\r\nчто находится в поле. Указали, что этот валидатор имеет тип \"FieldValidatorType\".*/\r\n    if (value) return undefined; /*Здесь проверяется имеется ли какое-либо введенное значение в поле, если есть,\r\n    то ничего не происходит.*/\r\n    return \"Field is required\"; /*Если никакого значение не указано в поле, то будет выводится соотвествующее\r\n    информационное сообщение.*/\r\n};\r\n\r\n\r\n/*Это валидатор, который проверяет не превышает ли введенный текст в поле максимального количества символов для этого\r\nполя.*/\r\nexport const maxLengthCreator = (maxLength: number): FieldValidatorType => (value) => { /*При вызове этой функции\r\nв нее будет приходить значение, которое обозначает максимальное количество символов для какого-то поля, и то, что\r\nвведено в поле. То здесь одна функция принимает числовой параметр и возвращает другую функцию, то есть наш валидатор,\r\nкоторая имеет тип \"FieldValidatorType\".*/\r\n    if (value.length > maxLength) return `max length is ${maxLength} symbols`; /*Если длина текста в поле больше\r\n    значения, которое обозначает максимальное количество символов для этого поля, то будет выводится соотвествующее\r\n    информационное сообщение.*/\r\n    return undefined; /*Если же длина текста в поле меньше и равна значению, которое обозначает максимальное количество\r\n    символов для этого поля, то ничего не происходит.*/\r\n};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"formControl\":\"FormsControls_formControl__3JtTI\",\"error\":\"FormsControls_error__TpkJB\",\"formSummaryError\":\"FormsControls_formSummaryError__3weeR\"};"],"sourceRoot":""}