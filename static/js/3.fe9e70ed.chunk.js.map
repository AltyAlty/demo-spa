{"version":3,"sources":["hoc/WithAuthRedirect.js","components/Profile/ProfileInfo/ProfileInfo.module.css","components/Profile/Profile.module.css","assets/images/profilelogo.jpg","components/Profile/MyPosts/MyPosts.module.css","components/Profile/MyPosts/Post/Post.module.css","components/Profile/ProfileInfo/ProfileStatusWithHooks.jsx","components/Profile/ProfileInfo/ProfileStatus.tsx","components/Profile/ProfileInfo/ProfileDataForm.jsx","components/Profile/ProfileInfo/ProfileInfo.jsx","components/Profile/MyPosts/Post/Post.jsx","components/Profile/MyPosts/MyPosts.jsx","components/Profile/MyPosts/MyPostsContainer.jsx","components/Profile/Profile.jsx","components/Profile/ProfileContainer.jsx"],"names":["mapStateToPropsForRedirect","state","isAuth","auth","withAuthRedirect","Component","RedirectComponent","this","props","to","React","connect","module","exports","ProfileStatusWithHooks","useState","editMode","setEditMode","status","setStatus","useEffect","isOwner","onDoubleClick","onChange","event","currentTarget","value","onFocus","e","target","select","autoFocus","onBlur","updateUserStatus","ProfileDataFormReduxForm","reduxForm","form","handleSubmit","profile","error","onSubmit","className","styles","formSummaryError","createField","Input","Object","keys","contacts","map","key","style","contact","type","Textarea","ProfileData","activateEditMode","onClick","fullName","aboutMe","contactTitle","contactValue","lookingForAJob","lookingForAJobDescription","Contact","ProfileInfo","saveUserPhoto","saveProfile","Preloader","profileImage","src","profileLogoSource","alt","descriptionBlock","photos","large","userPhoto","files","length","initialValues","formData","then","Post","item","avatar","message","likes","maxLength10","maxLengthCreator","AddPostReduxForm","Field","component","name","placeholder","validate","required","MyPosts","memo","console","log","postsElements","postsData","p","id","likesCount","postsBlock","values","addPost","newPostText","posts","profilePage","dispatch","addPostActionCreator","Profile","MyPostsContainer","ProfileContainer","userID","match","params","authUserID","history","push","getUserProfile","getUserStatus","refreshProfile","prevProps","prevState","snapshot","compose","withRouter"],"mappings":"kOAsDMA,EAA6B,SAACC,GAAD,MAAY,CAE3CC,OAAQD,EAAME,KAAKD,SAGVE,EAAmB,SAACC,GAAc,IAErCC,EAFqC,uKAKnC,OAAKC,KAAKC,MAAMN,OAIT,kBAACG,EAAcE,KAAKC,OAJI,kBAAC,IAAD,CAAUC,GAAI,gBALV,GAEXC,IAAML,WAiBtC,OALqCM,YAAQX,EAARW,CAAoCL,K,oBCxE7EM,EAAOC,QAAU,CAAC,iBAAmB,sCAAsC,aAAe,kCAAkC,UAAY,+BAA+B,QAAU,+B,oBCAjLD,EAAOC,QAAU,CAAC,QAAU,2B,oBCD5BD,EAAOC,QAAU,IAA0B,yC,oBCC3CD,EAAOC,QAAU,CAAC,WAAa,4BAA4B,MAAQ,yB,oBCAnED,EAAOC,QAAU,CAAC,KAAO,qB,0MCmJVC,GChGaJ,IAAML,UDJH,SAACG,GAAW,IAAD,EACRO,oBAAS,GADD,mBACjCC,EADiC,KACvBC,EADuB,OAMZF,mBAASP,EAAMU,QANH,mBAMjCA,EANiC,KAMzBC,EANyB,KAgBtCC,qBAAU,WAQND,EAAUX,EAAMU,UAEhB,CAACV,EAAMU,SA8BX,OACI,kCACMF,GAUF,6BACKR,EAAMa,QACD,6BAAK,qCAAL,KAAoB,0BAAMC,cAzCnB,WACrBL,GAAY,KAwC8DT,EAAMU,QAAU,sBAC5E,8BAAOV,EAAMU,QAAU,KAKhCF,GAYD,6BACI,2BAAOO,SAjDQ,SAACC,GAGxBL,EAAUK,EAAMC,cAAcC,QA+CfC,QA5CC,SAACC,GAEjBA,EAAEC,OAAOC,UA2CMC,WAAW,EACXC,OA3DQ,WAGvBf,GAAY,GACZT,EAAMyB,iBAAiBf,IAwDRQ,MAAOR,Q,kCEyCfgB,EALkBC,YAAU,CACvCC,KAAM,eADuBD,EAlFT,SAAC,GAOlB,IALsBE,EAKvB,EALuBA,aACAC,EAIvB,EAJuBA,QACAC,EAGvB,EAHuBA,MASzB,OACI,0BAAMC,SAAUH,GAAhB,IAEI,iCAEI,yCAGHE,GAAS,yBAAKE,UAAWC,IAAOC,kBAAmBJ,GAPxD,IAWI,iCACI,2CADJ,IAEKK,YAAY,YAAa,WAAYC,IAAO,KAIjD,iCACI,0CADJ,IAEKD,YAAY,WAAY,UAAWC,IAAO,KAK/C,iCAEI,0CAFJ,KAEyBC,OAAOC,KAAKT,EAAQU,UAAUC,KAAI,SAAAC,GAKvD,OACI,yBAAKA,IAAKA,EAAKT,UAAWU,IAAMC,SAAhC,IAGI,2BAAIF,EAAJ,KAAWN,YAAYM,EAAK,YAAcA,EAAKL,IAAO,UAalE,iCACI,uDACCD,YAAY,GAAI,iBAAkBC,IAAO,GAAI,CAACQ,KAAM,cAKzD,iCACI,yCACCT,YAAY,aAAc,4BAA6BU,IAAU,SCuB5EC,EAAc,SAAC,GAA0C,IAAzCjB,EAAwC,EAAxCA,QAASjB,EAA+B,EAA/BA,QAASmC,EAAsB,EAAtBA,iBAMpC,OACI,iCACKnC,GAAW,iCAER,4BAAQoC,QAASD,GAAjB,QAFQ,KAOZ,6BAAK,2CAAL,KAA2BlB,EAAQoB,UARvC,IAWI,6BAAK,0CAAL,KAA0BpB,EAAQqB,SAXtC,IAcI,iCAEI,0CAFJ,KAEyBb,OAAOC,KAAKT,EAAQU,UAAUC,KAAI,SAAAC,GAIvD,OAAO,kBAAC,EAAD,CAASA,IAAKA,EAELU,aAAcV,EACdW,aAAcvB,EAAQU,SAASE,SAMnD,6BAAK,uDAAL,IAAsCZ,EAAQwB,eAAiB,qCAAmB,qCAKjFxB,EAAQwB,gBAAkB,6BAAK,yCAAL,IAAwBxB,EAAQyB,2BAlC/D,MA8DFC,EAAU,SAAC,GAAkC,IAAjCJ,EAAgC,EAAhCA,aAAcC,EAAkB,EAAlBA,aAC5B,OAAO,yBAAKpB,UAAWC,IAAOU,SAAS,2BAAIQ,GAApC,KAAwDC,IAMpDI,EAxMK,SAAC,GAWd,IATkB5C,EASnB,EATmBA,QAEAiB,EAOnB,EAPmBA,QACApB,EAMnB,EANmBA,OACAe,EAKnB,EALmBA,iBACAiC,EAInB,EAJmBA,cAEAC,EAEnB,EAFmBA,YAEnB,EAC4BpD,oBAAS,GADrC,mBACGC,EADH,KACaC,EADb,KAYF,IAAKqB,EACD,OAAO,kBAAC8B,EAAA,EAAD,MA8BX,OACI,iCACI,yBAAK3B,UAAWC,IAAO2B,cAAvB,IAEI,yBAAKC,IAAKC,IAAmBC,IAAI,KAFrC,KAMA,yBAAK/B,UAAWC,IAAO+B,kBAAvB,IAEI,yBAAKH,IAAKhC,EAAQoC,OAAOC,OAASC,IAAWnC,UAAWC,IAAOkC,UAAWJ,IAAI,KAFlF,IAMKnD,GAAW,2BAAOgC,KAAM,OAAQ9B,SAzCjB,SAACK,GAIrBA,EAAEC,OAAOgD,MAAMC,QACfZ,EAActC,EAAEC,OAAOgD,MAAM,OA8B7B,IAaI,kBAAC,EAAD,CAAwB3D,OAAQA,EACjBe,iBAAkBA,EAElBZ,QAASA,IAIvBL,EAaK,kBAAC,EAAD,CAA0B+D,cAAezC,EAASE,SA3DnD,SAACwC,GAMdb,EAAYa,GAAUC,MAClB,WACIhE,GAAY,OAmDgEqB,QAASA,IAC/E,kBAAC,EAAD,CAAaA,QAASA,EAASjB,QAASA,EAASmC,iBA9E1C,WAErBvC,GAAY,S,oDClCLiE,EAtBF,SAAC1E,GAMV,OACI,yBAAKiC,UAAWC,IAAOyC,MAAvB,IAGI,yBAAKb,IAAK9D,EAAM4E,OAAQZ,IAAI,KAHhC,IAMKhE,EAAM6E,QANX,IASI,6BAAK,wCAAc7E,EAAM8E,QAT7B,MCkCFC,EAAcC,YAAiB,IAuD/BC,EAAmBtD,YAAU,CAC/BC,KAAM,sBADeD,EA9BL,SAAC3B,GAMjB,OACI,0BAAMgC,SAAUhC,EAAM6B,cAAtB,IAEI,iCAEI,kBAACqD,EAAA,EAAD,CAAOC,UAAWrC,IAEXsC,KAAM,cACNC,YAAa,qBACbC,SAAU,CAACC,IAAUR,KANhC,KAUA,iCAEI,iDAgGDS,EA5DCtF,IAAMuF,MAAK,SAAAzF,GAIvB0F,QAAQC,IAAI,UAsBZ,IAAIC,EAAgB5F,EAAM6F,UAAUpD,KAAI,SAAAqD,GAAC,OAAI,kBAAC,EAAD,CAAMC,GAAID,EAAEC,GACNlB,QAASiB,EAAEjB,QACXC,MAAOgB,EAAEE,WACTpB,OAAQkB,EAAElB,OACVlC,IAAKoD,EAAEC,QAa1D,OACI,yBAAK9D,UAAWC,IAAO+D,YAAvB,IAEI,wCAFJ,IAGI,kBAAChB,EAAD,CAAkBjD,SAfT,SAACkE,GAEdlG,EAAMmG,QAAQD,EAAOE,gBAUrB,IAWI,yBAAKnE,UAAWC,IAAOmE,OAAQT,GAXnC,Q,QCzGOzF,eAvBS,SAACV,GAErB,MAAO,CACHoG,UAAWpG,EAAM6G,YAAYT,cAIV,SAACU,GASxB,MAAO,CACHJ,QAAS,SAACC,GACNG,EAASC,YAAqBJ,QAK3BjG,CAA6CqF,GC5B7CiB,EA3BC,SAACzG,GAMb,OACI,yBAAKiC,UAAWC,IAAOJ,SAAvB,IAEI,kBAAC,EAAD,CAAaA,QAAS9B,EAAM8B,QACfpB,OAAQV,EAAMU,OACde,iBAAkBzB,EAAMyB,iBAExBZ,QAASb,EAAMa,QAEf6C,cAAe1D,EAAM0D,cAErBC,YAAa3D,EAAM2D,cAKhC,kBAAC+C,EAAD,QCiDNC,G,sLAGE,IAAIC,EAAS7G,KAAKC,MAAM6G,MAAMC,OAAOF,OAIhCA,IACDA,EAAS7G,KAAKC,MAAM+G,aAEhBhH,KAAKC,MAAMgH,QAAQC,KAAK,WAKhClH,KAAKC,MAAMkH,eAAeN,GAE1B7G,KAAKC,MAAMmH,cAAcP,K,0CAMzB7G,KAAKqH,mB,yCAGUC,EAAWC,EAAWC,GAEjCxH,KAAKC,MAAM6G,MAAMC,OAAOF,SAAWS,EAAUR,MAAMC,OAAOF,QAK1D7G,KAAKqH,mB,+BAUT,OACI,kBAAC,EAAD,iBAAarH,KAAKC,MAAlB,CAGSa,SAAUd,KAAKC,MAAM6G,MAAMC,OAAOF,c,GA/CxB1G,IAAML,YAqEtB2H,sBAEXrH,aAXoB,SAACV,GAAD,MAAY,CAEhCqC,QAASrC,EAAM6G,YAAYxE,QAE3BpB,OAAQjB,EAAM6G,YAAY5F,OAE1BqG,WAAYtH,EAAME,KAAKoG,MAKE,CAGrBmB,mBACAC,kBACA1F,qBACAiC,kBAEAC,kBAEJ8D,IAZWD,CAcbb","file":"static/js/3.fe9e70ed.chunk.js","sourcesContent":["/*\r\nЭто специальной созданный нами HOC для добавления редиректа в наш проект.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\n*/\r\n\r\nimport React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {Redirect} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\n\"Redirect\" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется\r\nатрибут \"to\".\r\nМаршрут для пути редиректа уже должен быть создан.\r\n*/\r\n\r\n\r\nconst mapStateToPropsForRedirect = (state) => ({ /*Здесь мы таким образом создали \"props\" необходимые для работы\r\nредиректа.*/\r\n    isAuth: state.auth.isAuth /*Свойство, которое указывает залогинен ли пользователь.*/\r\n});\r\n\r\nexport const withAuthRedirect = (Component) => { /*Это и есть наш HOC, который в качестве параметра принимает\r\nкакой-либо компонент.*/\r\n    class RedirectComponent extends React.Component { /*После получения компонента в качестве параметра, создается\r\n    другой классовый компонент \"RedirectComponent\".*/\r\n        render() { /*Свойственный для классовых компонентов метод \"render\".*/\r\n            if (!this.props.isAuth) return <Redirect to={'/login/'}/> /*Внутри этого классового компонента\r\n            \"RedirectComponent\" добавляем в компонент из параметров следующую логику: если пользователь не залогинен,\r\n            то происходит редирект по пути \"/login/\", где находится форма для логинизации.*/\r\n\r\n            return <Component {...this.props}/> /*А затем этот классовый компонент \"RedirectComponent\" возвращает\r\n            компонент из параметров, снабдив его \"props\", используя деструктуризацию.*/\r\n        }\r\n    }\r\n\r\n    let ConnectedAuthRedirectComponent = connect(mapStateToPropsForRedirect)(RedirectComponent); /*Далее в свою очередь\r\n    классовый компонент \"RedirectComponent\" обворачивается при помощи метода \"connect\", чтобы получить необходимые\r\n    \"props\" для проверки залогинен ли пользователь или нет. Метод \"connect\" вернет новый компонент\r\n    \"ConnectedAuthRedirectComponent\".*/\r\n\r\n    return ConnectedAuthRedirectComponent; /*И в конце концов HOC \"withAuthRedirect\" возвращает итоговый\r\n    компонент \"ConnectedAuthRedirectComponent\".*/\r\n}\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"descriptionBlock\":\"ProfileInfo_descriptionBlock__3IFpJ\",\"profileImage\":\"ProfileInfo_profileImage__1regV\",\"userPhoto\":\"ProfileInfo_userPhoto__2cgvG\",\"contact\":\"ProfileInfo_contact__1pgdA\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"profile\":\"Profile_profile__F_wTA\"};","module.exports = __webpack_public_path__ + \"static/media/profilelogo.ac5b38e4.jpg\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"postsBlock\":\"MyPosts_postsBlock__3XkAy\",\"posts\":\"MyPosts_posts__16GbP\"};","// extracted by mini-css-extract-plugin\nmodule.exports = {\"item\":\"Post_item__1JDJo\"};","import React, {useState, useEffect} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\nПодключаем хук \"useEffect\", который принимает функцию первым параметром и выполняет ее, когда произойдет\r\nотрисовка компонента, то есть после каждого вызова \"render\". Вторым параметром этот хук принимает зависимости -\r\nзависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то\r\nэтот хук сработает только один раз. Этот хук используется для side effects.\r\n*/\r\n\r\n/*\r\n\"ProfileStatusWithHooks\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileStatusWithHooks(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"ProfileInfo\".\r\nКомпонент \"ProfileStatusWithHooks\" предоставляет реализацию статуса пользователя на странице пользователя.\r\nСтатус пользователя представляет из себя поле статуса как в ВК, на который можно нажать и активировать поле для ввода\r\nстатуса, а если убрать фокус с этого поля, то будет просто текст.\r\n*/\r\nconst ProfileStatusWithHooks = (props) => {\r\n    let [editMode, setEditMode] = useState(false); /*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет означать\r\n    включен или выключен режим редактирования статуса (изначально \"false\"). Вторая переменная будет хранить функцию\r\n    из хука \"useState\", которая будет изменять первый элемент (то есть включать или выключать режим редактирования\r\n    статуса).*/\r\n    let [status, setStatus] = useState(props.status);/*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет хранить\r\n    значение статуса (изначально берется из \"props\"). Вторая переменная будет хранить функцию из хука \"useState\",\r\n    которая будет изменять первый элемент (то редактировать статус).*/\r\n\r\n    /*Поскольку \"useState\" содержит массив с двумя элементами, то аналог мог бы быть такой:\r\n    let stateWithSetState = useState(false);\r\n    let editMode = stateWithSetState[0];\r\n    let setEditMode = stateWithSetState[1];*/\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы избежать бага, когда не успевал загружаться статус\r\n    с сервера во время первого редактирования после загрузки компонента. Когда после загрузки страницы мы входили в\r\n    режим редактирования статуса, то поле было пустым, так как локальный \"status\", созданный при помощи хука \"useState\",\r\n    был пустым, поскольку иногда компонент загружался раньше, чем получался статус с сервера. То есть отображалось\r\n    пустое поле, так как изначально это пустое поле указано в статусе в нашем BLL. И это пустое поле подхватывалось\r\n    нашим \"status\" раньше данных о статусе, полученных из запроса на сервер. Поэтому сейчас мы отслеживаем изменения\r\n    статуса в глобаольном \"state\" и при каждом таком изменении вызываем функцию \"setStatus\", то есть теперь получение\r\n    запоздавших данных о статусе с сервера будет триггерить изменение локального \"status\".*/\r\n        setStatus(props.status); /*Первый параметр это функция для редактирования статуса при помощи хука \"useState\".*/\r\n    },\r\n        [props.status]); /*Второй параметр это значение статуса из глобального \"state\". Если это значение будет\r\n        меняться, то будет срабатывать каждый раз функция из первого параметра.*/\r\n\r\n    const activateEditMode = () => { /*Создали функцию, которая при вызове активирует режим редактирования статуса.*/\r\n        setEditMode(true);\r\n    };\r\n\r\n    const deactivateEditMode = () => { /*Создали функцию, которая при вызове деактивирует режим редактирования статуса\r\n    и обновляет значение статуса в глобальном \"state\" при помощи TC \"updateUserStatus\" для изменения\r\n    статуса пользователя на странице профиля.*/\r\n        setEditMode(false);\r\n        props.updateUserStatus(status);\r\n    };\r\n\r\n    const onUserStatusChange = (event) => { /*Создали специальный метод \"onUserStatusChange\", который\r\n    будет вызываться при изменении поля \"input\", брать текущее значение содержимого этого поля и сохранять его\r\n    в локальный \"state\" при помощи хука \"useState\".*/\r\n        setStatus(event.currentTarget.value)\r\n    };\r\n\r\n    const handleFocus = (e) => { /*Создали специальный метод \"handleFocus\" для автоматического выделения текста\r\n    в поле статуса пользователя.*/\r\n        e.target.select();\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {!editMode && /*Если режим редактирования статуса пользователя отключен и мы являемся владельцем страницы,\r\n            то отрисуется элемент \"div\", внутри которого будет элемент \"span\", содержащий обработчик события двойного\r\n            нажатия по элементу \"onDoubleClick\". При срабатывании этого события активируется метод \"activateEditMode\"\r\n            через callback, чтобы активировать режим редактирования статуса пользователя. Внутри элемента \"span\"\r\n            будет отображаться текущее значение статуса пользователя из \"props\", а при его отсуствии будет надпись\r\n            \"Enter your status\". Если мы же не являемся владельцем профиля, то мы не сможем перейти в режим\r\n            редактирования, только увидеть сам статус. Здесь есть небольшая проблема - после ввода нового статуса\r\n            какое-то время будет отображен старый статус, пока не завершится запрос на сервер на изменение\r\n            этого статуса. Одним из вариантов решений этой проблемы может быть добавление заглушки \"Preloader\" на время\r\n            пока идет запрос.*/\r\n            <div>\r\n                {props.isOwner\r\n                    ? <div><b>Status</b>: <span onDoubleClick={activateEditMode}>{props.status || 'Enter your status'}</span></div>\r\n                    : <span>{props.status || ''}</span>\r\n                }\r\n            </div>\r\n            }\r\n\r\n            {editMode && /*Если режим редактирования статуса пользователя включен, то\r\n            отрисуется элемент \"div\", внутри которого будет элемент \"input\", содержащий обработчик события потери фокуса\r\n            с элемента \"onBlur\". При срабатывании этого события активируется метод \"deactivateEditMode\"\r\n            через callback, чтобы деактивировать режим редактирования статуса пользователя и сохранить новый статус\r\n            в глобальном \"state\". Также у элемента \"input\" указан атрибут \"autoFocus\" для автоматического фокуса\r\n            на элементе. Внутри элемента \"input\" будет отображаться текущее значение статуса пользователя при помощи\r\n            атрибута \"value\" из локального \"state\" при помощи хука \"useState\". Также внутри элемента \"input\" содержится\r\n            обработчик события появления фокуса на элементе \"onFocus\", при срабатывании которого активируется\r\n            метод \"handleFocus\" через callback, чтобы автоматически выделить текст статуса пользователя. Еще внутри\r\n            элемента \"input\" содержится обработчик события изменения поля \"input\" \"onChange\", при срабатывании которого\r\n            активируется метод \"onUserStatusChange\" через callback, чтобы брать текущее значение содержимого\r\n            этого поля и сохранять его в локальный \"state\" при помощи хука \"useState\".*/\r\n            <div>\r\n                <input onChange={onUserStatusChange}\r\n                       onFocus={handleFocus}\r\n                       autoFocus={true}\r\n                       onBlur={deactivateEditMode}\r\n                       value={status}/>\r\n            </div>\r\n            }\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default ProfileStatusWithHooks; /*Экспортируем компонент \"ProfileStatusWithHooks\" по default, экспорт необходим\r\nдля импорта.*/","import React, {ChangeEvent} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"props\" в этом компоненте должен обязательно содержать следующие поля с указанными типами.*/\r\ntype PropsType = {\r\n    status: string /*Информация о статусе пользователя, полученная с сервера, должна быть строкой.*/\r\n    updateUserStatus: (newStatus: string) => void\r\n    isOwner: boolean /*Свойство, которое показывает является ли залогиненный пользователь владельцем профиля, который в\r\n    данный момент отображается на странице профиля, должно быть булева типа.*/\r\n};\r\n\r\n/*Создаем тип для локального \"state\". Локальный \"state\" в этом компоненте должен обязательно содержать следующие поля\r\nс указанными типами.*/\r\ntype StateType = {\r\n    editMode: boolean /*Значение, которое определяет вкючен ли режим редактирования статуса пользователя или нет,\r\n    должно быть булева типа.*/\r\n    status: string /*Информация о статусе пользователя, установленная в локальном \"state\", должна быть строкой.*/\r\n};\r\n\r\n/*\r\n\"ProfileStatus\" это классовый компонент.\r\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\r\nконцепцию ООП.\r\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\r\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\r\nвзаимодействует.\r\nНапример, у него можно постоянно запрашивать JSX.\r\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\r\nКомпонент это функция, которая возвращает JSX.\r\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\r\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\r\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"ProfileInfo\".\r\nКомпонент \"ProfileStatus\" предоставляет реализацию статуса пользователя на странице пользователя.\r\nСтатус пользователя представляет из себя поле статуса как в ВК, на который можно нажать и активировать поле для ввода\r\nстатуса, а если убрать фокус с этого поля, то будет просто текст.\r\n*/\r\nclass ProfileStatus extends React.Component<PropsType, StateType> { /*Указали, что \"props\" в этом классовом\r\nкомпоненте имеют тип \"PropsType\", а \"state\" имеет тип \"StateType\".*/\r\n    state = { /*Локальный \"state\" это дополнение к глобальному \"state\". Такой \"state\" может использоваться для данных,\r\n    которые необходимы для работы приложения, но не относятся к бизнес-данным (например, временные данные или\r\n    UI-данные). Любой компонент может определить свой локальный \"state\". Работать такой компонент будет по знакомому\r\n    способу: если компонент что-то изменить в локальном \"state\", то он перерисуется. Для этого нужно использовать\r\n    классовый компонент, поскольку \"React\" при работе с таким компонентом создает объект, в котором можно хранить\r\n    локальный \"state\".*/\r\n        editMode: false, /*Значение, которое определяет вкючен ли режим редактирования статуса пользователя или нет.*/\r\n        status: this.props.status /*Значение, которое будет хранить информацию о статусе пользователя, полученную\r\n        с сервера. Берется из \"props\".*/\r\n    };\r\n\r\n    activateEditMode = () => { /*Создаем метод, при вызове которого будет активироваться режим редактирования статуса\r\n    пользователя. Этот метод будет использоваться в обработчике событий как callback.*/\r\n        this.setState({ /*При помощи метода \"setState()\" из \"React\" работаем с локальным \"state\". Вместо этого\r\n        метода можно было использовать метод \"forceUpdate()\" для того, чтобы заставить \"React\" перерисовать компонент,\r\n        но это нежелательно. Метод \"setState()\" асинхронный. В метод \"setState\" нужно передать объект, свойства\r\n        которого перезапишут свойства в локальном \"state\", он не удалит все свойства локального \"state\", а только\r\n        заменит указанные. Ранее нужно было использовать классический способ создания метода:\r\n        \"activateEditMode () {...};\", так как при использовании стрелочной функции \"debugger\" не видел контекста \"this\",\r\n        а также приходилось использовать метод \"bind()\" для привязки этого контекста, но на данный момент эта проблема\r\n        решена в \"ReactJS\".*/\r\n            editMode: true, /*Указываем, что включили режим редактирования статуса пользователя.*/\r\n            status: this.props.status /*Получаем информацию о статусе пользователя из \"props\".*/\r\n        });\r\n    };\r\n\r\n    deactivateEditMode = () => { /*Создаем метод, при вызове которого будет деактивироваться режим редактирования\r\n    статуса пользователя. Этот метод будет использоваться в обработчике событий как callback.*/\r\n        this.setState({ /*При помощи метода \"setState()\" из \"React\" работаем с локальным \"state\". Вместо этого\r\n        метода можно было использовать метод \"forceUpdate()\" для того, чтобы заставить \"React\" перерисовать компонент,\r\n        но это нежелательно. Метод \"setState()\" асинхронный. В метод \"setState\" нужно передать объект, свойства\r\n        которого перезапишут свойства в локальном \"state\", он не удалит все свойства локального \"state\", а только\r\n        заменит указанные. Ранее нужно было использовать классический способ создания метода:\r\n        \"deactivateEditMode () {...};\", так как при использовании стрелочной функции \"debugger\" не видел\r\n        контекста \"this\", а также приходилось использовать метод \"bind()\" для привязки этого контекста, но на\r\n        данный момент эта проблема решена в \"ReactJS\".*/\r\n            editMode: false /*Указываем, что выключили режим редактирования статуса пользователя.*/\r\n        });\r\n        this.props.updateUserStatus(this.state.status); /*При помощи TC \"updateUserStatus\" для изменения статуса\r\n        пользователя на странице профиля, полученного из \"props\", обновляем значение статуса пользователя\r\n        в глобальном \"state\" (но не в локальный \"state\", для этого мы создали метод \"onUserStatusChange\" ниже).*/\r\n    };\r\n\r\n    onUserStatusChange = (event: ChangeEvent<HTMLInputElement>) => { /*Создали специальный метод \"onUserStatusChange\",\r\n    который будет вызываться при изменении поля \"input\", брать текущее значение содержимого этого поля и сохранять\r\n    его в локальный \"state\". Для события \"event\" указали тип \"ChangeEvent<HTMLInputElement>\".*/\r\n        this.setState({\r\n            status: event.currentTarget.value\r\n        });\r\n    };\r\n\r\n    componentDidUpdate(prevProps: PropsType, prevState: StateType) { /*Это метод жизненного цикла классового компонента.\r\n    Он вызывается в момент обновления (изменения \"props\" или \"state\") компонента. Указали, что предыдущие \"props\" в этом\r\n    классовом компоненте имеют тип \"PropsType\", а предыдущий \"state\" имеет тип \"StateType\".*/\r\n        if (prevProps.status !== this.props.status) { /*Если значение статуса из новых \"props\" не равно значению статуса\r\n        из предыдущих \"props\", то только в этом случае обновляем значение статуса в локальном \"state\". Эта проверка\r\n        нужна, чтобы избежать бесконечный цикл: после прихода новых \"props\" будут сразу обновлятся данные\r\n        локального \"state\", что заставит перерисоваться компонент, при перерисовка снова сработает \"componentDidUpdate\"\r\n        и локальный \"state\" снова изменится, что снова заставит перерисоваться компонент. В итоге весь этот код помогает\r\n        нам синхронизировать глобальный \"state\" и локальный \"state\", чтобы не было таких случаев, когда если сразу\r\n        после загрузки страницы профиля перейти в режим редактирования статуса и получить пустое поле (но у меня\r\n        не было почему то этой проблемы изначально).*/\r\n            this.setState({\r\n                status: this.props.status\r\n            });\r\n        }\r\n    };\r\n\r\n    handleFocus = (event: ChangeEvent<HTMLInputElement>) => { /*Создали специальный метод \"handleFocus\" для\r\n    автоматического выделения текста в поле статуса пользователя. Для события \"event\" указали тип\r\n    \"ChangeEvent<HTMLInputElement>\".*/\r\n        event.target.select();\r\n    };\r\n\r\n    render() {\r\n        /*\r\n        Здесь после return в компоненте начинается HTML разметка.\r\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n        */\r\n        return (\r\n            <> {/*Этот пустой элемент и есть наш корневой элемент.*/}\r\n                {!this.state.editMode && /*Если режим редактирования статуса пользователя отключен и мы являемся\r\n                владельцем страницы, то отрисуется элемент \"div\", внутри которого будет элемент \"span\", содержащий\r\n                обработчик события двойного нажатия по элементу \"onDoubleClick\". При срабатывании этого события\r\n                активируется метод \"activateEditMode\" через callback, чтобы активировать режим редактирования\r\n                статуса пользователя. Внутри элемента \"span\" будет отображаться текущее значение статуса пользователя\r\n                из \"props\", а при его отсуствии будет надпись \"Enter your status\". Если мы же не являемся владельцем\r\n                профиля, то мы не сможем перейти в режим редактирования, только увидеть сам статус. Здесь есть небольшая\r\n                проблема - после ввода нового статуса какое-то время будет отображен старый статус, пока не завершится\r\n                запрос на сервер на изменение этого статуса.\r\n                Одним из вариантов решений этой проблемы может быть добавление заглушки \"Preloader\"\r\n                на время пока идет запрос.*/\r\n                <div>\r\n                    {this.props.isOwner\r\n                        ? <div><b>Status</b>: <span onDoubleClick={this.activateEditMode}>{this.props.status || 'Enter your status'}</span></div>\r\n                        : <span>{this.props.status || ''}</span>\r\n                    }\r\n                </div>\r\n                }\r\n                {this.state.editMode && /*Если режим редактирования статуса пользователя включен, то\r\n                отрисуется элемент \"div\", внутри которого будет элемент \"input\", содержащий обработчик события потери\r\n                фокуса с элемента \"onBlur\". При срабатывании этого события активируется метод \"deactivateEditMode\"\r\n                через callback, чтобы деактивировать режим редактирования статуса пользователя и сохранить\r\n                новый статус в глобальном \"state\". Также у элемента \"input\" указан атрибут \"autoFocus\" для\r\n                автоматического фокуса на элементе. Внутри элемента \"input\" будет отображаться текущее значение\r\n                статуса пользователя при помощи атрибута \"value\" из локального \"state\". Также внутри элемента \"input\"\r\n                содержится обработчик события появления фокуса на элементе \"onFocus\", при срабатывании которого\r\n                активируется метод \"handleFocus\" через callback, чтобы автоматически выделить текст статуса\r\n                пользователя.Еще внутри элемента \"input\" содержится обработчик события изменения поля \"input\"\r\n                \"onChange\", при срабатывании которого активируется метод \"onUserStatusChange\" через callback, чтобы\r\n                брать текущее значение содержимого этого поля и сохранять его в локальный \"state\".*/\r\n                <div>\r\n                    <input onChange={this.onUserStatusChange}\r\n                           onFocus={this.handleFocus}\r\n                           autoFocus={true}\r\n                           onBlur={this.deactivateEditMode}\r\n                           value={this.state.status}/>\r\n                </div>\r\n                }\r\n            </>\r\n        );\r\n    };\r\n};\r\n\r\nexport default ProfileStatus; /*Экспортируем компонент \"ProfileStatus\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"ProfileDataForm\".\r\n- обворачиваем компонент \"ProfileDataForm\" HOC-ом \"reduxForm\" в компоненте \"ProfileDataFormReduxForm\", тем самым\r\nпредоставляя callback \"handleSubmit\" для компонента \"ProfileDataForm\".\r\n- компонент \"ProfileDataFormReduxForm\" указывается в компоненте \"ProfileInfo\" в файле \"ProfileInfo.jsx\", куда в\r\nсобытие \"onSubmit\" будет попадать объект с данными, сформированный в событии \"onSubmit\" при помощи\r\ncallback \"handleSubmit\" в компоненте \"ProfileDataForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"ProfileDataForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"onSubmit\" (доступен из контейнерного компонента \"ProfileDataFormReduxForm\") из компонента\r\n\"ProfileInfo\" в файле \"ProfileInfo.jsx\", в который передается указанный объект с данными и собираются в одном месте,\r\nпотом эти данные передаются в компонент \"ProfileDataFormReduxForm\", из которого перенаправляются в глобальный \"state\"\r\nв виде объекта под именем \"editProfile\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n*/\r\n\r\nimport {createField, Input, Textarea} from '../../common/FormsControls/FormsControls'; /*Подключаем созданный нами\r\nкомпонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию. Также подключаем созданный\r\nнами компонент \"Input\" для создания элемента \"input\" с возможностью указывать валидацию. Также импортируем функцию\r\n\"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания формы\r\nв компоненте \"ProfileDataForm\".*/\r\n\r\nimport style from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport styles from '../../common/FormsControls/FormsControls.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"ProfileDataForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileDataForm\" является компонентом, который представляет из себя форму для редактирования профиля пользователя\r\nна странице профиля в виде заготовки для обворачивания ее в HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"ProfileDataFormReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым\r\nполучая callback \"handleSubmit\".\r\n*/\r\nconst ProfileDataForm = ({ /*Указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.handleSubmit\",\r\n\"props.profile\" и так далее. Такое мы делаем только в функциональных компонентах.*/\r\n                             handleSubmit, /*Callback для сабмита данных.*/\r\n                             profile, /*Данные профиля пользователя для страницы профиля.*/\r\n                             error /*Свойство, содержащее текст ошибки (если была). Свойство \"error\" будет в объекте\r\n                             \"props\" благодаря библиотеке \"redux-form\", в него подцепится значение из TC \"saveProfile\"\r\n                             из \"profile-reducer.ts\".*/\r\n}) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указывает\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>save</button>\r\n            </div>\r\n\r\n            {error && <div className={styles.formSummaryError}>{error}</div>} {/*Если произошла какая-то ошибка, то\r\n            выведем ее в отдельном элементе \"div\". Свойство \"error\" будет в объекте \"props\" благодаря\r\n            библиотеке \"redux-form\", в него подцепится значение из TC \"saveProfile\" из \"profile-reducer.ts\".*/}\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для ввода полного имени пользователя.*/}\r\n                <b>1. Full Name</b>:\r\n                {createField(\"Full Name\", \"fullName\", Input, [])}\r\n                {/*Создали поле для ввода полного имени пользователя на основе импортированной функции \"createField\".*/}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для ввода информации о пользователе \"Обо мне\".*/}\r\n                <b>2. About Me</b>:\r\n                {createField(\"About Me\", \"aboutMe\", Input, [])}\r\n                {/*Создали поле для ввода информации о пользователе \"Обо мне\" на основе импортированной\r\n                функции \"createField\".*/}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поля для ввода контактов пользователя. Создаются эти поля\r\n            следующим образом (аналогично как и в компоненте \"ProfileData\" из файла \"ProfileInfo.jsx\"):*/}\r\n                <b>3. Contacts</b>: {Object.keys(profile.contacts).map(key => { /*При помощи метода \"keys\" глобального\r\n                объекта \"Object\" мы можем проитерироваться по ключам переданного объекта \"profile.contacts\". Возьмутся\r\n                все ключи \"key\" и завернутся в массив строк. А далее мы мапим этот массив, чтобы отрисовать JSX с\r\n                однотипным полями контактов при помощи небольшого куска JSX (в компоненте \"ProfileData\" из\r\n                файла \"ProfileInfo.jsx\" для такого JSX мы создавали вспомогательную компоненту \"Contact\").*/\r\n                return (\r\n                    <div key={key} className={style.contact}> {/*Отрисовываем элемент \"div\", который представляет\r\n                    из себя типовое поле для указания контакта. При использовании метода \"map\" нужно указывать\r\n                    атрибут \"key\" для избежания ошибок.*/}\r\n                        <b>{key}: {createField(key, \"contacts.\" + key, Input, [])}</b>\r\n                        {/*Внутри этот элемент \"div\" будет из себя представлять следующее:\r\n                         \"Текст заголовка поля контакта\": \"Текст со значение самого контакта\". Первое будет браться\r\n                         из ключа \"key\". Второе будет создаваться на основе импортированной функции \"createField\".\r\n                         \"name\" во втором будет получаться так: к тексту \"contacts.\" будет прибавляться текст ключа\r\n                         (например, \"github\"), что в итоге будет давать правильную структуру контактов (например,\r\n                         \"contacts.github\") для составления объекта с контактами, который сможет понять сервер\r\n                         при получении объекта с данным по профилю пользователя.*/}\r\n                    </div>\r\n                )\r\n            })}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для указания ищет ли в данный момент работу пользователь.*/}\r\n                <b>4. Is looking for a job?</b>\r\n                {createField(\"\", \"lookingForAJob\", Input, [], {type: \"checkbox\"})}\r\n                {/*Создали поле для указания ищет ли в данный момент работу пользователь на основе импортированной\r\n                функции \"createField\".*/}\r\n            </div>\r\n\r\n            <div> {/*Этот элемент \"div\" содержит поле для ввода работы, которую ищет пользователь.*/}\r\n                <b>Which one?</b>\r\n                {createField(\"Which one?\", \"lookingForAJobDescription\", Textarea, [])}\r\n                {/*Создали поле для ввода работы, которую ищет пользователь, на основе импортированной\r\n                функции \"createField\".*/}\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"ProfileDataForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"ProfileDataFormReduxForm\" будет заниматься общением\r\nс глобальным \"state\". Далее этот компонент используется в компоненте \"ProfileInfo\" в файле \"ProfileInfo.jsx\" */\r\nconst ProfileDataFormReduxForm = reduxForm({\r\n    form: 'editProfile' /*Это то самое уникальное имя для данных этой формы, которые будут попадать\r\n    в глобальный \"state\".*/\r\n})(ProfileDataForm);\r\n\r\nexport default ProfileDataFormReduxForm; /*Экспортируем компонент \"ProfileDataFormReduxForm\" по default, экспорт\r\nнеобходим для импорта.*/","import React, {useState} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\n*/\r\n\r\nimport styles from './ProfileInfo.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport userPhoto from '../../../assets/images/user.png'; /*Импортируем из ассетов аватар на случай, если у пользователя\r\nнет фото.*/\r\nimport profileLogoSource from '../../../assets/images/profilelogo.jpg'; /*Импортируем из ассетов лого для страницы\r\nпрофиля.*/\r\n\r\nimport Preloader from '../../common/Preloader/Preloader'; /*Подключаем компонент \"Preloader\".*/\r\nimport ProfileStatus from './ProfileStatus'; /*Подключаем компонент \"ProfileStatus\", но в данный момент\r\nне используется (аналог компонента \"ProfileStatusWithHooks\", но без хуков).*/\r\nimport ProfileStatusWithHooks from './ProfileStatusWithHooks'; /*Подключаем компонент \"ProfileStatusWithHooks\".*/\r\nimport ProfileDataFormReduxForm from './ProfileDataForm'; /*Подключаем компонент \"ProfileDataFormReduxForm\".*/\r\n\r\n\r\n/*\r\n\"ProfileInfo\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileInfo(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileInfo\" является компонентом, который содержит информацию о пользователе.\r\nЭтот компонент подключается в компоненте \"Profile\".\r\nВнутри компонента \"Profile\" подключаются компоненты:\r\n- \"Preloader\", который является компонентом-заглушкой, который используется, чтобы показать анимацию загрузки в других\r\nкомпонентах, когда идет какой-то процесс в них (например, AJAX-запрос);\r\n- \"ProfileStatusWithHooks\", который отвечает за отображение и редактирование статуса пользователя на странице профиля\r\n(сделан на хуках);\r\n- \"ProfileStatus\", который отвечает за отображение и редактирование статуса пользователя на странице профиля (в данный\r\nмомент не используется);\r\n- \"ProfileDataFormReduxForm\", который ;\r\n- \"ProfileData\", который является внутренним вспомогательным компонентом для компонента \"ProfileInfo\", который содержит\r\nданные профиля пользователя и интерфейс для перехода в режим редактирования этой информации.\r\n*/\r\nconst ProfileInfo = ({/*Указываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.isOwner\",\r\n\"props.profile\" и так далее. Такое мы делаем только в функциональных компонентах.*/\r\n                         isOwner, /*Свойство, которое показывает является ли залогиненный пользователь владельцем\r\n                         профиля, который в данный момент отображается на странице профиля.*/\r\n                         profile, /*Данные профиля пользователя для страницы профиля.*/\r\n                         status, /*Данные статуся пользователя для страницы профиля.*/\r\n                         updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/\r\n                         saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его\r\n                         отображения в нашем приложении.*/\r\n                         saveProfile /*TC для отправки новых данных профиля пользователя на странице профиля и\r\n                         дальнейшего их отображения в нашем приложении.*/\r\n}) => {\r\n    let [editMode, setEditMode] = useState(false); /*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет означать\r\n    включен или выключен режим редактирования профиля пользователя (изначально \"false\"). Вторая переменная будет\r\n    хранить функцию из хука \"useState\", которая будет изменять первый элемент (то есть включать или выключать режим\r\n    редактирования профиля пользователя).*/\r\n\r\n    const activateEditMode = () => { /*Создали функцию, которая при вызове активирует режим редактирования\r\n    профиля пользователя.*/\r\n        setEditMode(true);\r\n    };\r\n\r\n    if (!profile) { /*Если данные профиля пользователя отсутствуют, то отрисовываем компонент-заглушку \"Preloader\".*/\r\n        return <Preloader/>\r\n    }\r\n\r\n    const onUserPhotoSelected = (e) => { /*Создали функцию, которая при вызове сначала проверяет, что массив файлов с\r\n    фото пользователя не пустой, и если он не пустой, то потом отправляет первый файл из этого массива в\r\n    TC \"saveUserPhoto\" для загрузки фото пользователя на сервер и дальнейшего его отображения в нашем приложении. Эта\r\n    функция будет срабатывать как callback, когда пользователь выбирает изображение.*/\r\n        if (e.target.files.length) {\r\n            saveUserPhoto(e.target.files[0]);\r\n        }\r\n    };\r\n\r\n    const onSubmit = (formData) => { /*Создали функцию, которая при вызове совершает сабмит данных, то есть собирает\r\n    данные формы и вызывает TC \"saveProfile\" для отправки новых данных профиля пользователя на странице профиля и\r\n    дальнейшего их отображения в нашем приложении, передав ему эти данные. Далее будет ожидание промиса. При успешном\r\n    выполнении промиса деактивируется режим редактирования профиля пользователя. Если от сервера придет ошибка, то\r\n    промис будет отклонен и режим редактирования профиля пользователя не будет деактивирован (так работает этот TC\r\n    \"saveProfile\"). Если здесь использовать \"async/await\" вместо \".then\", то работать не будет.*/\r\n        saveProfile(formData).then(\r\n            () => {\r\n                setEditMode(false);\r\n            }\r\n        );\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <div className={styles.profileImage}> {/*Этот элемент \"div\" содержит изображение из шапки страницы\r\n            профиля.*/}\r\n                <img src={profileLogoSource} alt=''/> {/*Отрисовываем элемент \"img\", который содержит изображение\r\n                из шапки страницы профиля.*/}\r\n            </div>\r\n\r\n            <div className={styles.descriptionBlock}> {/*Этот элемент \"div\" содержит данные профиля пользователя\r\n            на странице профиля.*/}\r\n                <img src={profile.photos.large || userPhoto} className={styles.userPhoto} alt=''/> {/*Отрисовываем\r\n                элемент \"img\", в котором будет отображаться фото пользователя, а если данных по фото пользователя от\r\n                сервера получено не было, то отобразится аватар из ассетов проекта.*/}\r\n\r\n                {isOwner && <input type={'file'} onChange={onUserPhotoSelected}/>} {/*Если пользователь является\r\n                владельцем открытого в данным момент профиля, то отрисуется элемент \"input\" с \"type\" равным \"file\"\r\n                (т.е. можно загрузить файл) с событием при изменении \"onUserPhotoSelected\" для загрузки\r\n                фото пользователя.*/}\r\n\r\n                {/*Отрисовываем компонент \"ProfileStatusWithHooks\" и передаем ему через \"props\" необходимые для\r\n                него данные.*/}\r\n                <ProfileStatusWithHooks status={status} /*Данные статуся пользователя для страницы профиля.*/\r\n                               updateUserStatus={updateUserStatus} /*TC для изменения статуса пользователя\r\n                               на странице профиля.*/\r\n                               isOwner={isOwner} /*Свойство, которое показывает является ли залогиненный пользователь\r\n                               владельцем профиля, который в данный момент отображается на странице профиля.*/\r\n                />\r\n\r\n                {editMode /*Если режим редактирования включен, то отрисуется компонент \"ProfileDataFormReduxForm\",\r\n                получив стартовые значения \"initialValues\" (взято из библиотеки \"redux-form\") для полей формы, данные\r\n                автоматически раскидаются по полям в зависимости от их имен, чтобы при переходе в режим редактирования\r\n                профиля поля не были пустыми, если она уже имели какую-то информацию. При подтверждении формы в этом\r\n                компоненте сработает callback \"onSubmit\" для сабмита данных. Также передаем в компонент\r\n                \"ProfileDataFormReduxForm\" объект с данными профиля пользователя \"profile\" для его маппинга и создания\r\n                полей для редактирования контактов пользователя (смотри реализацию самого компонента).\r\n\r\n                Если же режим редактирования выключен, то отрисуется компонент \"ProfileData\" для отображения профиля\r\n                пользователя. В него мы передаем объект с данными профиля пользователя \"profile\", и свойство \"isOwner\",\r\n                так как нам нужно знать является ли пользователь владельцем открытого в данный момент профиля, поскольку\r\n                только владелец своего профиля должен иметь право его редактировать. Также в этот компонент мы передаем\r\n                callback \"activateEditMode\" для активации режима редактирования профиля пользователя.*/\r\n                    ? <ProfileDataFormReduxForm initialValues={profile} onSubmit={onSubmit} profile={profile}/>\r\n                    : <ProfileData profile={profile} isOwner={isOwner} activateEditMode={activateEditMode}/>\r\n                }\r\n            </div>\r\n        </div>\r\n    );\r\n};\r\n\r\n/*\r\n\"ProfileData\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ProfileData(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileData\" является внутренним вспомогательным компонентом для компонента \"ProfileInfo\", который содержит данные\r\nпрофиля пользователя и интерфейс для перехода в режим редактирования этой информации.\r\nЭтот компонент подключается в компоненте \"ProfileInfo\".\r\n*/\r\nconst ProfileData = ({profile, isOwner, activateEditMode}) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {isOwner && <div> {/*Если пользователь является владельцем открытого профиля, то отображаем\r\n            элемент \"div\",*/}\r\n                <button onClick={activateEditMode}>edit</button> {/*внутри которого есть элемент \"button\", для\r\n                отображения кнопки перехода в режим редактирования данных профиля, для чего указано событие\r\n                при нажатии \"activateEditMode\".*/}\r\n            </div>}\r\n\r\n            <div><b>1. Full Name</b>: {profile.fullName}</div> {/*Этот элемент \"div\" содержит полное имя пользователя,\r\n            которое берется из \"props\".*/}\r\n\r\n            <div><b>2. About Me</b>: {profile.aboutMe}</div> {/*Этот элемент \"div\" содержит информацию о пользователе\r\n            \"Обо мне\", которая берется из \"props\".*/}\r\n\r\n            <div> {/*Этот элемент \"div\" содержит контакты пользователя, которые берутся из \"props\". Создаются\r\n            следующим образом:*/}\r\n                <b>3. Contacts</b>: {Object.keys(profile.contacts).map(key => { /*При помощи метода \"keys\" глобального\r\n                объекта \"Object\" мы можем проитерироваться по ключам переданного объекта \"profile.contacts\". Возьмутся\r\n                все ключи \"key\" и завернутся в массив строк. А далее мы мапим этот массив, чтобы отрисовать однотипный\r\n                JSX с полями контактов при помощи компонента \"Contact\".*/\r\n                return <Contact key={key} /*При использовании метода \"map\" нужно указывать атрибут \"key\"\r\n                                для избежания ошибок.*/\r\n                                contactTitle={key} /*Заголовок поля контакта.*/\r\n                                contactValue={profile.contacts[key]} /*Значение поля контакта в соответствии\r\n                                с заголовком.*/\r\n                />\r\n            })}\r\n            </div>\r\n\r\n            <div><b>4. Is looking for a job?</b> {profile.lookingForAJob ? <span>Yes</span> : <span>No</span>}</div>\r\n            {/*Этот элемент \"div\" содержит информацию ищет ли в данный момент работу пользователь. Если свойство\r\n            \"lookingForAJob\", которое берется из \"props\", является \"TRUE\", то отрисуется элемент \"span\" с текстом \"Yes\",\r\n            иначе отрисуется элемент \"span\" с текстом \"No\".*/}\r\n\r\n            {profile.lookingForAJob && <div><b>Which one?</b> {profile.lookingForAJobDescription}</div>} {/*Если\r\n            свойство \"lookingForAJob\", которое берется из \"props\", является \"TRUE\", то отрисуется элемент \"div\"\r\n            с текстом из \"lookingForAJobDescription\", который означает работу, которую ищет пользователь.*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n/*\r\n\"Contact\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Contact(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Contact\" является внутренним вспомогательным компонентом для компонента \"ProfileData\", который содержит заготовку\r\nдля полей контактов пользователя, который используется в маппинге для отрисовки однотипного JSX.\r\nЭтот компонент подключается в компоненте \"ProfileData\".\r\n*/\r\nconst Contact = ({contactTitle, contactValue}) => {\r\n    return <div className={styles.contact}><b>{contactTitle}</b>: {contactValue}</div>\r\n    {/*Этот элемент \"div\" и есть наш корневой элемент. Внутри он будет из себя представлять следующее:\r\n    \"Текст заголовка поля контакта\": \"Текст со значение самого контакта\".*/}\r\n};\r\n\r\n\r\nexport default ProfileInfo; /*Экспортируем компонент \"ProfileInfo\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Post.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"Post\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Post(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Post\" является компонентом, который описывает, как должны выглядеть посты пользователя в его профиле.\r\nЭтот компонент подключается в компоненте \"MyPosts\".\r\n*/\r\nconst Post = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.item}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовое отображение постов пользователя в его профиле,\r\n        которое будет отрисовываться в компоненте \"MyPosts\" при помощи метода \"map\".*/}\r\n            <img src={props.avatar} alt=''/> {/*Пост пользователя в его профиле содержит аватар пользователя, ссылка\r\n            на который берется из параметров \"props\".*/}\r\n\r\n            {props.message} {/*Также пост пользователя в его профиле содержит текст этого поста, которое берется\r\n            из параметров \"props\".*/}\r\n\r\n            <div><span>likes: {props.likes}</span></div> {/*А также пост пользователя в его профиле содержит\r\n            количество лайков у этого поста, которое берется из параметров \"props\".*/}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Post; /*Экспортируем компонент \"Post\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Field, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"AddPostForm\".\r\n- обворачиваем компонент \"AddPostForm\" HOC-ом \"reduxForm\" в компоненте \"AddPostReduxForm\", тем самым предоставляя\r\ncallback \"handleSubmit\" для компонента \"AddPostForm\".\r\n- компонент \"AddPostReduxForm\" указывается в компоненте \"MyPosts\", куда в событие \"onSubmit\" будет попадать\r\nобъект с данными, сформированный в событии \"onSubmit\" при помощи callback \"handleSubmit\" в компоненте \"AddPostForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"AddPostForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"addNewPost\" (доступен из контейнерного компонента \"AddPostReduxForm\") из компонента \"MyPosts\",\r\nв который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент\r\n\"AddPostReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под именем \"profileAddPostForm\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n*/\r\nimport {maxLengthCreator, required} from '../../../utils/validators/validators'; /*Подключаем валидаторы для полей\r\nформ.*/\r\nimport {Textarea} from '../../common/FormsControls/FormsControls'; /*Подключаем созданный нами компонент \"Textarea\" для\r\nсоздания элемента \"textarea\" с возможностью указывать валидацию.*/\r\n\r\nimport styles from './MyPosts.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport Post from './Post/Post'; /*Подключаем компонент \"Post\".*/\r\n\r\n\r\nconst maxLength10 = maxLengthCreator(10); /*Создали валидатор, который проверяет не введено ли больше 10\r\nсимволов в поле.*/\r\n\r\n/*\r\n\"AddPostForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function AddPostForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"AddPostForm\" является компонентом, который представляет из себя форму для добавления постов в профиле пользователя\r\nв виде заготовки для обворачивания ее в HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"AddPostReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым\r\nполучая callback \"handleSubmit\".\r\n*/\r\nconst AddPostForm = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={props.handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указывает\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            <div> {/*Создаем элемент \"textarea\" при помощи элемента \"Field\". Это будет поле для ввода текста поста.\r\n            Все это помещаем в отдельный элемент \"div\".*/}\r\n                <Field component={Textarea} /*Указываем, что отрисовываем созданный нами элемент \"Textarea\", который\r\n                из себя представляет элемент \"textarea\" с возможностью указывать валидацию.*/\r\n                       name={\"newPostText\"} /*Задаем имя данным, которые будут вводится в это поле.*/\r\n                       placeholder={\"Enter your message\"} /*Указываем текст \"placeholder\".*/\r\n                       validate={[required, maxLength10]}/> {/*Указываем, что используем два валидатора \"required\" и\r\n                       \"maxLength10\".*/}\r\n            </div>\r\n\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>Add post</button>\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"AddPostForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"AddPostReduxForm\" будет заниматься общением\r\nс глобальным \"state\".*/\r\nconst AddPostReduxForm = reduxForm({\r\n    form: 'profileAddPostForm' /*Это то самое уникальное имя для данных этой формы, которые будут попадать\r\n    в глобальный \"state\".*/\r\n})(AddPostForm);\r\n\r\n/*\r\n\"MyPosts\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function MyPosts(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"MyPosts\" является компонентом, который отображает посты на странице профиля пользователя.\r\nЭтот компонент подключается в компоненте \"DialogsContainer\".\r\nВнутри компонента \"MyPosts\" подключается компонент \"AddPostReduxForm\", в котором обворачиваем компонент \"AddPostForm\"\r\nHOC-ом \"reduxForm\", тем самым предоставляя callback \"handleSubmit\" для компонента \"AddPostForm\".\r\n*/\r\nconst MyPosts = React.memo(props => { /*Изначально это был классовый компонент и он отрисовывался несколько\r\nлишних раз. Но, вроде, если использовать \"connect\", то лишних отрисовок не будет. В любом случае, мы сделали этот\r\nкомпонент функциональным, чтобы избежать этих лишних перерисовок. Для этого мы и использовали \"React.memo()\" (хок?),\r\nчто содержит оптимизацию этих перерисовок, чтобы обвернуть этим наш функциональный компонент.*/\r\n    console.log(\"RENDER\"); /*Выводил в консоль слова \"RENDER\". На данный момент нужно только в учебных целях в\r\n    рамках проверки \"React.memo()\".*/\r\n\r\n    /*\r\n    В JSX в массив можно вкладывать компоненты.\r\n    В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде строки.\r\n    \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования исходного массива.\r\n    Метод \"map\" принимает стрелочную функцию.\r\n    То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n    и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    Потом будет браться следующий объект из исходного массива объектов\r\n    и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n    То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов.\r\n    В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n    Массив \"postsElements\" содержит посты пользователя в его профиле.\r\n    При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n    */\r\n    let postsElements = props.postsData.map(p => <Post id={p.id}\r\n                                                       message={p.message}\r\n                                                       likes={p.likesCount}\r\n                                                       avatar={p.avatar}\r\n                                                       key={p.id}/>);\r\n\r\n    let addNewPost = (values) => { /*Создали специальный callback \"addNewPost\", который будет вызываться при\r\n    срабатывании события \"onSubmit\" в форме.*/\r\n        props.addPost(values.newPostText); /*Здесь мы вызываем AC \"addPost\", полученный из props, и передаем ему\r\n        текст поста.*/\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.postsBlock}> {/*Этот элемент \"div\" и есть наш корневой элемент. Он из себя представляет\r\n        блок с постами пользователя.*/}\r\n            <h3>My posts</h3> {/*При помощи элемента \"h3\" создаем заголовок для блока постов пользователя.*/}\r\n            <AddPostReduxForm onSubmit={addNewPost}/> {/*Здесь в событии \"onSubmit\" будет приходить объект с данными\r\n            из callback \"handleSubmit\" из компонента \"AddPostForm\", который обвернут компонентом \"AddPostReduxForm\".\r\n            Далее будет вызываться при этом событии нами созданный callback \"addNewPost\", в который будет передаваться\r\n            этот объект с данными. После этого эти данные будут отправлятся в часть глобального \"state\", которую\r\n            обрабатывает библиотека \"redux-form\", с целью осуществления работы нашей формы логина. Поскольку мы вызываем\r\n            функцию \"addNewPost\" как callback, поэтому не ставим \"()\" после имени функции. Но теперь после отправки\r\n            поста окно для ввода текста поста не будет очищаться, так как библиотека \"redux-form\" хоть и осуществляет\r\n            FLUX-круговорот, но очистку не осуществляет.*/}\r\n            <div className={styles.posts}>{postsElements}</div> {/*Отрисовываем посты пользователя.*/}\r\n        </div>\r\n    );\r\n});\r\n\r\nexport default MyPosts; /*Экспортируем компонент \"MyPosts\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\n\r\nimport MyPosts from './MyPosts'; /*Подключаем компонент \"MyPosts\".*/\r\n\r\nimport {addPostActionCreator} from '../../../redux/profile-reducer'; /*Подключаем АC \"addPostActionCreator\"\r\nиз \"profile-reducer\".*/\r\n\r\n\r\n/*\r\n\"MyPostsContainer\" это не классовый компонент и не функциональный компонент.\r\n\"MyPostsContainer\" является только контейнерным компонентом для компонента \"MyPosts\".\r\nВ отличии от классового компонента, этот компонент не имеет методов жизненного цикла.\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.js\") из библиотеки \"react-redux\".\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВ этом компоненте мы просто создаем \"mapStateToProps\" и \"mapDispatchToProps\", тем самым формируя \"props\"\r\nдля презентационной компоненты \"MyPosts\". Поэтому нам не нужно создавать классовый компонент для этого.\r\nТаким же образом созданы контейнерные компоненты \"NavbarContainer\", \"DialogsContainer\".\r\n*/\r\n\r\nconst mapStateToProps = (state) => { /*Здесь указываются данные из \"state\", которые необходимо передать\r\nв компонент \"MyPosts\". Эта функция возвращает указанные данные в виде объекта.*/\r\n    return {\r\n        postsData: state.profilePage.postsData /*Данные о постах на странице пользователя.*/\r\n    }\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => { /*Здесь указываются данные (callbacks - \"AC\" или \"TC\") \"dispatch\",\r\nкоторые необходимо передать в компонент \"MyPosts\". Эта функция возвращает указанные данные в виде объекта.\r\nФункция \"mapDispatchToProps\" работает следующим образом:\r\n1) Компонент вызывает через callback функцию \"addPost\".\r\n2) Компонент передает этой функции параметр \"newPostText\".\r\n3) Далее этот параметр передается в AC \"addPostActionCreator\".\r\n4) Этот AC вызывается.\r\n5) Создается объект \"action\".\r\n6) Этот объект \"action\" диспатчится в \"dialogsReducer\" в \"profile-reducer.js\".*/\r\n    return {\r\n        addPost: (newPostText) => {\r\n            dispatch(addPostActionCreator(newPostText));\r\n        }\r\n    }\r\n};\r\n\r\nexport default connect(mapStateToProps, mapDispatchToProps)(MyPosts);\r\n/*\r\nПри помощи метода \"connect\" создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL\r\nкомпоненту \"MyPosts\". Экспортируем получившийся в итоге компонент, который будет использоваться под именем\r\n\"MyPostsContainer\", по default, экспорт необходим для импорта.\r\n*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './Profile.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport ProfileInfo from './ProfileInfo/ProfileInfo'; /*Подключаем компонент \"ProfileInfo\".*/\r\nimport MyPostsContainer from './MyPosts/MyPostsContainer'; /*Подключаем компонент \"MyPostsContainer\".*/\r\n\r\n\r\n/*\r\n\"Profile\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Profile(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Profile\" является презентационным компонентом.\r\n\"Profile\" является компонентом, который отображает профиль пользователя целиком.\r\nЭтот компонент подключается в компоненте \"ProfileContainer\".\r\nВнутри компонента \"Profile\" подключаются компоненты:\r\n- \"ProfileInfo\", который содержит информацию о пользователе;\r\n- \"MyPostsContainer\", который является контейнером для компонента \"MyPosts\", содержащего посты пользователя.\r\n*/\r\nconst Profile = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.profile}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {/*Далее отрисовываем компонент \"ProfileInfo\" и передаем ему через \"props\" необходимы для него данные.*/}\r\n            <ProfileInfo profile={props.profile} /*Данные профиля пользователя для страницы профиля.*/\r\n                         status={props.status} /*Данные статуся пользователя для страницы профиля.*/\r\n                         updateUserStatus={props.updateUserStatus} /*TC для изменения статуса пользователя на\r\n                         странице профиля.*/\r\n                         isOwner={props.isOwner} /*Свойство, которое показывает является ли залогиненный пользователь\r\n                         владельцем профиля, который в данный момент отображается на странице профиля.*/\r\n                         saveUserPhoto={props.saveUserPhoto} /*TC для загрузки фото пользователя на странице профиля и\r\n                         дальнейшего его отображения в нашем приложении.*/\r\n                         saveProfile={props.saveProfile} /*TC для отправки новых данных профиля пользователя на\r\n                         странице профиля и дальнейшего их отображения в нашем приложении.*/\r\n            />\r\n\r\n            {/*А также отрисовываем компонент \"MyPostsContainer\" помимо компонента \"ProfileInfo\".*/}\r\n            <MyPostsContainer/>\r\n        </div>\r\n    );\r\n}\r\n\r\nexport default Profile; /*Экспортируем компонент \"Profile\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {compose} from 'redux';\r\n/*\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и ХОКи.\r\nОбвертки и ХОКи указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\n*/\r\nimport {withRouter} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nФункция \"withRouter\" это HOC.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nПоскольку URL тоже является источником данных, то компоненту иногда могут понадобиться эти данные.\r\nЧтобы их получить, можно воспользоваться \"withRouter\".\r\nHOC \"withRouter\" принимает в качестве параметра компонент и передает ему через \"props\" данные из URL, чтобы компонент\r\nзнал где он находиться - т.е. какой у него маршрут.\r\nЕсли подключить на самом высоком уровне дерева компонентов этот HOC, например, в \"App.js\", то данные URL будут доступны\r\nи в дочерних компонентах.\r\nТо есть здесь можно было и не указывать HOC \"withRouter\".\r\nПри использовании \"connect\" роутинг сбивается. Чтобы решить эту проблемы мы обварачиваем \"connect\" при помощи\r\n\"withRouter\". Но сейчас вроде и без этого все работает.\r\n*/\r\n\r\nimport Profile from './Profile'; /*Подключаем компонент \"Profile\".*/\r\n\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC \"withAuthRedirect\"\r\nдля добавления редиректа. В данный момент не используется.*/\r\n\r\nimport {\r\n    getUserProfile, /*Подключаем TC \"getUserProfile\" из \"profile-reducer\".*/\r\n    getUserStatus, /*Подключаем TC \"getUserStatus\" из \"profile-reducer\".*/\r\n    saveProfile, /*Подключаем TC \"saveProfile\" из \"profile-reducer\".*/\r\n    saveUserPhoto, /*Подключаем TC \"saveUserPhoto\" из \"profile-reducer\".*/\r\n    updateUserStatus /*Подключаем TC \"updateUserStatus\" из \"profile-reducer\".*/\r\n} from '../../redux/profile-reducer';\r\n\r\n\r\n/*\r\n\"ProfileContainer\" это классовый компонент.\r\nКлассы нужны для того, чтобы создавать однотипные объекты на базе этих классов, благодаря чему можно реализовывать\r\nконцепцию ООП.\r\nReact определяет классовый компонент и на его основе создает экземпляр класса, и далее будет уже взаимодействовать\r\nс этим объектом (использовать его свойства и методы). Этот объект хранится постоянно в памяти и React с ним постоянно\r\nвзаимодействует.\r\nНапример, у него можно постоянно запрашивать JSX.\r\nВ React при создании класса мы наследуем и расширяем некий базовый класс \"React.Component\" при помощи \"extends\".\r\nКомпонент это функция, которая возвращает JSX.\r\nКлассовые компоненты могут содержать \"side effects\". Для этого используются методы жизненного цикла.\r\nУ классового компонента всегда есть метод render(){...}, который возвращает JSX.\r\nПри переходе по разным \"Route\" экземпляры классовых компонентов удаляются из памяти.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ProfileContainer\" является контейнерным компонентом для компонента \"Profile\".\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.js\") из библиотеки \"react-redux\".\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nclass ProfileContainer extends React.Component {\r\n    refreshProfile() { /*Создаем специальный метод, который содержит необходимый функционал для обновления\r\n    страницы профиля.*/\r\n        let userID = this.props.match.params.userID; /*Получаем \"ID\" пользователя. HOC \"withRouter\" хранит некий объект,\r\n        к которому можно обратиться как к \"match.params.userID\", чтобы получить значения\r\n        дополнения \":userID\" к пути \"/profile/\", как это указано у нас в компоненте \"App\".*/\r\n\r\n        if (!userID) { /*Если не удалось получить \"ID\" пользователя, то*/\r\n            userID = this.props.authUserID; /*пытаемся его получить от пользователя, под которым залогинены,*/\r\n            if (!userID) { /*а если же и после этого не удалось получить \"ID\" пользователя, то*/\r\n                this.props.history.push(\"/login/\") /*нас перенаправляет на страницу логирования.*/\r\n            }\r\n        }\r\n\r\n        /*Если же мы все-таки получили \"ID\" пользователя, то делаем следующее:*/\r\n        this.props.getUserProfile(userID); /*вызываем TC \"getUserProfile\" для получения данных профиля пользователя и\r\n        их установки на странице профиля.*/\r\n        this.props.getUserStatus(userID); /*вызываем TC \"getUserStatus\" для получения данных статуса пользователя и\r\n        их установки на странице профиля.*/\r\n    };\r\n\r\n    componentDidMount() { /*Это метод жизненного цикла классового компонента. Он вызывается в момент первой\r\n    отрисовки (монтирования) компонента.*/\r\n        this.refreshProfile(); /*Вызываем метод \"refreshProfile\".*/\r\n    };\r\n\r\n    componentDidUpdate(prevProps, prevState, snapshot) { /*Это метод жизненного цикла\r\n    классового компонента. Он вызывается в момент обновления (изменения \"props\" или \"state\") компонента.*/\r\n        if (this.props.match.params.userID !== prevProps.match.params.userID) { /*Проверяем изменился ли \"ID\"\r\n        пользователя в \"props\". Эта проверка нужна, чтобы избежать бесконечный цикл запроса новых \"props\" методом\r\n        \"refreshProfile\": изначально срабатывает метод \"refreshProfile\" из \"componentDidMount\", получает новые \"props\",\r\n        в свою очередь это триггерит метод \"refreshProfile\" из \"componentDidUpdate\", снова получаем новые \"props\" и\r\n        снова триггерим метод \"refreshProfile\" из \"componentDidUpdate\" и так до бесконечности.*/\r\n            this.refreshProfile(); /*Если изменился, то вызываем метод \"refreshProfile\".*/\r\n        }\r\n    };\r\n\r\n    render() {\r\n        /*\r\n        Здесь после return в компоненте начинается HTML разметка.\r\n        Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n        Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n        */\r\n        return (\r\n            <Profile {...this.props} /*Отрисовываем компонент \"Profile\" и передаем ему через \"props\" необходимые для\r\n            него данные. Этот элемент \"Profile\" и есть наш корневой элемент. Здесь используется spread-оператор \"...\",\r\n            который из всех \"props\" создает атрибуты для компонента.*/\r\n                     isOwner={!this.props.match.params.userID} /*Свойство, которое показывает является ли залогиненный\r\n                     пользователь владельцем профиля, который в данный момент отображается на странице профиля. Будет\r\n                     равно \"TRUE\", если в данных URL не было найдено значения дополнения \":userID\" к пути \"/profile/\",\r\n                     как это указано у нас в компоненте \"App\", т.е. пользователь совершил переход просто на \"/profile/\",\r\n                     желая попасть на свою страницу, а не на чью-то другую. Это свойство нужно, чтобы интерфейс для\r\n                     редактирования информации в профиле появлялся только на собственной странице пользователя. Хотя\r\n                     тут есть проблема, когда мы переходим на свой профиль при помощи своего \"ID\" и не имеем\r\n                     упомянутого интерфейса. Далее передается в компонент \"ProfileInfo\".*/\r\n            />\r\n        )\r\n    }\r\n};\r\n\r\nconst mapStateToProps = (state) => ({ /*Здесь указываются данные из \"state\", которые необходимо передать\r\nв компонент \"ProfileContainer\". Эта функция возвращает указанные данные в виде объекта.*/\r\n    profile: state.profilePage.profile, /*Данные профиля пользователя для страницы профиля. Далее передается в\r\n    компонент \"ProfileInfo\".*/\r\n    status: state.profilePage.status, /*Данные статуса пользователя для страницы профиля. Далее передается в\r\n    компонент \"ProfileInfo\".*/\r\n    authUserID: state.auth.id, /*\"ID\" залогиненного пользователя.*/\r\n});\r\n\r\nexport default compose( /*При помощи функции \"compose\" объеденяем ХОКи \"withRouter\", \"withAuthRedirect\" и \"connect\",\r\nвозвращая итоговый компонент \"AppContainer\".*/\r\n    connect(mapStateToProps, {/*При помощи метода \"connect\"\r\n    создаем контейнерный компонент, и тем самым передаем нужные данные BLL и DAL в другой контейнерный\r\n    компонент \"ProfileContainer\" из этого файла.*/\r\n        getUserProfile, /*TC для получения данных профиля пользователя и их установки на странице профиля.*/\r\n        getUserStatus, /*TC для получения данных статуса пользователя и их установки на странице профиля.*/\r\n        updateUserStatus, /*TC для изменения статуса пользователя на странице профиля.*/\r\n        saveUserPhoto, /*TC для загрузки фото пользователя на странице профиля и дальнейшего его отображения в нашем\r\n        приложении.*/\r\n        saveProfile}), /*TC для отправки новых данных профиля пользователя на странице профиля и дальнейшего их\r\n        отображения в нашем приложении.*/\r\n    withRouter, /*Так же при помощи метода \"withRouter\" передаем в этот контейнерный компонент данные из URL.*/\r\n    //withAuthRedirect /*При помощи ХОКа \"withAuthRedirect\" добавляем логику по редиректу в компонент.*/\r\n)(ProfileContainer);\r\n/*\r\nПолучившийся в итоге компонент экспортируем, который будет использоваться под именем \"ProfileContainer\", по default,\r\nэкспорт необходим для импорта.\r\n*/"],"sourceRoot":""}