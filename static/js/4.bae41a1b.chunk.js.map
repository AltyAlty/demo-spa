{"version":3,"sources":["components/Dialogs/Dialogs.module.css","hoc/WithAuthRedirect.js","components/Dialogs/DialogItem/DialogItem.jsx","components/Dialogs/Message/Message.jsx","components/Dialogs/IncomingMessage/IncomingMessage.jsx","components/Dialogs/Dialogs.jsx","components/Dialogs/DialogsContainer.jsx"],"names":["module","exports","mapStateToPropsForRedirect","state","isAuth","auth","withAuthRedirect","Component","RedirectComponent","this","props","to","React","connect","DialogItem","path","id","className","styles","dialog","src","avatar","alt","activeClassName","active","name","Message","message","IncomingMessage","incomingMessage","maxLength10","maxLengthCreator","AddMessageReduxForm","reduxForm","form","onSubmit","handleSubmit","Field","component","Textarea","placeholder","validate","required","Dialogs","dialogsElements","dialogsPage","dialogs","map","d","key","messagesElements","messagesData","m","incomingMessagesElement","incomingMessagesData","im","dialogsItems","messages","values","addMessage","newMessageText","incomingMessages","compose","dispatch","addMessageActionCreator"],"mappings":"+GACAA,EAAOC,QAAU,CAAC,QAAU,yBAAyB,aAAe,8BAA8B,OAAS,wBAAwB,OAAS,wBAAwB,SAAW,0BAA0B,iBAAmB,kCAAkC,QAAU,yBAAyB,gBAAkB,mC,uICqD7SC,EAA6B,SAACC,GAAD,MAAY,CAE3CC,OAAQD,EAAME,KAAKD,SAGVE,EAAmB,SAACC,GAAc,IAErCC,EAFqC,uKAKnC,OAAKC,KAAKC,MAAMN,OAIT,kBAACG,EAAcE,KAAKC,OAJI,kBAAC,IAAD,CAAUC,GAAI,gBALV,GAEXC,IAAML,WAiBtC,OALqCM,YAAQX,EAARW,CAAoCL,K,sICR9DM,EAtBI,SAACJ,GAChB,IAAIK,EAAO,YAAcL,EAAMM,GAQ/B,OACI,yBAAKC,UAAWC,IAAOC,QAAvB,IAGI,yBAAKC,IAAKV,EAAMW,OAAQC,IAAI,KAHhC,IAMI,kBAAC,IAAD,CAASX,GAAII,EAAMQ,gBAAiBL,IAAOM,QAASd,EAAMe,MAN9D,MCLOC,EAnBC,SAAChB,GAMb,OACI,yBAAKO,UAAWC,IAAOS,SAAvB,IAGI,yBAAKP,IAAKV,EAAMW,OAAQC,IAAI,MAHhC,IAMKZ,EAAMiB,QANX,MCYOC,EAnBS,SAAClB,GAMrB,OACI,yBAAKO,UAAWC,IAAOW,iBAAvB,IAGKnB,EAAMiB,QAHX,IAMI,yBAAKP,IAAKV,EAAMW,OAAQC,IAAI,MANhC,MCoCFQ,EAAcC,YAAiB,IAoD/BC,EAAsBC,YAAU,CAClCC,KAAM,wBADkBD,EA9BL,SAACvB,GAMpB,OACI,0BAAMyB,SAAUzB,EAAM0B,cAAtB,IAEI,iCAEI,kBAACC,EAAA,EAAD,CAAOC,UAAWC,IAEXd,KAAM,iBACNe,YAAa,qBACbC,SAAU,CAACC,IAAUZ,KANhC,KAUA,iCAEI,oDAgHDa,EAxEC,SAACjC,GAsBb,IAAIkC,EAAkBlC,EAAMmC,YAAYC,QAAQC,KAAI,SAAAC,GAAC,OAAI,kBAAC,EAAD,CAAYvB,KAAMuB,EAAEvB,KACRT,GAAIgC,EAAEhC,GACNK,OAAQ2B,EAAE3B,OACV4B,IAAKD,EAAEhC,QAExEkC,EAAmBxC,EAAMmC,YAAYM,aAAaJ,KAAI,SAAAK,GAAC,OAAI,kBAAC,EAAD,CAASpC,GAAIoC,EAAEpC,GACNW,QAASyB,EAAEzB,QACXN,OAAQ+B,EAAE/B,OACV4B,IAAKG,EAAEpC,QAE3EqC,EAA0B3C,EAAMmC,YAAYS,qBAAqBP,KAAI,SAAAQ,GAAE,OAAI,kBAAC,EAAD,CAAiBvC,GAAIuC,EAAGvC,GACRW,QAAS4B,EAAG5B,QACZN,OAAQkC,EAAGlC,OACX4B,IAAKM,EAAGvC,QAavG,OACI,yBAAKC,UAAWC,IAAO4B,SAAvB,IACI,yBAAK7B,UAAWC,IAAOsC,cAAeZ,GAD1C,IAII,yBAAK3B,UAAWC,IAAOuC,UAAvB,IACI,6BAAMP,GADV,IAEI,kBAAClB,EAAD,CAAqBG,SAlBb,SAACuB,GAEjBhD,EAAMiD,WAAWD,EAAOE,mBAcpB,KAaA,yBAAK3C,UAAWC,IAAO2C,kBAAmBR,GAjB9C,M,kBCtGOS,sBAEXjD,aAzBoB,SAACV,GAErB,MAAO,CACH0C,YAAa1C,EAAM0C,gBAIA,SAACkB,GASxB,MAAO,CACHJ,WAAY,SAACC,GACTG,EAASC,YAAwBJ,SASzCtD,IAJWwD,CAKbnB","file":"static/js/4.bae41a1b.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"dialogs\":\"Dialogs_dialogs__1Sptc\",\"dialogsItems\":\"Dialogs_dialogsItems__rEKAE\",\"active\":\"Dialogs_active__1PaZd\",\"dialog\":\"Dialogs_dialog__2SGJR\",\"messages\":\"Dialogs_messages__lyiGR\",\"incomingMessages\":\"Dialogs_incomingMessages__1g53F\",\"message\":\"Dialogs_message__1BlRt\",\"incomingMessage\":\"Dialogs_incomingMessage__hrgPD\"};","/*\r\nЭто специальной созданный нами HOC для добавления редиректа в наш проект.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\n*/\r\n\r\nimport React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {Redirect} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\n\"Redirect\" позволяет создавать компонент <Redirect/> для создания редиректа. Для указания пути редиректа используется\r\nатрибут \"to\".\r\nМаршрут для пути редиректа уже должен быть создан.\r\n*/\r\n\r\n\r\nconst mapStateToPropsForRedirect = (state) => ({ /*Здесь мы таким образом создали \"props\" необходимые для работы\r\nредиректа.*/\r\n    isAuth: state.auth.isAuth /*Свойство, которое указывает залогинен ли пользователь.*/\r\n});\r\n\r\nexport const withAuthRedirect = (Component) => { /*Это и есть наш HOC, который в качестве параметра принимает\r\nкакой-либо компонент.*/\r\n    class RedirectComponent extends React.Component { /*После получения компонента в качестве параметра, создается\r\n    другой классовый компонент \"RedirectComponent\".*/\r\n        render() { /*Свойственный для классовых компонентов метод \"render\".*/\r\n            if (!this.props.isAuth) return <Redirect to={'/login/'}/> /*Внутри этого классового компонента\r\n            \"RedirectComponent\" добавляем в компонент из параметров следующую логику: если пользователь не залогинен,\r\n            то происходит редирект по пути \"/login/\", где находится форма для логинизации.*/\r\n\r\n            return <Component {...this.props}/> /*А затем этот классовый компонент \"RedirectComponent\" возвращает\r\n            компонент из параметров, снабдив его \"props\", используя деструктуризацию.*/\r\n        }\r\n    }\r\n\r\n    let ConnectedAuthRedirectComponent = connect(mapStateToPropsForRedirect)(RedirectComponent); /*Далее в свою очередь\r\n    классовый компонент \"RedirectComponent\" обворачивается при помощи метода \"connect\", чтобы получить необходимые\r\n    \"props\" для проверки залогинен ли пользователь или нет. Метод \"connect\" вернет новый компонент\r\n    \"ConnectedAuthRedirectComponent\".*/\r\n\r\n    return ConnectedAuthRedirectComponent; /*И в конце концов HOC \"withAuthRedirect\" возвращает итоговый\r\n    компонент \"ConnectedAuthRedirectComponent\".*/\r\n}\r\n","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './../Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"DialogItem\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function DialogItem(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"DialogItem\" является компонентом, который описывает, как должны выглядеть диалоги.\r\nЭтот компонент подключается в компоненте \"Dialogs\".\r\n*/\r\nconst DialogItem = (props) => {\r\n    let path = '/dialogs/' + props.id; /*Путь для \"NavLink\" формируется на основе \"ID\" пользователя, который берется из\r\n    параметров \"props\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.dialog}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовой пункт диалогов, который будет отрисовываться в компоненте \"Dialogs\"\r\n        при помощи метода \"map\".*/}\r\n            <img src={props.avatar} alt=''/> {/*Пункт диалога содержит аватар пользователя, ссылка на который берется\r\n            из параметров \"props\".*/}\r\n\r\n            <NavLink to={path} activeClassName={styles.active}>{props.name}</NavLink> {/*А также пункт диалога содержит\r\n            элемент \"NavLink\" с именем пользователя, которое берется из параметров \"props\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default DialogItem; /*Экспортируем компонент \"DialogItem\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './../Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"Message\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Message(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Message\" является компонентом, который описывает, как должны выглядеть исходящие сообщения.\r\nЭтот компонент подключается в компоненте \"Dialogs\".\r\n*/\r\nconst Message = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.message}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовое отображение исходящих сообщений, которое будет отрисовываться в\r\n        компоненте \"Dialogs\" при помощи метода \"map\".*/}\r\n            <img src={props.avatar} alt=\".\"/> {/*Исходящее сообщение содержит аватар пользователя, ссылка на который\r\n            берется из параметров \"props\".*/}\r\n\r\n            {props.message} {/*Также исходящее сообщение содержит текст этого сообщения, которое берется из\r\n            параметров \"props\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default Message; /*Экспортируем компонент \"Message\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './../Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\n\r\n/*\r\n\"IncomingMessage\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function IncomingMessage(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"IncomingMessage\" является компонентом, который описывает, как должны выглядеть входящие сообщения.\r\nЭтот компонент подключается в компоненте \"Dialogs\".\r\n*/\r\nconst IncomingMessage = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.incomingMessage}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовое отображение входящих сообщений, которое будет отрисовываться в\r\n        компоненте \"Dialogs\" при помощи метода \"map\".*/}\r\n            {props.message} {/*Исходящее сообщение содержит текст этого сообщения, которое берется из\r\n            параметров \"props\".*/}\r\n\r\n            <img src={props.avatar} alt='.'/> {/*Также исходящее сообщение содержит аватар пользователя, ссылка\r\n            на который берется из параметров \"props\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\nexport default IncomingMessage; /*Экспортируем компонент \"IncomingMessage\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {Field, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"AddMessageForm\".\r\n- обворачиваем компонент \"AddMessageForm\" HOC-ом \"reduxForm\" в компоненте \"AddMessageReduxForm\", тем самым предоставляя\r\ncallback \"handleSubmit\" для компонента \"AddMessageForm\".\r\n- компонент \"AddMessageReduxForm\" указывается в компоненте \"Dialogs\", куда в событие \"onSubmit\" будет попадать объект\r\nс данными, сформированный в событии \"onSubmit\" при помощи callback \"handleSubmit\" в компоненте \"AddMessageForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"AddMessageForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"addNewMessage\" (доступен из контейнерного компонента \"AddMessageReduxForm\") из компонента \"Dialogs\",\r\nв который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент\r\n\"AddMessageReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под именем\r\n\"dialogAddMessageForm\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n*/\r\nimport {maxLengthCreator, required} from '../../utils/validators/validators'; /*Подключаем валидаторы для полей форм.*/\r\nimport {Textarea} from '../common/FormsControls/FormsControls'; /*Подключаем созданный нами компонент \"Textarea\" для\r\nсоздания элемента \"textarea\" с возможностью указывать валидацию.*/\r\n\r\nimport styles from './Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport DialogItem from './DialogItem/DialogItem'; /*Подключаем компонент \"DialogItem\".*/\r\nimport Message from './Message/Message'; /*Подключаем компонент \"Message\".*/\r\nimport IncomingMessage from './IncomingMessage/IncomingMessage'; /*Подключаем компонент \"IncomingMessage\".*/\r\n\r\n\r\nconst maxLength10 = maxLengthCreator(10); /*Создали валидатор, который проверяет не введено ли больше 10\r\nсимволов в поле.*/\r\n\r\n/*\r\n\"AddMessageForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nФункциональный компонент можно создать еще и таким образом: function AddMessageForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"AddMessageForm\" является компонентом, который представляет из себя форму для добавления исходящих сообщений\r\nв диалогах в виде заготовки для обворачивания ее в HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"AddMessageReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым\r\nполучая callback \"handleSubmit\".\r\n*/\r\nconst AddMessageForm = (props) => {\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={props.handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указываем\r\n        callback \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            <div> {/*Создаем элемент \"textarea\" при помощи элемента \"Field\". Это будет поле для ввода текста сообщения.\r\n            Все это помещаем в отдельный элемент \"div\".*/}\r\n                <Field component={Textarea} /*Указываем, что отрисовываем созданный нами элемент \"Textarea\", который из\r\n                себя представляет элемент \"textarea\" с возможностью указывать валидацию.*/\r\n                       name={\"newMessageText\"} /*Задаем имя данным, которые будут вводится в это поле.*/\r\n                       placeholder={\"Enter your message\"} /*Указываем текст \"placeholder\".*/\r\n                       validate={[required, maxLength10]}/> {/*Указываем, что используем два валидатора \"required\" и\r\n                       \"maxLength10\".*/}\r\n            </div>\r\n\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>Add message</button>\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"AddMessageForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"AddMessageReduxForm\" будет заниматься общением\r\nс глобальным \"state\".*/\r\nconst AddMessageReduxForm = reduxForm({\r\n    form: 'dialogAddMessageForm' /*Это то самое уникальное имя для данных этой формы, которые будут попадать\r\n    в глобальный \"state\".*/\r\n})(AddMessageForm);\r\n\r\n/*\r\n\"Dialogs\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Dialogs(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Dialogs\" является компонентом, который отображает диалоги.\r\nЭтот компонент подключается в компоненте \"DialogsContainer\".\r\nВнутри компонента \"Dialogs\" подключаются компоненты:\r\n- \"DialogItem\", который описывает, как должны выглядеть диалоги;\r\n- \"Message\", который описывает, как должны выглядеть исходящие сообщения;\r\n- \"IncomingMessage\", который описывает, как должны выглядеть входящие сообщения;\r\n- \"AddMessageReduxForm\", в котором обворачиваем компонент \"AddMessageForm\" HOC-ом \"reduxForm\",\r\nтем самым предоставляя callback \"handleSubmit\" для компонента \"AddMessageForm\".\r\n*/\r\nconst Dialogs = (props) => {\r\n    /*\r\n    В JSX в массив можно вкладывать компоненты.\r\n    В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде строки.\r\n    \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования исходного массива.\r\n    Метод \"map\" принимает стрелочную функцию.\r\n    То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n    и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    Потом будет браться следующий объект из исходного массива объектов\r\n    и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n    То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов.\r\n    В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n    Массив \"dialogsElements\" содержит диалоги пользователя.\r\n    Массив \"messagesElements\" содержит исходящие сообщения пользователя.\r\n    Массив \"incomingMessagesElement\" содержит входящие сообщения пользователя.\r\n    При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n    */\r\n    let dialogsElements = props.dialogsPage.dialogs.map(d => <DialogItem name={d.name}\r\n                                                                         id={d.id}\r\n                                                                         avatar={d.avatar}\r\n                                                                         key={d.id}/>);\r\n\r\n    let messagesElements = props.dialogsPage.messagesData.map(m => <Message id={m.id}\r\n                                                                            message={m.message}\r\n                                                                            avatar={m.avatar}\r\n                                                                            key={m.id}/>);\r\n\r\n    let incomingMessagesElement = props.dialogsPage.incomingMessagesData.map(im => <IncomingMessage id={im.id}\r\n                                                                                                   message={im.message}\r\n                                                                                                   avatar={im.avatar}\r\n                                                                                                   key={im.id}/>);\r\n\r\n    let addNewMessage = (values) => { /*Создали специальный callback \"addNewMessage\", который будет вызываться при\r\n    срабатывании события \"onSubmit\" в форме.*/\r\n        props.addMessage(values.newMessageText); /*Здесь мы вызываем AC \"addMessage\", полученный из props, и передаем\r\n        ему текст исходящего сообщения.*/\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.dialogs}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <div className={styles.dialogsItems}>{dialogsElements}</div> {/*Этот элемент \"div\" содержит список\r\n            диалогов.*/}\r\n\r\n            <div className={styles.messages}> {/*Этот элемент \"div\" содержит внутри два других элемента \"div\".*/}\r\n                <div>{messagesElements}</div> {/*Этот элемент \"div\" содержит исходящие сообщения.*/}\r\n                <AddMessageReduxForm onSubmit={addNewMessage}/> {/*Здесь в событии \"onSubmit\" будет приходить объект с\r\n                данными из callback \"handleSubmit\" из компонента \"AddMessageForm\", который обвернут\r\n                компонентом \"AddMessageReduxForm\". Далее будет вызываться при этом событии нами созданный\r\n                callback \"addNewMessage\", в который будет передаваться этот объект с данными. После этого эти данные\r\n                будут отправлятся в часть глобального \"state\", которую обрабатывает библиотека\"redux-form\", с целью\r\n                осуществления работы нашей формы логина. Поскольку мы вызываем функцию \"addNewMessage\" как callback,\r\n                поэтому не ставим \"()\" после имени функции. Но теперь после отправки сообщения окно для ввода текста\r\n                сообщения не будет очищаться, так как библиотека \"redux-form\" хоть и осуществляет FLUX-круговорот,\r\n                но очистку не осуществляет.*/}\r\n            </div>\r\n\r\n            <div className={styles.incomingMessages}>{incomingMessagesElement}</div> {/*Этот элемент \"div\" содержит\r\n            входящие сообщения.*/}\r\n        </div>\r\n    );\r\n};\r\n\r\nexport default Dialogs; /*Экспортируем компонент \"Dialogs\" по default, экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭто прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC (ХОК) - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {compose} from 'redux';\r\n/*\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и ХОКи.\r\nОбвертки и ХОКи указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\n*/\r\n\r\nimport Dialogs from './Dialogs'; /*Подключаем компонент \"Dialogs\".*/\r\n\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC \"withAuthRedirect\" для\r\nдобавления редиректа.*/\r\n\r\nimport {addMessageActionCreator} from '../../redux/dialogs-reducer'; /*Подключаем AC \"addMessageActionCreator\"\r\nиз \"dialogs-reducer\".*/\r\n\r\n\r\n/*\r\n\"DialogsContainer\" это не классовый компонент и не функциональный компонент.\r\n\"DialogsContainer\" является только контейнерным компонентом для компонента \"Dialogs\".\r\nВ отличии от классового компонента, этот компонент не имеет методов жизненного цикла.\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.js\") из библиотеки \"react-redux\".\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВ этом компоненте мы просто создаем \"mapStateToProps\" и \"mapDispatchToProps\", тем самым формируя \"props\"\r\nдля презентационной компоненты \"Dialogs\". Поэтому нам не нужно создавать классовый компонент для этого.\r\nТаким же образом созданы контейнерные компоненты \"MyPostsContainer\", \"NavbarContainer\".\r\n*/\r\n\r\nconst mapStateToProps = (state) => { /*Здесь указываются данные из \"state\", которые необходимо передать в компонент\r\n\"Dialogs\". Эта функция возвращает указанные данные в виде объекта.*/\r\n    return {\r\n        dialogsPage: state.dialogsPage,\r\n    }\r\n};\r\n\r\nconst mapDispatchToProps = (dispatch) => { /*Здесь указываются данные (\"callbacks - \"AC\" или \"TC\") \"dispatch\",\r\nкоторые необходимо передать в компонент \"Dialogs\". Эта функция возвращает указанные данные в виде объекта.\r\nФункция \"mapDispatchToProps\" работает следующим образом:\r\n1) Компонент вызывает callback функцию \"addMessage\".\r\n2) Компонент передает этой функции параметр \"newMessageText\".\r\n3) Далее этот параметр передается в AC \"addMessageActionCreator\".\r\n4) Этот AC вызывается.\r\n5) Создается объект \"action\".\r\n6) Этот объект \"action\" диспатчится в \"dialogsReducer\" в \"dialogs-reducer.js\".*/\r\n    return {\r\n        addMessage: (newMessageText) => {\r\n            dispatch(addMessageActionCreator(newMessageText));\r\n        }\r\n    }\r\n};\r\n\r\nexport default compose( /*При помощи функции \"compose\" объеденяем ХОКи \"withAuthRedirect\" и \"connect\", возвращая\r\nитоговый компонент \"AppContainer\".*/\r\n    connect(mapStateToProps, mapDispatchToProps), /*При помощи метода \"connect\" создаем контейнерный компонент,\r\n    и тем самым передаем нужные данные BLL и DAL компоненту \"Dialogs\".*/\r\n    withAuthRedirect /*При помощи ХОКа \"withAuthRedirect\" добавляем логику по редиректу в компонент.*/\r\n)(Dialogs);\r\n/*\r\nА также экспортируем получившийся в итоге компонент, который будет использоваться под именем \"DialogsContainer\",\r\nпо default, экспорт необходим для импорта.\r\n*/"],"sourceRoot":""}