{"version":3,"sources":["hoc/WithAuthRedirect.tsx","pages/Chat/ChatPage.module.css","redux/chat-selectors.ts","pages/Chat/ChatPage.tsx"],"names":["mapStateToPropsForRedirect","state","isAuth","auth","withAuthRedirect","Component","connect","props","restProps","to","module","exports","getChatMessages","chat","chatMessages","getWSStatus","WSStatus","Chat","useSelector","dispatch","useDispatch","useEffect","startGettingChatMessages","stopGettingChatMessages","className","styles","wsError","ChatMessages","chatMessagesAnchorRef","useRef","useState","isAutoScrollActive","setAutoScroll","current","scrollIntoView","behavior","onScroll","event","element","currentTarget","Math","abs","scrollHeight","scrollTop","clientHeight","map","m","index","ChatMessage","chatMessage","id","ref","React","memo","userId","src","photo","avatarSource","alt","chatMessageUserName","userName","chatMessageText","message","AddChatMessageForm","setChatMessage","placeholder","onChange","e","value","onClick","sendChatMessage","disabled","ChatPageWithAuthRedirect"],"mappings":"mNAgEMA,EAA6B,SAACC,GAAD,MAAyD,CAIxFC,OAAQD,EAAME,KAAKD,SAIhB,SAASE,EAAgCC,GA0C5C,OARqCC,YACpCN,EADoCM,EAxBrC,SAA2BC,GAUvB,IAAKL,EAAwBK,EAAxBL,OAAWM,EAAhB,YAA6BD,EAA7B,GAGA,OAAKL,EAKE,cAACG,EAAD,eAAeG,IALF,cAAC,IAAD,CAAUC,GAAI,iB,oBC9F1CC,EAAOC,QAAU,CAAC,aAAe,+BAA+B,YAAc,8BAA8B,oBAAsB,sCAAsC,gBAAkB,kCAAkC,QAAU,4B,6FCQzNC,EAAkB,SAACX,GAG5B,OAAOA,EAAMY,KAAKC,cAGTC,EAAc,SAACd,GAGxB,OAAOA,EAAMY,KAAKG,U,0CCkIhBC,EAAiB,WACnB,IAAID,EAAWE,YAAYH,GAGrBI,EAAWC,cAqBjB,OAnBAC,qBAAU,WAIN,OAFAF,EAASG,eAEF,WAGHH,EAASI,kBAGb,IAUA,oCACkB,UAAbP,GAAwB,qBAAKQ,UAAWC,IAAOC,QAAvB,4FAGrB,qCACI,cAAC,EAAD,IACA,cAAC,EAAD,WAgCdC,EAAyB,WAC3B,IAAIb,EAAeI,YAAYN,GAGzBgB,EAAwBC,iBAAuB,MAGrD,EAA4CC,oBAAkB,GAA9D,mBAAOC,EAAP,KAA2BC,EAA3B,KAyDA,OAlBAX,qBAAU,WAEmB,IAAD,EAApBU,IAIA,UAAAH,EAAsBK,eAAtB,SAA+BC,eAAe,CAACC,SAAU,cAG7D,CAACrB,IAUD,sBAAKU,UAAWC,IAAOX,aAAcsB,SApDd,SAACC,GAGxB,IAAMC,EAAUD,EAAME,cAElBC,KAAKC,IAAKH,EAAQI,aAAeJ,EAAQK,UAAaL,EAAQM,cAAgB,KAC7Eb,GAAsBC,GAAc,GAErCD,GAAsBC,GAAc,IA4CxC,cAEKlB,EAAa+B,KAAI,SAACC,EAAGC,GAAJ,OAAc,cAACC,EAAD,CAAwBC,YAAaH,GAAnBA,EAAEI,OAFxD,IAMI,qBAAKC,IAAKvB,IANd,QAiCFoB,EAAkDI,IAAMC,MAAK,YAAoB,IAAlBJ,EAAiB,EAAjBA,YAUjE,OACI,sBAAKzB,UAAWC,IAAOwB,YAAvB,cACI,eAAC,IAAD,CAASxC,GAAI,YAAcwC,EAAYK,OAAvC,cAEI,qBAAKC,IAA2B,OAAtBN,EAAYO,MAAiBP,EAAYO,MAAQC,IAAcC,IAAI,KAFjF,IAKI,uBAAMlC,UAAWC,IAAOkC,oBAAxB,cAEKV,EAAYW,SAAW,IAF5B,SAEuCX,EAAYK,OAFnD,WAMJ,uBAAM9B,UAAWC,IAAOoC,gBAAxB,cAEKZ,EAAYa,iBA2BvBC,EAA+B,WACjC,MAAsCjC,mBAAS,IAA/C,mBAAOmB,EAAP,KAAoBe,EAApB,KAKIhD,EAAWE,YAAYH,GAGrBI,EAAWC,cAoBjB,OACI,oCACI,8BACI,0BACI6C,YAAa,qBACbC,SAAU,SAACC,GAAD,OAAOH,EAAeG,EAAE5B,cAAc6B,QAGhDA,MAAOnB,EALX,iBAaJ,8BACI,yBAAQoB,QAnCG,WAIdpB,IAIL9B,EAASmD,YAAgBrB,IAEzBe,EAAe,MA0BCO,SAAuB,UAAbvD,EADlB,8BAeVwD,EAA2BpE,aA1TN,WAOvB,OACI,oCACI,cAAC,EAAD,IADJ,UAsTOoE","file":"static/js/5.a619afbc.chunk.js","sourcesContent":["/*\r\nЭто специальной созданный нами HOC для добавления редиректа в наш проект.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\n*/\r\n\r\nimport React, {ComponentType} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nИмпортируем \"ComponentType\" для типизации.\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {Redirect} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\n\"Redirect\" позволяет создавать компонент <Redirect /> для создания редиректа. Для указания пути редиректа используется\r\nатрибут \"to\".\r\nМаршрут для пути редиректа уже должен быть создан.\r\n*/\r\n\r\nimport {AppStateType} from '../redux/redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"mapStateToPropsForRedirect\". \"mapStateToPropsForRedirect\" в этом компоненте должен обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype MapStateToPropsForRedirectType = {\r\n    isAuth: boolean /*Свойство, которое указывает залогинен ли пользователь, должно быть булева типа.*/\r\n};\r\n\r\n\r\nconst mapStateToPropsForRedirect = (state:AppStateType): MapStateToPropsForRedirectType => ({ /*Здесь мы таким образом\r\nсоздали \"props\" необходимые для работы редиректа. Будем их подключать при помощи функции \"connect\". На входе\r\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\r\nданные с типом \"MapStateToPropsType\".*/\r\n    isAuth: state.auth.isAuth /*Свойство, которое указывает залогинен ли пользователь.*/\r\n});\r\n\r\n\r\nexport function withAuthRedirect<WrappedProps> (Component: ComponentType<WrappedProps>) { /*Это и есть наш HOC, который\r\nв качестве параметра принимает какой-либо компонент \"Component\". Не используем здесь синтаксис стрелочной функции, чтобы\r\nможно было уточнить \"props\" как \"WrappedProps\", как мы это сделали здесь.\r\n\r\nЭтот HOC принимает какой-то \"generic\" компонент \"Component\", который ожидает \"props\" c типом \"WrappedProps\". Компонент\r\n\"Component\" должен быть типа \"ComponentType\", то есть быть каким-то компонентом из \"ReactJS\".\r\n\r\nУточняем, что внутри ожидаются \"props\" c типом \"WrappedProps\", то есть теже \"props\" компонента \"Component\", который мы\r\nбудем передавать в этот HOC, так как наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\".\r\nНо при этом наш HOC будет использовать свойство \"isAuth\" из \"mapStateToPropsForRedirect\" для своей внутренней работы.*/\r\n    function RedirectComponent(props: MapStateToPropsForRedirectType) { /*После получения компонента \"Component\" в\r\n    качестве параметра, создается другой функциональный компонент \"RedirectComponent\". Это обвертка для компонента\r\n    \"Component\", поэтому \"props\" компонента \"RedirectComponent\" должны быть типа \"WrappedProps\", так как эти \"props\"\r\n    должны не потеряться и быть переданы в компонент \"Component\", и типа \"MapStateToPropsForRedirectType\", так как для\r\n    работы компонента \"RedirectComponent\" необходимо свойство \"isAuth\" из \"mapStateToPropsForRedirect\". Но свойство\r\n    \"isAuth\" мы не должны передавать в компонент \"Component\".\r\n\r\n    Но для функции \"connect\" и для внутренней работы компонента \"RedirectComponent\" важно знать только \"props\" типа\r\n    \"MapStateToPropsForRedirectType\", поэтому в итоге мы убираем \"WrappedProps\" здесь и оставляем только\r\n    \"MapStateToPropsForRedirectType\" в качестве типа для \"props\" компонента \"RedirectComponent\".*/\r\n        let {isAuth, ...restProps} = props; /*Здесь мы выделили \"props.isAuth\" в переменную \"isAuth\", а остальные\r\n        свойства \"props\" оставили в объекте \"restProps\" при помощи деструктуризации.*/\r\n\r\n        if (!isAuth) return <Redirect to={'/login/'}/> /*Внутри этого функционального компонента \"RedirectComponent\"\r\n        указано, что если пользователь не залогинен, то происходит при помощи \"Redirect\" из библиотеки\r\n        \"react-routed-dom\" редирект по пути \"/login/\", где находится форма для логинизации, вместо отрисовки переданного\r\n        в HOC компонента \"Component\".*/\r\n\r\n        return <Component {...restProps as WrappedProps}/> /*Если же пользователь оказался залогиненным, то мы попадем в\r\n        этот \"return\". В этом случае возвращается компонент \"Component\", который был передан в HOC, при помощи\r\n        деструктуризации снабженный \"restProps\", которые должны восприниматься как \"props\" типа \"WrappedProps\", то есть\r\n        теми же \"props\", что у него были изначально, так как выше мы убрали свойство \"isAuth\" из них.*/\r\n    };\r\n\r\n    let ConnectedAuthRedirectComponent = connect<MapStateToPropsForRedirectType, {}, WrappedProps, AppStateType>\r\n    (mapStateToPropsForRedirect)(RedirectComponent); /*Далее в свою очередь функциональный компонент \"RedirectComponent\"\r\n    обворачивается при помощи метода \"connect\", чтобы получить необходимые \"props\" для проверки залогинен ли\r\n    пользователь или нет. Метод \"connect\" вернет новый компонент \"ConnectedAuthRedirectComponent\". Поскольку метод\r\n    \"connect\" является \"generic\", то его можно уточнить: первым в \"<>\" указан тип для \"MapStateToProps\", вторым для\r\n    \"MapDispatchToProps\", третьим для \"собственных props\" компонента, четвертым для \"state\". Эти параметры мы узнали\r\n    перейдя в файл декларации метода \"connect\", \"Ctrl+click\" в \"WebStorm\".*/\r\n\r\n    return ConnectedAuthRedirectComponent; /*Сам HOC \"withAuthRedirect\" возвращает итоговый компонент\r\n    \"ConnectedAuthRedirectComponent\".*/\r\n};\r\n","// extracted by mini-css-extract-plugin\nmodule.exports = {\"chatMessages\":\"ChatPage_chatMessages__1FYTM\",\"chatMessage\":\"ChatPage_chatMessage__g-_n9\",\"chatMessageUserName\":\"ChatPage_chatMessageUserName__2gki_\",\"chatMessageText\":\"ChatPage_chatMessageText__GTZxJ\",\"wsError\":\"ChatPage_wsError__xvOuF\"};","/*\r\nСелектор - это функция, которая принимает \"state\", достает из него то, что ей нужно и возвращает это в BLL.\r\nСелекторы осуществляют определенную выборку данных из \"state\".\r\nЗдесь содержаться селекторы для данных из \"auth-reducer.ts\".\r\n*/\r\n\r\nimport {AppStateType} from './redux-store'; /*Подключаем типы.*/\r\n\r\n\r\nexport const getChatMessages = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает информацию о сообщениях из чата для вывода их в нашем приложении. На входе этот селектор принимает \"state\" с\r\nтипом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.chat.chatMessages\r\n};\r\n\r\nexport const getWSStatus = (state: AppStateType) => { /*Это созданный нами без библиотеки \"reselect\" селектор. Он\r\nвозвращает статус готовности WebSocket-канала для отправки информации по нему. На входе этот селектор принимает \"state\"\r\nс типом \"AppStateType\", который мы создали и импортировали сюда.*/\r\n    return state.chat.WSStatus\r\n};","import React, {useEffect, useRef, useState} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nКлассовый компонент позволяет реализовать локальный \"state\" (смотри \"ProfileStatus\") и методы\r\nжизненного цикла (\"componentDidMount\" и т.д.), а функциональный компонент этого не может делать.\r\nТакие возможности классового компонента были созданы благодаря тому, что \"React\" на основе класса\r\nсоздает объект и всякий раз взаимодействует с этим объектом. А поскольку это объект, значит может\r\nхранить такие вещи как \"state\" и методы. Функция же просто вызывается и возвращает \"JSX\", постоянное\r\nобщение с функциональным компонентом так просто не организовать. Объект живет в памяти, а функция отработала\r\nи удалилась. Для решения этой проблемы в функциональных компонентах были созданы \"Hooks\" (хуки).\r\n\"Hook\" - это функция, которая может делать side effects.\r\n\"React\" когда вызывает функциональную компоненту, в которой есть хуки, он запоминает вызов этих хуков и\r\nэтой функции для того, чтобы потом соотносить side effects, созданные этими хуками. В отличие от классового компонента\r\n\"React\" запоминает эту информацию где-то на своей стороне, а не внутри объекта.\r\nХуки нельзя писать в условиях и циклах.\r\nМожно писать свои кастомные хуки.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\nПодключаем хук \"useEffect\", который принимает функцию первым параметром и выполняет ее, когда произойдет\r\nотрисовка компонента, то есть после каждого вызова \"render\". Вторым параметром этот хук принимает зависимости -\r\nзависимо от чьих изменений будет срабатывать хук, если передать туда пустой массив (так лучше не делать), то\r\nэтот хук сработает только один раз. Этот хук используется для side effects.\r\nПодключаем хук \"useState\", который возвращает массив с двуми элементами. Первый элемент - это значение,\r\nкоторое хранится в \"state\". Второй элемент - это функция, которая будет изменять это значение в первом элементе. Изменяя\r\nпервый элемент мы заставляем \"React\" перерисовывать функциональный компонент.\r\n\"Refs\" дают возможность получить доступ к DOM-узлам или React-элементам. Ситуациями, в которых использование рефов\r\nявляется оправданным, являются управление фокусом, выделение текста, воспроизведение медиа, императивный вызов анимаций,\r\nинтеграция со сторонними DOM-библиотеками. Рефы прикрепляются к React-элементам через атрибут \"ref\". Хук \"useRef\"\r\nвозвращает изменяемый ref-объект, свойство \"current\" которого инициализируется переданным аргументом, то есть\r\n\"initialValue\". Возвращенный объект будет сохраняться в течение всего времени жизни компонента.\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\nimport {useDispatch, useSelector} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux). Эта прослойка необходима потому, что UI\r\nнежелательно общаться с BLL напрямую. Библиотека \"react-redux\" предоставляет продвинутые инструкции по созданию\r\nконтейнерных компонент и контекста.\r\n\"useSelector\" - это hook, который принимает селектор и возвращает данные, которые возвращает этот селектор.\r\n\"useDispatch\" - это hook, который принимает AC или TC и диспатчит их.\r\n*/\r\n\r\nimport {\r\n    sendChatMessage, /*Подключаем TC \"sendChatMessage\" из \"chat-reducer.ts\".*/\r\n    startGettingChatMessages, /*Подключаем TC \"startGettingChatMessages\" из \"chat-reducer.ts\".*/\r\n    stopGettingChatMessages /*Подключаем TC \"stopGettingChatMessages\" из \"chat-reducer.ts\".*/\r\n} from '../../redux/chat-reducer';\r\n\r\nimport {\r\n    getChatMessages, /*Импортируем селектор, который возвращает информацию о сообщениях из чата для вывода их в нашем\r\n    приложении.*/\r\n    getWSStatus /*Импортируем селектор, который возвращает статус готовности WebSocket-канала для отправки информации по\r\n    нему.*/\r\n} from '../../redux/chat-selectors';\r\n\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC \"withAuthRedirect\" для\r\nдобавления редиректа.*/\r\n\r\nimport {ChatMessageAPIType} from '../../api/chat-api'; /*Подключаем типы.*/\r\n\r\nimport styles from './ChatPage.module.css'; /*Подключаем стили из CSS-модуля.*/\r\nimport avatarSource from '../../assets/images/user.png'; /*Импортируем из ассетов проекта аватар пользователя.*/\r\n\r\n\r\n/*Создаем тип для \"props\" компонента \"ChatMessage\". \"Props\" в этом компоненте должны обязательно содержать следующие\r\nполя с указанными типами. Все это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype ChatMessageComponentType = {\r\n    chatMessage: ChatMessageAPIType /*Данные о сообщении из чата должны быть типа \"ChatMessageType\", который мы создали\r\n    выше.*/\r\n};\r\n\r\n\r\n/*\r\n\"ChatPage\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ChatPage(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ChatPage\" является компонентом, который является финальным компонентом, который собирает компоненты, необходимые для\r\nреализации чата в нашем приложении.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВнутри компонента \"ChatPage\" подключаются компонент \"Chat\", который содержит в себе компоненты, отвечающие за вывод\r\nсообщения из чата и формы для добавления сообщения в чат.\r\n*/\r\nconst ChatPage: React.FC = () => {\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <Chat/> {/*Отрисовываем компонент \"Chat\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n/*\r\n\"Chat\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Chat(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Chat\" является компонентом, который содержит в себе компоненты, отвечающие за вывод сообщений из чата и формы для\r\nдобавления сообщения в чат.\r\nЭтот компонент подключается в компоненте \"ChatPage\".\r\nВнутри компонента \"Chat\" подключаются компоненты:\r\n- \"ChatMessages\", который отображает сообщения чата;\r\n- \"AddChatMessageForm\", который отвечает за отображение формы для добавления сообщения в чат.\r\n*/\r\nconst Chat: React.FC = () => {\r\n    let WSStatus = useSelector(getWSStatus); /*При помощи хука \"useSelector\", передав в него селектор \"getWSStatus\",\r\n    получаем статус готовности WebSocket-канала для отправки информации по нему.*/\r\n\r\n    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука \"useDispatch\".*/\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы при отрисовке компонента инициализировать\r\n    WebSocket-канал и начать получать по нему сообщения для чата при помощи TC \"startGettingChatMessages\".*/\r\n        dispatch(startGettingChatMessages());\r\n\r\n        return () => { /*Когда мы выйдем из этого компонента, мы должны закрыть WebSocket-канал и остановить получение\r\n        информации по сообщениям для чата, которые получались через этот WebSocket-канал, при помощи TC\r\n        \"stopGettingChatMessages\". Это называется \"cleanup\" функцией.*/\r\n            dispatch(stopGettingChatMessages());\r\n        };\r\n    },\r\n        [] /*Второй параметр это пустой массив, так как мы хотим, чтобы все, что есть в первом параметре сработало\r\n        только один раз после отрисовки компонента.*/\r\n    );\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            {WSStatus === 'error' && <div className={styles.wsError}>\r\n                Some error occurred. Please refresh the page or check your Internet-connection\r\n            </div>}\r\n                <>\r\n                    <ChatMessages/>\r\n                    <AddChatMessageForm/>\r\n                </>\r\n            {/*Если статус готовности WebSocket-канала для отправки информации по нему равен \"error\", то отрисуются\r\n            элемент \"div\" с сообщением об ошибке вместе с компонентами \"ChatMessages\" и \"AddChatMessageForm\", иначе\r\n            отрисуются только эти два компонента.*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n/*\r\n\"ChatMessages\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ChatMessages(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ChatMessages\" является компонентом, который отображает сообщения чата.\r\nЭтот компонент подключается в компоненте \"Chat\".\r\nВнутри компонента \"ChatMessages\" подключаются компонент \"ChatMessage\", который отвечает за типовое отображения одного\r\nсообщения в чате.\r\n*/\r\nconst ChatMessages: React.FC = () => {\r\n    let chatMessages = useSelector(getChatMessages); /*При помощи хука \"useSelector\", передав в него селектор\r\n    \"getChatMessages\", получаем информацию о сообщениях из чата для вывода их в нашем приложении.*/\r\n\r\n    const chatMessagesAnchorRef = useRef<HTMLDivElement>(null); /*При помощи хука \"useRef\" создаем \"ref\"\r\n    типа \"HTMLDivElement\", то есть элемент \"div\", который изначально равен \"null\".*/\r\n\r\n    const [isAutoScrollActive, setAutoScroll] = useState<boolean>(true); /*При помощи деструктуризирующего\r\n    присваивания создали две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент\r\n    будет означать активна ли автопрокрутка чата в какой-то момент или нет (изначально активна). Вторая переменная будет\r\n    хранить функцию из хука \"useState\", которая будет изменять первый элемент (то есть указывать активна ли\r\n    автопрокрутка чата в какой-то момент или нет).*/\r\n\r\n    const scrollEventHandler = (event: React.UIEvent<HTMLDivElement, UIEvent>) => { /*Создаем специальную\r\n    callback-функцию, которая будет вызываться снизу в корневом элементе \"div\" при срабатывании события \"onScroll\", то\r\n    в моменты прокрутки нашего чата. На входе принимает событие типа \"React.UIEvent<HTMLDivElement, UIEvent>\".*/\r\n        const element = event.currentTarget; /*Получаем свойство \"currentTarget\" полученного события.*/\r\n\r\n        if (Math.abs((element.scrollHeight - element.scrollTop) - element.clientHeight) < 200) {\r\n            !isAutoScrollActive && setAutoScroll(true);\r\n        } else {\r\n            isAutoScrollActive && setAutoScroll(false);\r\n        };/*Свойство \"scrollHeight\" это измерение высоты контента в элементе, включая содержимое, невидимое из-за\r\n        прокрутки. Значение свойства \"scrollHeight\" равно минимальному значению свойства \"clientHeight\", которое\r\n        потребуется элементу для того, чтобы поместить все содержимое в видимую область, не используя вертикальную\r\n        полосу прокрутки. Оно включает в себя \"padding\" элемента, но не его \"margin\".\r\n\r\n        Свойство \"scrollTop\" считывает или устанавливает количество пикселей, прокрученных от верха элемента. Свойство\r\n        \"scrollTop\" измеряет дистанцию от верха элемента до верхней точки видимого контента. Когда контент элемента не\r\n        создает вертикальную прокрутку, его свойство \"scrollTop\" равно \"0\".\r\n\r\n        Свойство \"clientHeight\" - это свойство, доступное только для чтения. Для элементов без CSS-стилей, или элементов\r\n        каркаса строчной разметки - значение равно \"0\". Для остальных элементов - значение равно внутренней высоте\r\n        элемента в пикселях, включая пространство между содержимым элемента и его границей (\"padding\"), но исключая\r\n        высоту полосы горизонтальной прокрутки, и ширину отступа от границы элемента до родительского элемента\r\n        (\"margin\"). Значение свойства \"clientHeight\" может быть вычислено по формуле:\r\n        \"CSS height\" + \"CSS padding\" - \"высота горизонтального скролла (если присутствует)\".\r\n\r\n        Здесь мы сначала высчитываем высоту того, что ниже верхней границы контента, который мы видим в чате, по модулю\r\n        при помощи функции \"Math.abs\". Далее вычисляем высоту контента, который ниже нижней границы контента, который мы\r\n        видим в чате. И если это полученное значение меньше 200 пикселей и автопрокрутка чата отключена, то мы включаем\r\n        эту автопрокрутку. Если же полученное значение больше 200 пикселей и автопрокрутка чата включена, то мы\r\n        выключаем эту автопрокрутку, чтобы чат постоянно не прокручивался вниз, когда мы что-то читаем сверху чата.\r\n        */\r\n    };\r\n\r\n    useEffect(() => { /*Используем хук \"useEffect\", чтобы при получении новых сообщений автоматически прокручивать\r\n    вниз, чтобы было видно новое сообщение.*/\r\n        if (isAutoScrollActive) { /*Метод \"scrollIntoView()\" прокручивает текущий контейнер родителя элемента так,\r\n        чтобы этот элемент, на котором был вызван метод \"scrollIntoView()\" был видим пользователю. Если автопрокрутка\r\n        включена, то у рефа \"chatMessagesAnchorRef\" вызывается метод \"scrollIntoView()\", чтобы чат прокручивался до\r\n        элемента с этим рефом. Параметр \"behavior\" в данном случае определяет плавную анимацию прокрутки.*/\r\n            chatMessagesAnchorRef.current?.scrollIntoView({behavior: 'smooth'});\r\n        };\r\n    },\r\n        [chatMessages] /*Второй параметр это сообщения для чата из глобального \"state\". Если эти данные будут\r\n        меняться, то будет срабатывать каждый раз все то, что указано в первом параметре.*/\r\n    );\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.chatMessages} onScroll={scrollEventHandler}> {/*Этот элемент \"div\" и есть наш корневой\r\n        элемент.*/}\r\n            {chatMessages.map((m, index) => <ChatMessage key={m.id} chatMessage={m}/>)} {/*Мапим\r\n            массив с сообщениями из чата, чтобы в итоге отрисовать каждое сообщение, используя компонент \"ChatMessage\".\r\n            Внутрь этого компонента передаем информацию о сообщении через атрибут \"chatMessage\".*/}\r\n\r\n            <div ref={chatMessagesAnchorRef}></div> {/*После всех сообщений чата отрисовываем специальный элемент \"div\",\r\n            который содержит атрибут \"ref\". Это нам нужно, чтобы реализовать прокрутку в самый низ чата.*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\n/*\r\n\"ChatMessage\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function ChatMessage(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"ChatMessage\" является компонентом, который отвечает за типовое отображение сообщения в чате.\r\nЭтот компонент подключается в компоненте \"ChatMessages\".\r\n*/\r\nconst ChatMessage: React.FC<ChatMessageComponentType> = React.memo(({chatMessage}) => { /*Указываем какие\r\nименно \"props\" мы получаем, чтобы не писать далее \"props.chatMessage\". Указали при помощи \"React.FC<>\", что \"props\" в\r\nэтом функциональном компоненте имеют тип \"ChatMessageComponentType\". Для оптимизации лишних отрисовок мы обворачиваем\r\nэтот функциональный компонент при помощи \"React.memo()\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.chatMessage}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <NavLink to={'/profile/' + chatMessage.userId}> {/*Создаем маршрут для пути перехода на страницу выбранного\r\n            пользователя. Отрисуется компонент \"Profile\".*/}\r\n                <img src={chatMessage.photo !== null ? chatMessage.photo : avatarSource} alt=''/> {/*Отображаем аватар\r\n                пользователя, если его нет, то подгружаем дефолтный аватар из проекта приложения.*/}\r\n\r\n                <span className={styles.chatMessageUserName}> {/*При помощи элемента \"span\" выводим имя пользователя и\r\n                его \"ID\".*/}\r\n                    {chatMessage.userName + ' '} (id: {chatMessage.userId}):\r\n                </span>\r\n            </NavLink>\r\n\r\n            <span className={styles.chatMessageText}> {/*При помощи элемента \"span\" выводим сообщение пользователя в\r\n            чат.*/}\r\n                {chatMessage.message}\r\n            </span>\r\n        </div>\r\n    )\r\n});\r\n\r\n\r\n/*\r\n\"AddChatMessageForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function AddChatMessageForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"AddChatMessageForm\" является компонентом, который отвечает за отображение формы для добавления сообщения в чат.\r\nЭтот компонент подключается в компоненте \"App\".\r\n*/\r\nconst AddChatMessageForm: React.FC = () => {\r\n    const [chatMessage, setChatMessage] = useState(''); /*При помощи деструктуризирующего присваивания создали\r\n    две переменные. Первая переменная будет хранить первый элемент из хука \"useState\", этот элемент будет означать\r\n    введенный текст сообщения для чата (изначально пустой). Вторая переменная будет хранить функцию из хука \"useState\",\r\n    которая будет изменять первый элемент (то есть указывать текст сообщения для чата).*/\r\n\r\n    let WSStatus = useSelector(getWSStatus); /*При помощи хука \"useSelector\", передав в него селектор \"getWSStatus\",\r\n    получаем статус готовности WebSocket-канала для отправки информации по нему.*/\r\n\r\n    const dispatch = useDispatch(); /*Делаем это для более краткого использования хука \"useDispatch\".*/\r\n\r\n    const addChatMessage = () => { /*Создали специальную функцию \"addChatMessage\", которая будет вызываться при нажатии\r\n    на кнопку для отправки сообщения в чат, проверять есть ли введенный текст, и если есть, то будет отправлять этот\r\n    текст в WebSocket-канал (если таковой имеется) при помощи TC \"sendChatMessage\", а после отправки занулять введеный\r\n    текст сообщения в форме.*/\r\n        if (!chatMessage) {\r\n            return;\r\n        };\r\n\r\n        dispatch(sendChatMessage(chatMessage));\r\n\r\n        setChatMessage('');\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <div>\r\n                <textarea /*Отрисовываем элемент \"textarea\" для ввода текста сообщения для чата.*/\r\n                    placeholder={'Enter your message'}\r\n                    onChange={(e) => setChatMessage(e.currentTarget.value)} /*При изменении\r\n                    этого поля будет вызываться функция \"setChatMessage\" из хука \"useState\" выше для получения\r\n                    введенного текста в поле.*/\r\n                    value={chatMessage}> {/*Используя атрибут \"value\", указываем, что в этом поле отображается текст,\r\n                    который мы ввели, который прошел через FLUX-круговорот, благодаря хуку \"useState\" (то есть текст в\r\n                    поле меняется в ответ на изменения переменной \"chatMessage\", которая меняется функцией\r\n                    \"setChatMessage\", которая в свою очередь вызывается каждый раз, когда мы что-то меняем в поле для\r\n                    ввода текста).*/}\r\n                </textarea>\r\n            </div>\r\n\r\n            <div>\r\n                <button onClick={addChatMessage}\r\n                        disabled={WSStatus !== 'ready'}> {/*Отрисовываем элемент \"button\". При нажатии на кнопку будет\r\n                        срабатывать функция \"addChatMessage\", которую мы создали выше, с целью отправки введенного\r\n                        сообщения в WebSocket-канал, и для дальнейшей очистки этого текста сообщения после отправки\r\n                        этого сообщения. Также поскольку есть вероятность того, что мы попробуем отправить сообщение\r\n                        раньше, чем установится WebSocket-канал, то мы отключаем кнопку на случай если этот канал еще не\r\n                        в готовом состоянии для отправки информации по нему.*/}\r\n                    Send\r\n                </button>\r\n            </div>\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nconst ChatPageWithAuthRedirect = withAuthRedirect(ChatPage); /*При помощи HOC \"withAuthRedirect\" добавляем логику по\r\nредиректу в компонент \"ChatPage\".*/\r\n\r\n\r\nexport default ChatPageWithAuthRedirect; /*Экспортируем компонент \"ChatPageWithAuthRedirect\" по default и будем его\r\nиспользовать в нашем проекте под именем \"ChatPage\", экспорт необходим для импорта.*/"],"sourceRoot":""}