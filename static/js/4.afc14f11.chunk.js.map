{"version":3,"sources":["components/Dialogs/Dialogs.module.css","hoc/WithAuthRedirect.tsx","components/Dialogs/DialogItem/DialogItem.tsx","components/Dialogs/Message/Message.tsx","components/Dialogs/IncomingMessage/IncomingMessage.tsx","components/Dialogs/Dialogs.tsx","components/Dialogs/DialogsContainer.tsx"],"names":["module","exports","mapStateToPropsForRedirect","state","isAuth","auth","withAuthRedirect","Component","connect","props","restProps","to","DialogItem","id","name","avatar","path","className","styles","dialog","src","alt","activeClassName","active","Message","message","IncomingMessage","incomingMessage","maxLength10","maxLengthCreator","AddMessageReduxForm","reduxForm","form","handleSubmit","onSubmit","createField","Textarea","required","Dialogs","dialogsPage","addMessage","dialogsElements","dialogs","map","d","messagesElements","messagesData","m","incomingMessagesElement","incomingMessagesData","im","dialogsItems","messages","formData","newMessageText","incomingMessages","compose","dialogsAC"],"mappings":"qGACAA,EAAOC,QAAU,CAAC,QAAU,yBAAyB,aAAe,8BAA8B,OAAS,wBAAwB,OAAS,wBAAwB,SAAW,0BAA0B,iBAAmB,kCAAkC,QAAU,yBAAyB,gBAAkB,mC,kIC+D7SC,EAA6B,SAACC,GAAD,MAAyD,CAIxFC,OAAQD,EAAME,KAAKD,SAIhB,SAASE,EAAgCC,GA0C5C,OARqCC,YACpCN,EADoCM,EAxBrC,SAA2BC,GAUvB,IAAKL,EAAwBK,EAAxBL,OAAWM,EAAhB,YAA6BD,EAA7B,GAGA,OAAKL,EAKE,cAACG,EAAD,eAAeG,IALF,cAAC,IAAD,CAAUC,GAAI,iB,6HCZ3BC,EA7ByB,SAAC,GAAwB,IAAvBC,EAAsB,EAAtBA,GAAIC,EAAkB,EAAlBA,KAAMC,EAAY,EAAZA,OAO5CC,EAAO,YAAcH,EAQzB,OACI,sBAAKI,UAAWC,IAAOC,OAAvB,cAGI,qBAAKC,IAAKL,EAAQM,IAAI,KAH1B,IAMI,cAAC,IAAD,CAASV,GAAIK,EAAMM,gBAAiBJ,IAAOK,OAA3C,SAAoDT,IANxD,QCFOU,EA1BsB,SAAC,GAAuB,IAAtBC,EAAqB,EAArBA,QAASV,EAAY,EAAZA,OAY5C,OACI,sBAAKE,UAAWC,IAAOO,QAAvB,cAGI,qBAAKL,IAAKL,EAAQM,IAAI,MAH1B,IAMKI,EANL,QCaOC,EA1B8B,SAAC,GAAuB,IAAtBD,EAAqB,EAArBA,QAASV,EAAY,EAAZA,OAYpD,OACI,sBAAKE,UAAWC,IAAOS,gBAAvB,cAGKF,EAHL,IAMI,qBAAKL,IAAKL,EAAQM,IAAI,MAN1B,QCsDFO,EAAcC,YAAiB,IA6E/BC,EAAsBC,YAAgE,CAOxFC,KAAM,wBAPkBD,EApDxB,SAAC,GAAoB,IAAnBE,EAAkB,EAAlBA,aA6BF,OACI,uBAAMC,SAAUD,EAAhB,cAEI,oCAEKE,YACA,qBAAsB,iBAAkBC,IAAU,CAACC,IAAUT,OAKlE,oCAEI,0DAmIDU,EAnF6B,SAAC,GAA+B,IAA9BC,EAA6B,EAA7BA,YAAaC,EAAgB,EAAhBA,WA4BnDC,EAAkBF,EAAYG,QAAQC,KAAI,SAAAC,GAAC,OAAI,cAAC,EAAD,CAAY9B,KAAM8B,EAAE9B,KACFD,GAAI+B,EAAE/B,GACNE,OAAQ6B,EAAE7B,QACL6B,EAAE/B,OAExEgC,EAAmBN,EAAYO,aAAaH,KAAI,SAAAI,GAAC,OAAI,cAAC,EAAD,CAASlC,GAAIkC,EAAElC,GACAY,QAASsB,EAAEtB,QACXV,OAAQgC,EAAEhC,QACLgC,EAAElC,OAE3EmC,EAA0BT,EAAYU,qBAAqBN,KAAI,SAAAO,GAAE,OAAI,cAAC,EAAD,CAAiBrC,GAAIqC,EAAGrC,GACFY,QAASyB,EAAGzB,QACZV,OAAQmC,EAAGnC,QACNmC,EAAGrC,OAiBvG,OACI,sBAAKI,UAAWC,IAAOwB,QAAvB,cACI,qBAAKzB,UAAWC,IAAOiC,aAAvB,SAAsCV,IAD1C,IAII,sBAAKxB,UAAWC,IAAOkC,SAAvB,cACI,8BAAMP,IADV,IAEI,cAACf,EAAD,CAAqBI,SAtBb,SAACmB,GAKjBb,EAAWa,EAASC,gBAEpBD,EAASC,eAAiB,MAatB,OAaA,qBAAKrC,UAAWC,IAAOqC,iBAAvB,SAA0CP,IAjB9C,Q,kBC/KOQ,sBAKXhD,aAfoB,SAACL,GAIrB,MAAO,CACHoC,YAAapC,EAAMoC,eAWnB,CAACC,WAAYiB,IAAUjB,aAK3BlC,IAXWkD,CAYblB","file":"static/js/4.afc14f11.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"dialogs\":\"Dialogs_dialogs__1Sptc\",\"dialogsItems\":\"Dialogs_dialogsItems__rEKAE\",\"active\":\"Dialogs_active__1PaZd\",\"dialog\":\"Dialogs_dialog__2SGJR\",\"messages\":\"Dialogs_messages__lyiGR\",\"incomingMessages\":\"Dialogs_incomingMessages__1g53F\",\"message\":\"Dialogs_message__1BlRt\",\"incomingMessage\":\"Dialogs_incomingMessage__hrgPD\"};","/*\r\nЭто специальной созданный нами HOC для добавления редиректа в наш проект.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\n*/\r\n\r\nimport React, {ComponentType} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nИмпортируем \"ComponentType\" для типизации.\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {Redirect} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\n\"Redirect\" позволяет создавать компонент <Redirect /> для создания редиректа. Для указания пути редиректа используется\r\nатрибут \"to\".\r\nМаршрут для пути редиректа уже должен быть создан.\r\n*/\r\n\r\nimport {AppStateType} from '../redux/redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"mapStateToPropsForRedirect\". \"mapStateToPropsForRedirect\" в этом компоненте должен обязательно\r\nсодержать следующие поля с указанными типами.*/\r\ntype MapStateToPropsForRedirectType = {\r\n    isAuth: boolean /*Свойство, которое указывает залогинен ли пользователь, должно быть булева типа.*/\r\n};\r\n\r\n\r\nconst mapStateToPropsForRedirect = (state:AppStateType): MapStateToPropsForRedirectType => ({ /*Здесь мы таким образом\r\nсоздали \"props\" необходимые для работы редиректа. Будем их подключать при помощи функции \"connect\". На входе\r\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\r\nданные с типом \"MapStateToPropsType\".*/\r\n    isAuth: state.auth.isAuth /*Свойство, которое указывает залогинен ли пользователь.*/\r\n});\r\n\r\n\r\nexport function withAuthRedirect<WrappedProps> (Component: ComponentType<WrappedProps>) { /*Это и есть наш HOC, который\r\nв качестве параметра принимает какой-либо компонент \"Component\". Не используем здесь синтаксис стрелочной функции, чтобы\r\nможно было уточнить \"props\" как \"WrappedProps\", как мы это сделали здесь.\r\n\r\nЭтот HOC принимает какой-то \"generic\" компонент \"Component\", который ожидает \"props\" c типом \"WrappedProps\". Компонент\r\n\"Component\" должен быть типа \"ComponentType\", то есть быть каким-то компонентом из \"ReactJS\".\r\n\r\nУточняем, что внутри ожидаются \"props\" c типом \"WrappedProps\", то есть теже \"props\" компонента \"Component\", который мы\r\nбудем передавать в этот HOC, так как наш HOC не будет снабжать новыми данными переданный в него компонент \"Component\".\r\nНо при этом наш HOC будет использовать свойство \"isAuth\" из \"mapStateToPropsForRedirect\" для своей внутренней работы.*/\r\n    function RedirectComponent(props: MapStateToPropsForRedirectType) { /*После получения компонента \"Component\" в\r\n    качестве параметра, создается другой функциональный компонент \"RedirectComponent\". Это обвертка для компонента\r\n    \"Component\", поэтому \"props\" компонента \"RedirectComponent\" должны быть типа \"WrappedProps\", так как эти \"props\"\r\n    должны не потеряться и быть переданы в компонент \"Component\", и типа \"MapStateToPropsForRedirectType\", так как для\r\n    работы компонента \"RedirectComponent\" необходимо свойство \"isAuth\" из \"mapStateToPropsForRedirect\". Но свойство\r\n    \"isAuth\" мы не должны передавать в компонент \"Component\".\r\n\r\n    Но для функции \"connect\" и для внутренней работы компонента \"RedirectComponent\" важно знать только \"props\" типа\r\n    \"MapStateToPropsForRedirectType\", поэтому в итоге мы убираем \"WrappedProps\" здесь и оставляем только\r\n    \"MapStateToPropsForRedirectType\" в качестве типа для \"props\" компонента \"RedirectComponent\".*/\r\n        let {isAuth, ...restProps} = props; /*Здесь мы выделили \"props.isAuth\" в переменную \"isAuth\", а остальные\r\n        свойства \"props\" оставили в объекте \"restProps\" при помощи деструктуризации.*/\r\n\r\n        if (!isAuth) return <Redirect to={'/login/'}/> /*Внутри этого функционального компонента \"RedirectComponent\"\r\n        указано, что если пользователь не залогинен, то происходит при помощи \"Redirect\" из библиотеки\r\n        \"react-routed-dom\" редирект по пути \"/login/\", где находится форма для логинизации, вместо отрисовки переданного\r\n        в HOC компонента \"Component\".*/\r\n\r\n        return <Component {...restProps as WrappedProps}/> /*Если же пользователь оказался залогиненным, то мы попадем в\r\n        этот \"return\". В этом случае возвращается компонент \"Component\", который был передан в HOC, при помощи\r\n        деструктуризации снабженный \"restProps\", которые должны восприниматься как \"props\" типа \"WrappedProps\", то есть\r\n        теми же \"props\", что у него были изначально, так как выше мы убрали свойство \"isAuth\" из них.*/\r\n    };\r\n\r\n    let ConnectedAuthRedirectComponent = connect<MapStateToPropsForRedirectType, {}, WrappedProps, AppStateType>\r\n    (mapStateToPropsForRedirect)(RedirectComponent); /*Далее в свою очередь функциональный компонент \"RedirectComponent\"\r\n    обворачивается при помощи метода \"connect\", чтобы получить необходимые \"props\" для проверки залогинен ли\r\n    пользователь или нет. Метод \"connect\" вернет новый компонент \"ConnectedAuthRedirectComponent\". Поскольку метод\r\n    \"connect\" является \"generic\", то его можно уточнить: первым в \"<>\" указан тип для \"MapStateToProps\", вторым для\r\n    \"MapDispatchToProps\", третьим для \"собственных props\" компонента, четвертым для \"state\". Эти параметры мы узнали\r\n    перейдя в файл декларации метода \"connect\", \"Ctrl+click\" в \"WebStorm\".*/\r\n\r\n    return ConnectedAuthRedirectComponent; /*Сам HOC \"withAuthRedirect\" возвращает итоговый компонент\r\n    \"ConnectedAuthRedirectComponent\".*/\r\n};\r\n","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {NavLink} from 'react-router-dom';\r\n/*\r\nБиблиотека \"react-router-dom\" необходима для создания роутинга и маршрутов в приложении.\r\nПодключаем \"NavLink\", который является аналогом элемента \"a\" из HTML, хотя в браузере в итоге все равно будет\r\nотображаться элемент \"a\".\r\nНо \"NavLink\" не перезагружает все приложение в отличии от обычного использования элемента \"a\", то есть \"NavLink\"\r\nотменяет действие по умолчанию элемента \"a\".\r\n\"NavLink\" используется для перемещения по \"Route\" маршрутам.\r\n\"NavLink\" вместо атрибута \"href\" использует атрибут \"to\".\r\n\"NavLink\" добавляет атрибует \"class\" со значением \"active\" к элементу \"a\", когда осуществляется переход по ссылке.\r\nНо класс \"active\" нам не подходит, посколько React добавляет уникальный префиксы и суффиксы к значению класса из-за\r\nиспользования CSS-модуля.\r\nАтрибут \"activeClassName\" позволяет указывать какой именно класс добавляется к элементу \"a\" вместо класса \"active\".\r\n*/\r\n\r\nimport styles from './../Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {AvatarSourceType} from '../../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    id: number /*\"ID\" диалога должно быть числом.*/\r\n    name: string /*Имя, с кем ведется диалог, должно быть строкой.*/\r\n    avatar: AvatarSourceType /*Аватар того, с кем ведется диалог, должен быть типа \"AvatarSourceType\".*/\r\n};\r\n\r\n\r\n/*\r\n\"DialogItem\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function DialogItem(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"DialogItem\" является компонентом, который описывает, как должны выглядеть диалоги.\r\nЭтот компонент подключается в компоненте \"Dialogs\".\r\n*/\r\nconst DialogItem: React.FC<PropsType> = ({id, name, avatar}) => { /*При помощии деструктуризации \"props\"\r\nуказываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.id\", \"props.name\" и так далее:\r\n- \"id\" - \"ID\" диалога;\r\n- \"name\" - имя, с кем ведется диалог;\r\n- \"avatar\" - аватар того, с кем ведется диалог.\r\nТакое мы делаем только в функциональных компонентах. Указали при помощи \"React.FC<>\", что \"props\" в этом\r\nфункциональном компоненте имеют тип \"PropsType\".*/\r\n    let path = '/dialogs/' + id; /*Путь для \"NavLink\" формируется на основе \"ID\" пользователя, который берется из\r\n    параметров \"props\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.dialog}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовой пункт диалогов, который будет отрисовываться в компоненте \"Dialogs\"\r\n        при помощи метода \"map\".*/}\r\n            <img src={avatar} alt=''/> {/*Пункт диалога содержит аватар пользователя, ссылка на который берется\r\n            из параметров \"props\".*/}\r\n\r\n            <NavLink to={path} activeClassName={styles.active}>{name}</NavLink> {/*А также пункт диалога содержит\r\n            элемент \"NavLink\" с именем пользователя, которое берется из параметров \"props\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default DialogItem; /*Экспортируем компонент \"DialogItem\" по default и будем его использовать в нашем проекте под\r\nименем \"DialogItem\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './../Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {AvatarSourceType} from '../../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    id: number /*\"ID\" исходящего сообщения должно быть числом. Мы это здесь не используем, но указываем, так как\r\n    передаем этот \"ID\" в компоненте \"Dialogs\" в компонент \"Message\" при использовании функции \"map\".*/\r\n    message: string /*Текст исходящего сообщения должно быть строкой.*/\r\n    avatar: AvatarSourceType /*Аватар того, от кого отправлено исходящее сообщение, должен быть типа\r\n    \"AvatarSourceType\".*/\r\n};\r\n\r\n\r\n/*\r\n\"Message\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Message(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Message\" является компонентом, который описывает, как должны выглядеть исходящие сообщения.\r\nЭтот компонент подключается в компоненте \"Dialogs\".\r\n*/\r\nconst Message: React.FC<PropsType> = ({message, avatar}) => { /*При помощии деструктуризации \"props\"\r\nуказываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.message\" и так далее:\r\n- \"message\" - текст исходящего сообщения;\r\n- \"avatar\" - аватар того, от кого отправлено исходящее сообщение.\r\nТакое мы делаем только в функциональных\r\nкомпонентах. Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.message}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовое отображение исходящих сообщений, которое будет отрисовываться в\r\n        компоненте \"Dialogs\" при помощи метода \"map\".*/}\r\n            <img src={avatar} alt=\".\"/> {/*Исходящее сообщение содержит аватар пользователя, ссылка на который\r\n            берется из параметров \"props\".*/}\r\n\r\n            {message} {/*Также исходящее сообщение содержит текст этого сообщения, которое берется из\r\n            параметров \"props\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default Message; /*Экспортируем компонент \"Message\" по default и будем его использовать в нашем проекте под\r\nименем \"Message\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\n\r\nimport styles from './../Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport {AvatarSourceType} from '../../../types/types'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"props\". \"Props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.\r\nВсе это нужно для указания типа \"props\" в функциональном компоненте.*/\r\ntype PropsType = {\r\n    id: number /*\"ID\" входящего сообщения должно быть числом. Мы это здесь не используем, но указываем, так как передаем\r\n    этот \"ID\" в компоненте \"Dialogs\" в компонент \"IncomingMessage\" при использовании функции \"map\".*/\r\n    message: string /*Текст исходящего сообщения должно быть строкой.*/\r\n    avatar: AvatarSourceType /*Аватар того, от кого отправлено входящее сообщение, должен быть типа\r\n    \"AvatarSourceType\".*/\r\n};\r\n\r\n\r\n/*\r\n\"IncomingMessage\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function IncomingMessage(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"IncomingMessage\" является компонентом, который описывает, как должны выглядеть входящие сообщения.\r\nЭтот компонент подключается в компоненте \"Dialogs\".\r\n*/\r\nconst IncomingMessage: React.FC<PropsType> = ({message, avatar}) => { /*При помощии деструктуризации \"props\"\r\nуказываем какие именно \"props\" мы получаем, чтобы не писать далее \"props.message\" и так далее:\r\n- \"message\" - текст исходящего сообщения;\r\n- \"avatar\" - аватар того, от кого отправлено исходящее сообщение.\r\nТакое мы делаем только в функциональных\r\nкомпонентах. Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип \"PropsType\".*/\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.incomingMessage}> {/*Этот элемент \"div\" и есть наш корневой элемент.\r\n        Этот элемент представляет из себя типовое отображение входящих сообщений, которое будет отрисовываться в\r\n        компоненте \"Dialogs\" при помощи метода \"map\".*/}\r\n            {message} {/*Исходящее сообщение содержит текст этого сообщения, которое берется из\r\n            параметров \"props\".*/}\r\n\r\n            <img src={avatar} alt='.'/> {/*Также исходящее сообщение содержит аватар пользователя, ссылка\r\n            на который берется из параметров \"props\".*/}\r\n        </div>\r\n    )\r\n};\r\n\r\n\r\nexport default IncomingMessage; /*Экспортируем компонент \"IncomingMessage\" по default и будем его использовать в нашем\r\nпроекте под именем \"IncomingMessage\", экспорт необходим для импорта.*/","import React from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\n*/\r\nimport {InjectedFormProps, reduxForm} from 'redux-form';\r\n/*\r\nБиблиотека \"redux-form\" нужна для работы с формами.\r\nЭта библиотека добавляет в \"store\", то есть в глобальный \"state\" свой \"reducer\" и\r\nобрабатывает какую-то свою ветку данных. Эта ветка процессит все формы на сайте, что позволяет нам меньше делать работы\r\nорганизации данных форм в \"state\".\r\nЭта библиотека предоставляет специальный HOC. Задача компонента, которым этот HOC обвернет другой компонент,\r\nявляется общаться со своей частью в \"reducer\".\r\nЭта библиотека является устаревшей, поэтому лучше использовать более актуальные аналоги, например, \"react-final-form\",\r\nкоторый работыет на хуках. Так же может подойти \"formik\".\r\nЭта библиотека, добавляя свою часть в глобальный \"state\", обязуется заниматься круговоротом данных (FLEX) со всеми\r\nформами в приложении. То есть нам самим не нужно будет что-то диспатчить. Часть \"state\", которую создает эта библиотека,\r\nне является по сути данными, относящимися к BLL, но при этом находятся в глобальном \"state\".\r\nТакже эта библиотека упрощает создание валидации форм, так как в ее \"state\" есть полезные для этого данные (поля и\r\nсвойства).\r\nТак же стоит помнить, что дефолтное поведение кнопки при \"submit\" это отправка данных на сервер,\r\nчто является индикатором для перерисовки в React.\r\nПосле создания части в глобальном \"state\", нужно необходимые формы обварачивать в HOC \"reduxForm\" из библиотеки\r\n\"redux-form\" (как и метод \"connect\", метод \"reduxForm\" не совсем является HOC, он вызывается дважды, сначала мы\r\nвызываем функцию \"reduxForm\" и настраиваем ее, а потом она уже вернет нам некий HOC, и этим HOC при помощи замыкания\r\nмы обворачиваем форму, вследствие чего вокруг компонента с формой появится контейненый компонент, который будет\r\nдиспатчить и общаться с глобальным \"state\").\r\nКаждой форме нужно давать уникальное имя, чтобы не появилось проблем с библиотекой \"redux-form\".\r\nВместо \"input\" необходимо использовать \"Field\" из библиотеки \"redux-form\". Указывая в нем атрибут \"component\", мы\r\nуказываем какой элемент нужно отрисовать. Другие указанные атрибуты перейдут в отрисованный элемент. Также необходимо\r\nуказывать атрибут \"name\", чтобы дать имя отправляемым через этот \"input\" данным. Библиотека \"redux-form\" будет\r\nреагировать на эти атрибуты \"name\" и осуществлять круговорот данных.\r\n\r\nДля получения данных при \"submit\" есть особый callback \"handleSubmit\" в \"props\", который создается при обворачивании\r\n\"reduxForm\". В форме в событии \"onSubmit\" нужно указывать этот callback. В этом callback отключено дефолтное поведение\r\nпо перезагрузке страницы. Также в нем идет сбор всех данных и они упаковываются в объект, а затем вызывается\r\n\"props.onSubmit()\" у родителя (то есть у контейнерного компонента над компонентом с формой), в который передается этот\r\nобъект с данными. То есть мы должны в контейнерный компонент над компонентом с формой передать некий метод,\r\nсрабатывающий при событии \"onSubmit\". Этот некий метод будет использоваться для передачи данных формы во внешний мир,\r\nто есть в глобальный \"state\".\r\n\r\nТо есть в нашем случае происходит следующее:\r\n- callback \"handleSubmit\" указан в компоненте \"AddMessageForm\".\r\n- обворачиваем компонент \"AddMessageForm\" HOC-ом \"reduxForm\" в компоненте \"AddMessageReduxForm\", тем самым предоставляя\r\ncallback \"handleSubmit\" для компонента \"AddMessageForm\".\r\n- компонент \"AddMessageReduxForm\" указывается в компоненте \"Dialogs\", куда в событие \"onSubmit\" будет попадать объект\r\nс данными, сформированный в событии \"onSubmit\" при помощи callback \"handleSubmit\" в компоненте \"AddMessageForm\".\r\n\r\nТо есть при срабатывании события \"onSubmit\" сначала вызывается callback \"handleSubmit\" в компоненте \"AddMessageForm\",\r\nкоторый собирает все данные из формы и помещает их в объект, потом внутри callback \"handleSubmit\" вызывается нами\r\nсозданный callback \"addNewMessage\" (доступен из контейнерного компонента \"AddMessageReduxForm\") из компонента \"Dialogs\",\r\nв который передается указанный объект с данными и собираются в одном месте, потом эти данные передаются в компонент\r\n\"AddMessageReduxForm\", из которого перенаправляются в глобальный \"state\" в виде объекта под именем\r\n\"dialogAddMessageForm\".\r\n\r\nТо есть общая логика при работе с библиотекой \"redux-form\" такова:\r\n- вынести саму форму в отдельный компонент;\r\n- повесить callback \"handleSubmit\" в качестве обработчика события \"onSubmit\" в этой форме;\r\n- в этой форме вместо элементов \"input\" и прочего используем элемент \"Field\";\r\n- обворачиваем эту форму HOC-ом \"reduxForm\".\r\n\r\nВ компонент \"AddMessageForm\" внедряются некие дополнительные \"props\" (например, тот же \"handleSubmit\") ХОКом, который\r\nобразуется при помощи компонента \"AddMessageReduxForm\". Эти \"props\" содержатся под именем \"InjectedFormProps\". Эти\r\n\"InjectedFormProps\" также содержат добавленные нами \"props\". Поэтому мы импортировали \"InjectedFormProps\" из библиотеки\r\n\"reduxForm\", чтобы типизировать такие \"props\" в компоненте \"AddMessageForm\".\r\n*/\r\nimport {maxLengthCreator, required} from '../../utils/validators/validators'; /*Подключаем валидаторы для полей форм.*/\r\nimport {createField, GetValuesKeysType, Textarea} from '../common/FormsControls/FormsControls'; /*Подключаем созданный\r\nнами компонент \"Textarea\" для создания элемента \"textarea\" с возможностью указывать валидацию. Также импортируем\r\nфункцию \"createField\", которая принимает параметры и создает элементы формы. Мы ее используем для создания формы в\r\nкомпоненте \"AddMessageForm\". Дополнительно импортируем оттуда тип \"GetValuesKeysType\".*/\r\n\r\nimport styles from './Dialogs.module.css'; /*Подключаем стили из CSS-модуля.*/\r\n\r\nimport DialogItem from './DialogItem/DialogItem'; /*Подключаем компонент \"DialogItem\".*/\r\nimport Message from './Message/Message'; /*Подключаем компонент \"Message\".*/\r\nimport IncomingMessage from './IncomingMessage/IncomingMessage'; /*Подключаем компонент \"IncomingMessage\".*/\r\n\r\nimport {InitialDialogsStateType} from '../../redux/dialogs-reducer'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем общий тип для всех \"props\" компонента \"Dialogs\" . Все это нужно для указания типа \"props\" в функциональном\r\nкомпоненте \"Dialogs\".*/\r\ntype DialogsPropsType = {\r\n    dialogsPage: InitialDialogsStateType /*Поскольку передаем в этот компонент весь \"state\" из \"dialogs-reducer.ts\",\r\n    то указываем тип \"InitialDialogsStateType\" - это тип всего этого \"state\" из \"dialogs-reducer.ts\".*/\r\n    addMessage: (newMessageText: string) => void /*AC для добавления нового исходящего сообщения, который принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n};\r\n\r\n/*Создаем тип для \"собственных props\" компонента \"AddMessageForm\". \"Собственные props\" в этом компоненте должны\r\nобязательно содержать следующие поля с указанными типами.*/\r\ntype AddMessageFormOwnPropsType = {}; /*Указываем пустой объект, так как компонент \"AddMessageForm\" не содержит\r\n\"собственных props\". По идее это можно в данном случае вообще не указывать.*/\r\n\r\n/*Создаем тип для \"props\" компонента \"AddMessageForm\", которые будут использоваться в \"formData\" для компонента\r\n\"Dialogs\". Эти \"props\" в этом компоненте должны обязательно содержать следующие поля с указанными типами.*/\r\ntype AddMessageFormValuesType = {\r\n    newMessageText: string /*Текст исходящего сообщения, который должен быть строкой.*/\r\n};\r\n\r\n/*Следующий тип мы создали специально, чтобы мы не могли допустить ошибку при указании свойства \"name\" в \"createField\".\r\nЭто свойство важно для формирования имен свойств \"formData\", то есть данных формы. Для этого мы использовали созданный\r\nнами и иимпортированный сюда вспомогательный тип \"GetValuesKeysType\". Нужные нам имена свойств уже перечислены в типе\r\n\"AddMessageFormValuesType\", поэтому мы при помощи этого типа \"GetValuesKeysType\" получаем типы ключей из типа\r\n\"AddMessageFormValuesType\".*/\r\ntype AddMessageFormValuesKeysType = GetValuesKeysType<AddMessageFormValuesType>;\r\n\r\n\r\nconst maxLength10 = maxLengthCreator(10); /*Создали валидатор, который проверяет не введено ли больше 10\r\nсимволов в поле.*/\r\n\r\n\r\n/*\r\n\"AddMessageForm\" это функциональный компонент, который создан в виде стрелочной функции.\r\nФункциональный компонент можно создать еще и таким образом: function AddMessageForm(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"AddMessageForm\" является компонентом, который представляет из себя форму для добавления исходящих сообщений\r\nв диалогах в виде заготовки для обворачивания ее в HOC \"reduxForm\".\r\nЭтот компонент подключается в компоненте \"AddMessageReduxForm\" и обварачивается там в HOC \"reduxForm\", тем самым\r\nполучая callback \"handleSubmit\".\r\n*/\r\nconst AddMessageForm:\r\n    React.FC<InjectedFormProps<AddMessageFormValuesType, AddMessageFormOwnPropsType> & AddMessageFormOwnPropsType> =\r\n    ({handleSubmit}) => {\r\n    /*При помощии деструктуризации \"props\" указываем какие именно \"props\" мы получаем, чтобы не писать далее\r\n    \"props.handleSubmit\". Такое мы делаем только в функциональных компонентах.\r\n    Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном компоненте имеют тип\r\n    \"InjectedFormProps<AddMessageFormValuesType, AddMessageFormOwnPropsType> & AddMessageFormOwnPropsType>\". Такая\r\n    комбинация получилась следующим образом:\r\n    - \"InjectedFormProps<AddMessageFormValuesType, AddMessageFormOwnPropsType>\" - здесь мы уточнили внедренные ХОКом,\r\n    который образуется при помощи компонента \"AddMessageReduxForm\", \"InjectedFormProps\". \"AddMessageFormValuesType\"\r\n    указывает, что приходит из этого ХОКа, а \"AddMessageFormOwnPropsType\" указывает, что приходит со стороны - в нашем\r\n    случае ничего.\r\n    - \"& AddMessageFormOwnPropsType\" - также этот компонент содержит некие свои собственные \"props\", которые не приходят\r\n    от ХОКа выше.\r\n    Это мы сделали на основании файла декларации \"InjectedFormProps\" (\"Ctrl+click\" в \"WebStorm\"). Там указано, что\r\n    первым параметром принимаются \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого\r\n    обворачиваем \"reduxForm\" (то есть компонент \"AddMessageForm\"), и собственные \"props\" этого компонента\r\n    \"AddMessageForm\", которые не приходят от ХОКа выше (так нужно для внутренней работы \"InjectedFormProps\"); а вторым\r\n    параметром принимаются еще раз некие свои собственные \"props\", которые не приходят от ХОКа выше (так уже надо для\r\n    работы самого этого компонента \"AddMessageForm\"). Третьим параметром принимается вид ошибки формы типа строка, но\r\n    данном случае мы этого не указываем. Только все эти три параметра указываются как бы вместе как единый параметр, а\r\n    не через запятую как три разных параметра. ВОЗМОЖНО, это потому, что \"InjectedFormProps\" это объект (как единое\r\n    целое состоит из разных свойств, которые можно типизировать суммой разных типов), а тот же \"reduxForm\" это функция\r\n    (принимает последовательность параметров, где каждый параметр нужно отдельно типизировать).\r\n    */\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <form onSubmit={handleSubmit}> {/*Здесь в элементе \"form \"в событии \"onSubmit\" указываем callback\r\n        \"handleSubmit\". Этот элемент \"form\" и есть наш корневой элемент\"*/}\r\n            <div> {/*Создаем элемент \"div\", в котором создадим поле для ввода текста исходящего сообщения при помощи\r\n            импортированной функции \"createField\".*/}\r\n                {createField<AddMessageFormValuesKeysType>\r\n                (\"Enter your message\", \"newMessageText\", Textarea, [required, maxLength10])}\r\n                {/*Создали поле для ввода исходящего сообщения на основе импортированной функции \"createField\". Уточняем\r\n                здесь функцию \"createField\", что она имеет тип \"AddMessageFormValuesKeysType\", созданный нами выше.*/}\r\n            </div>\r\n\r\n            <div> {/*Создаем специальный элемент \"div\", внутри которого будет находится элемент \"button\", который будет\r\n            использоваться как кнопка для сабмита данных введенных в форму.*/}\r\n                <button>Add message</button>\r\n            </div>\r\n        </form>\r\n    )\r\n};\r\n\r\n\r\n/*Это отдельный контейнерный компонент, цель которого обвернуть компонент \"AddMessageForm\" в HOC \"reduxForm\", чтобы\r\nпредоставить callback \"handleSubmit\". Именно компонент \"AddMessageReduxForm\" будет заниматься общением\r\nс глобальным \"state\".*/\r\nconst AddMessageReduxForm = reduxForm<AddMessageFormValuesType, AddMessageFormOwnPropsType>({ /*\"reduxForm\"\r\nявляется \"generic\", поэтому мы его уточнили. В файле декларации \"reduxForm\" (\"Ctrl+click\" в \"WebStorm\") указано, что он\r\nпринимает следующие данные:\r\n- \"formData\" - то есть какие именно данные собирает форма в компоненте, вокруг которого обворачиваем \"reduxForm\" (то\r\nесть компонент \"AddMessageForm\");\r\n- \"собственные props\" компонента, вокруг которого обворачиваем \"reduxForm\" (то есть компонент \"AddMessageForm\");\r\n- вид ошибки формы типа строка, но данном случае мы этого не указываем.*/\r\n    form: 'dialogAddMessageForm' /*Это то самое уникальное имя для данных этой формы, которые будут попадать\r\n    в глобальный \"state\".*/\r\n})(AddMessageForm);\r\n\r\n\r\n/*\r\n\"Dialogs\" это функциональный компонент, который создан в виде стрелочной функции.\r\nПри взаимодействии с функциональным компонентом React не хранит его постоянно в памяти.\r\nReact вызывает функциональный компонент, он делает свою работу (например, возвращает JSX) и компонент удаляется\r\nиз памяти.\r\nФункциональный компонент можно создать еще и таким образом: function Dialogs(props) {тело}.\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\n\"Dialogs\" является компонентом, который отображает диалоги.\r\nЭтот компонент подключается в компоненте \"DialogsContainer\".\r\nВнутри компонента \"Dialogs\" подключаются компоненты:\r\n- \"DialogItem\", который описывает, как должны выглядеть диалоги;\r\n- \"Message\", который описывает, как должны выглядеть исходящие сообщения;\r\n- \"IncomingMessage\", который описывает, как должны выглядеть входящие сообщения;\r\n- \"AddMessageReduxForm\", в котором обворачиваем компонент \"AddMessageForm\" HOC-ом \"reduxForm\",\r\nтем самым предоставляя callback \"handleSubmit\" для компонента \"AddMessageForm\".\r\n*/\r\nconst Dialogs: React.FC<DialogsPropsType> = ({dialogsPage, addMessage}) => { /*Указываем какие именно\r\n\"props\" мы получаем, чтобы не писать далее \"props.dialogsPage\" и так далее:\r\n- \"dialogsPage\" - весь \"state\" из \"dialogs-reducer.ts\";\r\n- \"addMessage\" - AC для добавления нового исходящего сообщения.\r\nТакое мы делаем только в функциональных компонентах.Указали при помощи \"React.FC<>\", что \"props\" в этом функциональном\r\nкомпоненте имеют тип \"DialogsPropsType\", созданный нами выше.*/\r\n\r\n    /*\r\n    В JSX в массив можно вкладывать компоненты.\r\n    В React, если мы передаем какой-либо массив, то JSX отобразит каждый элемент этого массива в виде строки.\r\n    \"map\" - это метод массива из JS, который позволяет создать новый массив на основе преобразования исходного массива.\r\n    Метод \"map\" принимает стрелочную функцию.\r\n    То есть в нашем случае будет сначала браться первый объект из исходного массива объектов\r\n    и на основе данных этого объекта будет формироваться первый элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    Потом будет браться следующий объект из исходного массива объектов\r\n    и на основе данных уже этого объекта будет формироваться следующий элемента нового массива, который\r\n    будет из себя представлять JSX компонента, указанного в стрелочной функции.\r\n    И так будет продолжаться до тех пор, пока мы не переберем все объекты в изначальном массиве объектов.\r\n    То есть переданная в метод \"map\" стрелочная функция вызывается столько раз, сколько элементов в изначальном массиве\r\n    объектов.\r\n    В итоге получится новый массив с элементами в виде компонентов, построенными на основе данных из BLL.\r\n    Вызвав такой массив в JSX мы отобразим наши компоненты.\r\n    Массив \"dialogsElements\" содержит диалоги пользователя.\r\n    Массив \"messagesElements\" содержит исходящие сообщения пользователя.\r\n    Массив \"incomingMessagesElement\" содержит входящие сообщения пользователя.\r\n    При использовании метода \"map\" нужно указывать атрибут \"key\" для избежания ошибок.\r\n    */\r\n    let dialogsElements = dialogsPage.dialogs.map(d => <DialogItem name={d.name}\r\n                                                                         id={d.id}\r\n                                                                         avatar={d.avatar}\r\n                                                                         key={d.id}/>);\r\n\r\n    let messagesElements = dialogsPage.messagesData.map(m => <Message id={m.id}\r\n                                                                            message={m.message}\r\n                                                                            avatar={m.avatar}\r\n                                                                            key={m.id}/>);\r\n\r\n    let incomingMessagesElement = dialogsPage.incomingMessagesData.map(im => <IncomingMessage id={im.id}\r\n                                                                                                   message={im.message}\r\n                                                                                                   avatar={im.avatar}\r\n                                                                                                   key={im.id}/>);\r\n\r\n    let addNewMessage = (formData: AddMessageFormValuesType) => { /*Создали специальный callback \"addNewMessage\",\r\n    который будет вызываться при срабатывании события \"onSubmit\" в форме. Этот callback будет собирать все данные формы\r\n    (текст исходящего сообщения) в одном месте. Эти данные будут отдаваться AC \"addMessage\" для добавляния нового\r\n    исходящего сообщения. Этот callback получает указанные данные на входе в объекте \"formData\" с типом\r\n    \"AddMessageFormValuesType\".*/\r\n        addMessage(formData.newMessageText); /*Здесь мы вызываем AC \"addMessage\", полученный из \"props\", и\r\n        передаем ему текст исходящего сообщения.*/\r\n        formData.newMessageText = ''; /*После вывода исходящего сообщения зануляем поле для ввода текста.*/\r\n    };\r\n\r\n    /*\r\n    Здесь после return в компоненте начинается HTML разметка.\r\n    Нужно помнить, что в этой разметке должен быть только один корневой элемент.\r\n    Поскольку то, что возвращает return указано с новой строки, поэтому все возвращаемое помещено в круглые скобки.\r\n    */\r\n    return (\r\n        <div className={styles.dialogs}> {/*Этот элемент \"div\" и есть наш корневой элемент.*/}\r\n            <div className={styles.dialogsItems}>{dialogsElements}</div> {/*Этот элемент \"div\" содержит список\r\n            диалогов.*/}\r\n\r\n            <div className={styles.messages}> {/*Этот элемент \"div\" содержит внутри два других элемента \"div\".*/}\r\n                <div>{messagesElements}</div> {/*Этот элемент \"div\" содержит исходящие сообщения.*/}\r\n                <AddMessageReduxForm onSubmit={addNewMessage}/> {/*Здесь в событии \"onSubmit\" будет приходить объект с\r\n                данными из callback \"handleSubmit\" из компонента \"AddMessageForm\", который обвернут\r\n                компонентом \"AddMessageReduxForm\". Далее будет вызываться при этом событии нами созданный\r\n                callback \"addNewMessage\", в который будет передаваться этот объект с данными. После этого эти данные\r\n                будут отправлятся в часть глобального \"state\", которую обрабатывает библиотека\"redux-form\", с целью\r\n                осуществления работы нашей формы логина. Поскольку мы вызываем функцию \"addNewMessage\" как callback,\r\n                поэтому не ставим \"()\" после имени функции. Но теперь после отправки сообщения окно для ввода текста\r\n                сообщения не будет очищаться, так как библиотека \"redux-form\" хоть и осуществляет FLUX-круговорот,\r\n                но очистку не осуществляет.*/}\r\n            </div>\r\n\r\n            <div className={styles.incomingMessages}>{incomingMessagesElement}</div> {/*Этот элемент \"div\" содержит\r\n            входящие сообщения.*/}\r\n        </div>\r\n    );\r\n};\r\n\r\n\r\nexport default Dialogs; /*Экспортируем компонент \"Dialogs\" по default и будем его использовать в нашем проекте под\r\nименем \"Dialogs\", экспорт необходим для импорта.*/","import React, {ComponentType} from 'react';\r\n/*\r\nПодключаем сам \"ReactJS\", необходим везде, где мы что-то из него используем (например, JSX).\r\n\"WebPack\" уже встроен в \"ReactJS\".\r\nИмпортируем \"ComponentType\" для типизации.\r\n*/\r\nimport {connect} from 'react-redux';\r\n/*\r\nБиблиотека \"react-redux\" является прослойкой между UI (react) и BLL (redux).\r\nЭта прослойка необходима потому, что UI нежелательно общаться с BLL напрямую.\r\nБиблиотека \"react-redux\" предоставляет продвинутые инструкции по созданию контейнерных компонент и контекста.\r\nМетод \"connect\" это HOC. Точнее он возвращает HOC, а этот HOC получает компонент и обрабатывает его.\r\nHOC - high order component (компонента высшего порядка).\r\nHOC - это функция, которая принимает на входе один компонент, обворачивает его, чтобы передать какие-то данные, и\r\nна выходе возвращает другой компонент.\r\nHOC позволяет создавать однообразные контейнерные компоненты.\r\nМетод \"connect\" используется для создания компонентов и контейнеров.\r\nМетод \"connect\" знает о нашем \"store\" из \"redux\" и сам передает данные оттуда в указанный компонент.\r\nМетод \"connect\" упрощает перекидывание \"props\".\r\nМетод \"connect\" имеет улучшенную оптимизацию перерисовки, т.к он перерисовывает только нужную часть \"Virtual DOM\".\r\nПри помощи метода \"connect\" можно удобно создавать контейнерные компоненты.\r\nУ метода \"connect\" есть свои аналоги \"getState\", \"subscribe\", \"callSubscriber\", \"dispatch\".\r\nМетод \"connect\" вызывается дважды - первый раз он вызывается с параметрами ((две функции)) ввиде данных \"state\" (функция\r\n\"mapStateToProps\") и \"dispatch\" (наши callbacks - \"AC\" или \"TC\", функция \"mapDispatchToProps\"), причем в первую функцию\r\nметод \"connect\" закинет весь \"state\" из \"store\", а во вторую функцию закинет \"store.dispatch.bind(store)\", т.е. наши\r\ncallbacks и потом будет возвращать другую функцию, затем вызывается эта возвращенная функция с параметрами ввиде\r\nуказанного компонента. При каждом изменении \"state\" вызывается функция \"mapStateToProps\", формируется новый объект\r\nс данными из \"state\" и сравнивается со старым объектом с данными из \"state\" (их внутренности).\r\nЕсли были изменения в нужной для компонента части \"state\", которая указана в функции \"mapStateToProps\",\r\nто метод \"connect\" перерисовывает компонент. Именно поэтому в \"reducers\" мы создаем копии \"state\". Если создается копия\r\n\"state\", то получается, что идет ссылка на другой объект. Исходя из этого \"connect\" считает, что были изменения.\r\nКогда мы импортируем объекты или функции в классовые компоненты, то на самом деле мы создаем ссылки на них. Например,\r\nAC или TC в контейнерной компоненте это ссылки на AC или TC из \"reducers\". Учитывая это, в метод \"connect\" можно сразу\r\nуказывать AC или TC, так как connect создает контейнерную классовую компоненту и сам может создавать callbacks вокруг\r\nAC или TC, как это делается в функции \"mapDispatchToProps\". И тогда функцию \"mapDispatchToProps\" можно не писать.\r\n\"Provider\" необходим для создания контекста, из которого компоненты (особенно контейнерные) могут брать данные\r\nBLL и DAL.\r\n*/\r\nimport {compose} from 'redux';\r\n/*\r\nФункция \"compose\" из функционального программирования. Эта функция создает композицию обработчиков.\r\nБиблиотека \"redux\" содержит свою реализацию \"compose\". При помощи функции \"compose\" можно объеденять, например,\r\nнесколько обверток вокруг компонента и HOCs.\r\nОбвертки и HOCs указываются снизу вверх. Функция \"compose\" вызывается дважды и работает схожим образом, как и метод\r\n\"connect\" из библиотеки \"react-redux\".\r\n*/\r\n\r\nimport Dialogs from './Dialogs'; /*Подключаем компонент \"Dialogs\".*/\r\n\r\nimport {withAuthRedirect} from '../../hoc/WithAuthRedirect'; /*Подключаем созданый нами HOC \"withAuthRedirect\" для\r\nдобавления редиректа.*/\r\n\r\nimport {dialogsAC, InitialDialogsStateType} from '../../redux/dialogs-reducer'; /*Подключаем объект \"dialogsAC\", что\r\nиспользовать оттуда AC \"addMessageActionCreator\" из \"dialogs-reducer\". Также подключаем типы оттуда.*/\r\n\r\nimport {AppStateType} from '../../redux/redux-store'; /*Подключаем типы.*/\r\n\r\n\r\n/*Создаем тип для \"MapStateToProps\". \"MapStateToProps\" в этом компоненте должен обязательно содержать следующие поля с\r\nуказанными типами.*/\r\ntype MapStateToPropsType = {\r\n    dialogsPage: InitialDialogsStateType /*Поскольку передаем в этот компонент весь \"state\" из \"dialogs-reducer.ts\",\r\n    то указываем тип \"InitialDialogsStateType\" - это тип всего этого \"state\".*/\r\n};\r\n\r\n/*Создаем тип для \"MapDispatchToProps\". \"MapDispatchToProps\" в этом компоненте должен обязательно содержать следующие\r\nполя с указанными типами.*/\r\ntype MapDispatchToPropsType = {\r\n    addMessage: (newMessageText: string) => void /*AC для добавления нового исходящего сообщения, который принимает\r\n    строковой параметр и ничего не возвращает.*/\r\n};\r\n\r\n\r\n/*\r\n\"DialogsContainer\" это не классовый компонент и не функциональный компонент.\r\n\"DialogsContainer\" является только контейнерным компонентом для компонента \"Dialogs\".\r\nВ отличии от классового компонента, этот компонент не имеет методов жизненного цикла.\r\nКонтейнерные компоненты обварачивают презентационные компоненты и передают им данные BLL и DAL.\r\nЭти данные в нашем приложении контейнерные компоненты получают из контекста,\r\nсозданного при помощи \"Provider\" (указан в \"App.tsx\") из библиотеки \"react-redux\".\r\nКомпонент это функция, которая возвращает JSX.\r\nJSX совмещает в себе JS и HTML.\r\nВ JSX для указания класса в стилях нужно использовать \"className\" вместо \"class\".\r\nВ JSX скобки {} позволяют использовать JS-код внутри HTML-кода.\r\nКаждый компонент это новый тег для ReactJS, и эти теги используются для вызова этих компонентов.\r\nТеги компонентов можно вкладывать друг в друга, тем самым образуя дерево компонентов.\r\nКаждый компонент желательно помещать в отдельный файл.\r\nКаждый компонент всегда вызывается с объектом, внутри которого какие-то параметры.\r\nЕсли параметры не указаны, то им все равно передается пустой объект в качестве параметров.\r\nПринято объект с параметрами именовать как \"props\".\r\nВызывая тег компонента и передавая ему атрибуты, мы отдаем ему параметры.\r\nЭтот компонент подключается в компоненте \"App\".\r\nВ этом компоненте мы просто создаем \"mapStateToProps\" и \"mapDispatchToProps\", тем самым формируя \"props\"\r\nдля презентационной компоненты \"Dialogs\". Поэтому нам не нужно создавать классовый компонент для этого.\r\nТаким же образом созданы контейнерные компоненты \"MyPostsContainer\", \"NavbarContainer\".\r\n*/\r\n\r\n\r\nconst mapStateToProps = (state: AppStateType): MapStateToPropsType => { /*Здесь указываются данные из \"state\", которые\r\nнеобходимо передать в компонент \"Dialogs\". Эта функция возвращает указанные данные в виде объекта. На входе\r\n\"mapStateToProps\" принимает \"state\" с типом \"AppStateType\", который мы создали и импортировали сюда, а на выходе выдает\r\nданные с типом \"MapStateToPropsType\".*/\r\n    return {\r\n        dialogsPage: state.dialogsPage,\r\n    }\r\n};\r\n\r\n\r\nexport default compose<ComponentType>( /*При помощи функции \"compose\" объеденяем HOCs \"withAuthRedirect\" и \"connect\",\r\nвозвращая итоговый компонент \"DialogsContainer\". Здесь мы уточнили тип только одним параметром, так как согласно файлу\r\nдекларации функции \"compose\" (раздел \"rest\"), нам нужно уточнить только такой компонент, свойства \"props\" которого не\r\nбудут переданы в этот компонент функциями, которые были переданы внутрь функции \"compose\", то есть функциями \"connect\" и\r\n\"withRouter\", то есть никакие свойства, так как мы не передаем извне ничего в компонент \"Dialogs\".*/\r\n    connect<MapStateToPropsType, MapDispatchToPropsType, {}, AppStateType>(mapStateToProps,\r\n        {addMessage: dialogsAC.addMessage}), /*При помощи метода \"connect\" создаем контейнерный\r\n        компонент, и тем самым передаем нужные данные BLL и DAL компоненту \"Dialogs\". Поскольку метод \"connect\"\r\n        является \"generic\", то его можно уточнить: первым в \"<>\" указан тип для \"MapStateToProps\", вторым для\r\n        \"MapDispatchToProps\", третьим для \"собственных props\" компонента, четвертым для \"state\". Эти параметры мы узнали\r\n        перейдя в файл декларации метода \"connect\", \"Ctrl+click\" в \"WebStorm\".*/\r\n    withAuthRedirect /*При помощи HOC \"withAuthRedirect\" добавляем логику по редиректу в компонент.*/\r\n)(Dialogs);\r\n/*А также экспортируем получившийся в итоге компонент, который будет использоваться в нашем проекте под именем\r\n\"DialogsContainer\", по default, экспорт необходим для импорта.*/\r\n\r\n/*----------------------------------------------------------------------------------------------------*/\r\n\r\n/*Это старый вариант \"mapDispatchToProps\". Сейчас АС \"addMessage\" мы используем в функции \"connect\".\r\nЗдесь указываются данные (\"callbacks - \"AC\" или \"TC\") \"dispatch\", которые необходимо передать в компонент \"Dialogs\".\r\nЭта функция возвращает указанные данные в виде объекта.\r\nФункция \"mapDispatchToProps\" работает следующим образом:\r\n1) Компонент вызывает callback функцию \"addMessage\".\r\n2) Компонент передает этой функции параметр \"newMessageText\".\r\n3) Далее этот параметр передается в AC \"addMessageActionCreator\".\r\n4) Этот AC вызывается.\r\n5) Создается объект \"action\".\r\n6) Этот объект \"action\" диспатчится в \"dialogsReducer\" в \"dialogs-reducer.js\".*/\r\n/*const mapDispatchToProps = (dispatch) => {\r\n    return {\r\n        addMessage: (newMessageText) => {\r\n            dispatch(dialogsAC.addMessage(newMessageText));\r\n        }\r\n    }\r\n};*/"],"sourceRoot":""}